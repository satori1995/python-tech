<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>使用 collections 模块扩展你的数据类 - Python 实用技巧</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../如何优雅地遍历可迭代对象？/doc.html">如何优雅地遍历可迭代对象？</a></li><li class="chapter-item expanded "><a href="../解密可迭代对象的排序问题/doc.html">解密可迭代对象的排序问题</a></li><li class="chapter-item expanded "><a href="../通过 TOP K 问题，探究堆和优先队列的秘密/doc.html">通过 TOP K 问题，探究堆和优先队列的秘密</a></li><li class="chapter-item expanded "><a href="../如何优雅地对数据进行分组？/doc.html">如何优雅地对数据进行分组？</a></li><li class="chapter-item expanded "><a href="../全方位解析 f-string/doc.html">全方位解析 f-string</a></li><li class="chapter-item expanded "><a href="../最好的日期处理库：pendulum/doc.html">最好的日期处理库：pendulum</a></li><li class="chapter-item expanded "><a href="../你知道创建模块都有哪些方式吗？/doc.html">你知道创建模块都有哪些方式吗？</a></li><li class="chapter-item expanded "><a href="../exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？/doc.html">exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？</a></li><li class="chapter-item expanded "><a href="../文件处理的一些最佳实践/doc.html">文件处理的一些最佳实践</a></li><li class="chapter-item expanded "><a href="../使用 os 模块更高效地读写文件/doc.html">使用 os 模块更高效地读写文件</a></li><li class="chapter-item expanded "><a href="../将文件映射到内存，像数组一样访问/doc.html">将文件映射到内存，像数组一样访问</a></li><li class="chapter-item expanded "><a href="../使用 psutil 获取硬件、网络以及进程信息/doc.html">使用 psutil 获取硬件、网络以及进程信息</a></li><li class="chapter-item expanded "><a href="../使用临时文件保存数据/doc.html">使用临时文件保存数据</a></li><li class="chapter-item expanded "><a href="../shutil：更优雅地拷贝文件/doc.html">shutil：更优雅地拷贝文件</a></li><li class="chapter-item expanded "><a href="../使用 contextvars 管理上下文变量/doc.html">使用 contextvars 管理上下文变量</a></li><li class="chapter-item expanded "><a href="../自定义异常堆栈信息/doc.html">自定义异常堆栈信息</a></li><li class="chapter-item expanded "><a href="../prettytable：像数据库一样格式化输出内容/doc.html">prettytable：像数据库一样格式化输出内容</a></li><li class="chapter-item expanded "><a href="../轻松绘制动态条形图/doc.html">轻松绘制动态条形图</a></li><li class="chapter-item expanded "><a href="../自定义 jupyter 魔法命令/doc.html">自定义 jupyter 魔法命令</a></li><li class="chapter-item expanded "><a href="../解析 ini、yaml、toml 配置文件/doc.html">解析 ini、yaml、toml 配置文件</a></li><li class="chapter-item expanded "><a href="../使用 fuzzywuzzy 模块计算两个字符串之间的相似度/doc.html">使用 fuzzywuzzy 模块计算两个字符串之间的相似度</a></li><li class="chapter-item expanded "><a href="../命令行解析工具 argparse/doc.html">命令行解析工具 argparse</a></li><li class="chapter-item expanded "><a href="../使用 urllib.parse 模块优雅地处理 URL/doc.html">使用 urllib.parse 模块优雅地处理 URL</a></li><li class="chapter-item expanded "><a href="../Python 实现复制粘贴/doc.html">Python 实现复制粘贴</a></li><li class="chapter-item expanded "><a href="../Python 生成、解析二维码/doc.html">Python 生成、解析二维码</a></li><li class="chapter-item expanded "><a href="../解密 __getattr__ 和 __getattribute__ 的用法与区别/doc.html">解密 __getattr__ 和 __getattribute__ 的用法与区别</a></li><li class="chapter-item expanded "><a href="../使用 fcntl 模块对文件进行加解锁/doc.html">使用 fcntl 模块对文件进行加解锁</a></li><li class="chapter-item expanded "><a href="../详解新一代 HTTP 请求库：httpx/doc.html">详解新一代 HTTP 请求库：httpx</a></li><li class="chapter-item expanded "><a href="../通过 contextlib 模块详细复习一下 with 语句的用法/doc.html">通过 contextlib 模块详细复习一下 with 语句的用法</a></li><li class="chapter-item expanded "><a href="../使用 collections 模块扩展你的数据类/doc.html" class="active">使用 collections 模块扩展你的数据类</a></li><li class="chapter-item expanded "><a href="../使用 unicodedata 模块对字符串标准化/doc.html">使用 unicodedata 模块对字符串标准化</a></li><li class="chapter-item expanded "><a href="../使用 struct 模块打包、解包二进制数据/doc.html">使用 struct 模块打包、解包二进制数据</a></li><li class="chapter-item expanded "><a href="../使用 watchfiles 模块监控目录变更/doc.html">使用 watchfiles 模块监控目录变更</a></li><li class="chapter-item expanded "><a href="../读取照片的 Exif 信息/doc.html">读取照片的 Exif 信息</a></li><li class="chapter-item expanded "><a href="../模拟 TLS 指纹实现反反爬/doc.html">模拟 TLS 指纹实现反反爬</a></li><li class="chapter-item expanded "><a href="../生成词云/doc.html">生成词云</a></li><li class="chapter-item expanded "><a href="../你知道 Python 其实自带了小型数据库吗/doc.html">你知道 Python 其实自带了小型数据库吗</a></li><li class="chapter-item expanded "><a href="../聊一聊 Python 的换行以及转义/doc.html">聊一聊 Python 的换行以及转义</a></li><li class="chapter-item expanded "><a href="../分享一个 Python 处理音频的库/doc.html">分享一个 Python 处理音频的库</a></li><li class="chapter-item expanded "><a href="../pyquery：一个灵活方便的 HTML 解析库/doc.html">pyquery：一个灵活方便的 HTML 解析库</a></li><li class="chapter-item expanded "><a href="../生成并识别图片验证码/doc.html">生成并识别图片验证码</a></li><li class="chapter-item expanded "><a href="../数据解压缩/doc.html">数据解压缩</a></li><li class="chapter-item expanded "><a href="../用 Python 操作你的鼠标和键盘/doc.html">用 Python 操作你的鼠标和键盘</a></li><li class="chapter-item expanded "><a href="../itertools：用于处理可迭代对象的模块/doc.html">itertools：用于处理可迭代对象的模块</a></li><li class="chapter-item expanded "><a href="../通过 atexit 模块让 Python 实现 Golang 的 defer 功能/doc.html">通过 atexit 模块让 Python 实现 Golang 的 defer 功能</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 实用技巧</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/python-tech" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>Python 标准库提供了一个 collections 模块，里面提供了很多的数据类，在工作中使用这些类能够简化我们的开发。</p>
<p>下面就来看看这个模块能够帮助我们做哪些事情？</p>
<h2 id="搜索多个字典"><a class="header" href="#搜索多个字典">搜索多个字典</a></h2>
<p>假设当前有 3 个字典：dct1、dct2、dct3，现在要通过 key 查找对应的 value。如果 key 在 dct1 里面存在，那么直接返回，否则从 dct2 里面找。dct2 里面如果不存在，那么从 dct3 里面找。</p>
<p>这个需求该怎么实现呢？</p>
<pre><code class="language-python">dct1 = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
dct2 = {&quot;d&quot;: 4, &quot;e&quot;: 5, &quot;f&quot;: 6}
dct3 = {&quot;e&quot;: 7, &quot;f&quot;: 8, &quot;g&quot;: 9}

def get_value_by_key(key):
    if key in dct1:
        return dct1[key]
    elif key in dct2:
        return dct2[key]
    elif key in dct3:
        return dct3[key]
    else:
        raise KeyError

print(get_value_by_key(&quot;b&quot;))  # 2
print(get_value_by_key(&quot;d&quot;))  # 4
print(get_value_by_key(&quot;f&quot;))  # 6
</code></pre>
<p>实现起来非常简单，但通过 ChainMap 对象可以更方便地做到这一点。</p>
<pre><code class="language-python">from collections import ChainMap

dct1 = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
dct2 = {&quot;b&quot;: 4, &quot;c&quot;: 5, &quot;d&quot;: 6}

# 将多个字典传进去，
dct = ChainMap(dct1, dct2)

# 如果多个字典存在相同的 key，那么返回第一次出现的 key 对应的 value
print(dct[&quot;b&quot;], dct[&quot;d&quot;])
&quot;&quot;&quot;
2 6
&quot;&quot;&quot;

# 字典的 API 都可以使用
print(dct.items())
&quot;&quot;&quot;
ItemsView(ChainMap({'a': 1, 'b': 2, 'c': 3}, {'b': 4, 'c': 5, 'd': 6}))
&quot;&quot;&quot;

# 也可以使用 get，如果 key 在所有的字典中都不存在，则返回默认值
print(dct.get(&quot;k&quot;, 333))
&quot;&quot;&quot;
333
&quot;&quot;&quot;

# ChainMap 对象有一个 maps 属性，存储了要搜索的映射列表
# 这个列表是可变的，所以可以直接增加新映射，或者改变元素的顺序以控制查找和更新行为。
print(dct.maps)
&quot;&quot;&quot;
[{'a': 1, 'b': 2, 'c': 3}, {'b': 4, 'c': 5, 'd': 6}]
&quot;&quot;&quot;

# dct.maps 保存了原始的字典，修改 dct.maps 会影响原字典
print(dct1)
&quot;&quot;&quot;
{'a': 1, 'b': 2, 'c': 3}
&quot;&quot;&quot;
dct.maps[0][&quot;a&quot;] = 11111111
print(dct1)
&quot;&quot;&quot;
{'a': 11111111, 'b': 2, 'c': 3}
&quot;&quot;&quot;
# 同理修改原字典，也会影响 dct.maps
</code></pre>
<p>以上就是 ChainMap 对象的用法，当你需要从多个字典中进行搜索的话，它会很有用。</p>
<h2 id="统计可散列的对象"><a class="header" href="#统计可散列的对象">统计可散列的对象</a></h2>
<p>我们经常会遇到数量统计相关的问题，比如有一个序列，计算里面每个元素出现了多少次。一般情况下，我们会这么做。</p>
<pre><code class="language-python">words = [&quot;hello&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;beautiful&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;cruel&quot;, &quot;world&quot;]

counter = {}
for word in words:
    if word in counter:
        counter[word] += 1
    else:
        counter[word] = 1

print(counter)
&quot;&quot;&quot;
{'hello': 3, 'world': 3, 'beautiful': 1, 'cruel': 1}
&quot;&quot;&quot;
</code></pre>
<p>实现方法没有任何问题，但通过 Counter 会更方便，并且还提供了更多功能。</p>
<pre><code class="language-python">from collections import Counter

words = [&quot;hello&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;beautiful&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;cruel&quot;, &quot;world&quot;]

# 将序列传进去即可
counter = Counter(words)
print(counter)
&quot;&quot;&quot;
Counter({'hello': 3, 'world': 3, 'beautiful': 1, 'cruel': 1})
&quot;&quot;&quot;

# Counter 继承 dict，所以字典的 API 它也是都支持的
counter = Counter(hello=3, world=3, beautiful=1, cruel=1)
print(counter)
&quot;&quot;&quot;
Counter({'hello': 3, 'world': 3, 'beautiful': 1, 'cruel': 1})
&quot;&quot;&quot;
</code></pre>
<p>Counter 对象还支持动态更新操作，举个例子：</p>
<pre><code class="language-python">from collections import Counter

# Counter 需要接收一个可迭代对象，然后会遍历它
# 所以结果就是 a 出现了三次，b 出现了两次，c 出现了一次
counter = Counter(&quot;aaabbc&quot;)
print(counter)
&quot;&quot;&quot;
Counter({'a': 3, 'b': 2, 'c': 1})
&quot;&quot;&quot;

# 也可以动态更新，比如又来了一个序列，需要和当前的 counter 组合起来进行统计
counter.update(&quot;bcd&quot;)
print(counter)
&quot;&quot;&quot;
Counter({'a': 3, 'b': 3, 'c': 2, 'd': 1})
&quot;&quot;&quot;
# 可以看到 b 和 c 的值都增加了 1，并且出现了 d
# 需要注意的是：update 方法同样接收一个可迭代对象，然后进行遍历
# 如果我希望添加一个 key 叫 &quot;bcd&quot; 的话，那么要这么做
counter.update([&quot;bcd&quot;])
print(counter)
&quot;&quot;&quot;
Counter({'a': 3, 'b': 3, 'c': 2, 'd': 1, 'bcd': 1})
&quot;&quot;&quot;

# 访问计数，Counter 对象可以像字典一样访问
print(counter[&quot;a&quot;])  
&quot;&quot;&quot;
3
&quot;&quot;&quot;
# 如果访问一个不存在的 key，不会引发 KeyError
# 而是会返回 0，表示对象中没有这个 key
print(counter[&quot;mmp&quot;])  
&quot;&quot;&quot;
0
&quot;&quot;&quot;

# 还可以计算出现最多的元素，这是用的最频繁的一个功能
# 统计 string 中前三个出现次数最多的元素
string = &quot;sasaxzsdsadfscxzcasdscxzdfscxsasadszczxczxcsds&quot;
counter = Counter(string)
print(counter)
&quot;&quot;&quot;
Counter({'s': 13, 'c': 7, 'a': 6, 'x': 6, 'z': 6, 'd': 6, 'f': 2})
&quot;&quot;&quot;
print(counter.most_common(3))
&quot;&quot;&quot;
[('s', 13), ('c', 7), ('a', 6)]
&quot;&quot;&quot;
</code></pre>
<p>Counter 对象还有一个强大的功能，就是它支持算数操作以及位运算。</p>
<pre><code class="language-python">from collections import Counter

counter1 = Counter(&quot;aabbccc&quot;)
counter2 = Counter(&quot;bbbccdd&quot;)
print(counter1)  
print(counter2)  
&quot;&quot;&quot;
Counter({'a': 2, 'b': 2, 'c': 3})
Counter({'b': 3, 'c': 2, 'd': 2})
&quot;&quot;&quot;
# 如果 counter1 的元素出现在了 counter2 中，就把该元素减去，记住：减的是次数
print(counter1 - counter2)  
&quot;&quot;&quot;
Counter({'a': 2, 'c': 1})
&quot;&quot;&quot;
# a 在 counter1 中出现了 2 次，在 counter2 中没有出现，所以是 a: 2
# b 在 counter1 中出现了 2 次，在 counter2 中出现 3 次，所以一减就没有了
# c 在 counter1 中出现了 3 次，在 counter2 中出现 2 次，所以相减还剩下一次
# 至于 counter1 中没有的元素就不用管了


# 相加就很好理解了
print(counter1 + counter2) 
&quot;&quot;&quot;
Counter({'b': 5, 'c': 5, 'a': 2, 'd': 2}) 
&quot;&quot;&quot;

# 相交的话，查找公共的元素，并且取次数出现较小的那个
print(counter1 &amp; counter2)  
&quot;&quot;&quot;
Counter({'b': 2, 'c': 2})
&quot;&quot;&quot;

# 并集的话，取较大的，记住不是相加
# 所以 b 和 c 出现的次数不会增加，只是取较大的那个
print(counter1 | counter2)  
&quot;&quot;&quot;
Counter({'b': 3, 'c': 3, 'a': 2, 'd': 2})
&quot;&quot;&quot;
</code></pre>
<p>以上就是 Counter 的用法，更多的还是统计次数，求 topK。</p>
<h2 id="缺少的键返回默认值"><a class="header" href="#缺少的键返回默认值">缺少的键返回默认值</a></h2>
<p>很明显，这是针对于字典的。首先字典也支持这种操作，通过 setdefault 和 get 两个方法，可以用来获取 key 对应的 value，并且还能在 key 不存在的时候给一个默认值。</p>
<p>如果 key 存在，两者会获取 key 对应的 value；但如果 key 不存在，setdefault 会先将 key 和指定的默认值设置进去，然后再将设置的值返回，而 get 则只会返回默认值，不会进行设置。</p>
<pre><code class="language-python">d = {&quot;a&quot;: 1}
# 如果 key 存在，直接返回 value
print(d.get(&quot;a&quot;, 0))  # 1
print(d.setdefault(&quot;a&quot;, 0))  # 1
# 原字典不受影响
print(d)  # {&quot;a&quot;: 1}

# key 不存在，则返回指定的默认值
print(d.get(&quot;b&quot;, 0))  # 0
# 原字典不受影响
print(d)  # {&quot;a&quot;: 1}

# key 不存在的话，会将 key 和默认值组成键值对，设置在字典中
print(d.setdefault(&quot;b&quot;, 0))  # 0
print(d)  # {&quot;a&quot;: 1, &quot;b&quot;: 0}
</code></pre>
<p>指的一提的是，setdefault 是一个非常实用且简洁的方法，但用的却不多。我们举一个例子：</p>
<pre><code class="language-python">data = [
    (&quot;banana&quot;, 15), (&quot;banana&quot;, 17), (&quot;banana&quot;, 22),
    (&quot;apple&quot;, 31), (&quot;apple&quot;, 30), (&quot;apple&quot;, 33),
    (&quot;orange&quot;, 45), (&quot;orange&quot;, 47), (&quot;orange&quot;, 44),
]
# 如果我希望将 data 转成以下格式，该怎么办呢？
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;

def change_data1():
    result = {}
    for product, count in data:
        if product not in result:
            result[product] = [count]
        else:
            result[product].append(count)
    return result

print(change_data1())
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;

# 结果没问题，但如果用 setdefault 的话会更方便
def change_data2():
    result = {}
    for product, count in data:
        result.setdefault(product, []).append(count)
    return result

print(change_data2())
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;
</code></pre>
<p>但这个功能也可以通过 defaultdict 完成，该类要求调用者传递一个类型，当 key 不存在时会返回对应类型的零值。</p>
<pre><code class="language-python">from collections import defaultdict

d = defaultdict(int)
print(d)  # defaultdict(&lt;class 'int'&gt;, {})
print(d[&quot;a&quot;])  # 0
print(d)  # defaultdict(&lt;class 'int'&gt;, {'a': 0})

d = defaultdict(tuple)
print(d)  # defaultdict(&lt;class 'tuple'&gt;, {})
print(d[&quot;a&quot;])  # ()
print(d)  # defaultdict(&lt;class 'tuple'&gt;, {'a': ()})

# 之前的例子就可以这么做
data = [
    (&quot;banana&quot;, 15), (&quot;banana&quot;, 17), (&quot;banana&quot;, 22),
    (&quot;apple&quot;, 31), (&quot;apple&quot;, 30), (&quot;apple&quot;, 33),
    (&quot;orange&quot;, 45), (&quot;orange&quot;, 47), (&quot;orange&quot;, 44),
]

result = defaultdict(list)
for product, count in data:
    result[product].append(count)
# defaultdict 继承 dict，支持字典的 API
print(dict(result))
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;
# 整个过程就是，key 如果存在，那么获取 value
# key 不存在，那么将指定类型的零值作为 value（这里是空列表）
# 并且返回之前，会先将 key、value 添加到键值对中

# 再比如之前的词频统计
string = &quot;aabbccdddddee&quot;
counter = defaultdict(int)
for c in string:
    counter[c] += 1
print(dict(counter))
&quot;&quot;&quot;
{'a': 2, 'b': 2, 'c': 2, 'd': 5, 'e': 2}
&quot;&quot;&quot;
</code></pre>
<p>怎么样，是不是很方便呢？在实例化 defaultdict 的时候，指定一个类型即可，获取一个不存在的 key 的时候，会返回指定的类型的零值，并且还会将 key 和零值添加到字典中。</p>
<p>此外 defaultdict 还可以自定义返回值，只需要指定一个不需要参数的函数即可。</p>
<pre><code class="language-python">from collections import defaultdict

# 此时的默认值就是 default
d = defaultdict(lambda: &quot;default&quot;)
print(d[&quot;aa&quot;])  # default

# 此外还可以添加参数，因为单独指定了 aa，所以打印的时候以指定的为准
# 如果没有指定，那么才会得到默认值
d4 = defaultdict(lambda: &quot;default&quot;, aa=&quot;bar&quot;)
print(d4[&quot;aa&quot;])  # bar
print(d4[&quot;bb&quot;])  # default
</code></pre>
<p>那么估计会有人好奇，这是如何实现的呢？其实主要是实现了一个叫做 __missing__ 的魔法方法。字典在查找元素的时候，会调用 __getitem__，然后在找不到的时候会去调用 __missing__。但是注意：dict 这个类本身并没有实现 __missing__，所以我们需要继承自 dict，然后在子类中实现。</p>
<pre><code class="language-python">class MyDict(dict):

    def __getitem__(self, item):
        # 执行父类的 __getitem__ 方法
        # 如果 key 不存在，会去执行 __missing__ 方法
        value = super().__getitem__(item)
        # 所以这里的 value 就是 __missing__ 方法的返回值
        return value

    def __missing__(self, key):
        self[key] = &quot;搞事情ﾍ(´ー｀ﾍ)搞事情&quot;
        return self[key]


d = MyDict([(&quot;a&quot;, 3), (&quot;b&quot;, 4)])
print(d)  # {'a': 3, 'b': 4}
print(d[&quot;mmm&quot;])  # 搞事情ﾍ(´ー｀ﾍ)搞事情
print(d)  # {'a': 3, 'b': 4, 'mmm': '搞事情ﾍ(´ー｀ﾍ)搞事情'}
</code></pre>
<p>都是一些基础的内容了，突然想到了，就提一遍。</p>
<h2 id="双端队列"><a class="header" href="#双端队列">双端队列</a></h2>
<p>如果你需要维护一个序列，并根据需求动态地往序列的尾部添加元素和弹出元素，那么你会选择什么序列呢？很明显，如果只在尾部操作，那么列表一定是最合适的选择。</p>
<p>但如果我们操作的不止是尾部，还有头部呢？比如往序列的头部添加和弹出元素，此时双端队列就是一个不错的选择。</p>
<p>双端队列支持从任意一端添加和删除元素，更为常用的两种数据结构（即栈和队列）就是双端队列的退化形式，它们的输入和输出被限制在某一端。</p>
<pre><code class="language-python">from collections import deque

# 接收一个可迭代对象，然后进行遍历
d = deque(&quot;abcdefg&quot;)
print(d) 
&quot;&quot;&quot;
deque(['a', 'b', 'c', 'd', 'e', 'f', 'g'])
&quot;&quot;&quot;
print(len(d)) 
&quot;&quot;&quot;
7
&quot;&quot;&quot;
print(d[0]) 
&quot;&quot;&quot;
a
&quot;&quot;&quot;
print(d[-1])  
&quot;&quot;&quot;
g
&quot;&quot;&quot;

# 由于 deque 是一种序列容器，因此同样支持 list 的操作
# 如：通过索引获取元素，查看长度，删除元素，反转元素等等
# list 支持的操作，deque 基本上都支持
d.reverse()
print(d)  # deque(['g', 'f', 'e', 'd', 'c', 'b', 'a'])
d.remove(&quot;c&quot;)
print(d)  # deque(['g', 'f', 'e', 'd', 'b', 'a'])
</code></pre>
<p>deque 还有很多的 API，比如添加元素。</p>
<pre><code class="language-python">from collections import deque

d = deque(&quot;abc&quot;)

# 添加元素，可以从两端添加
d.append(&quot;Hello&quot;)  # 从尾部添加
d.appendleft(&quot;World&quot;)  # 也可以从头部添加
print(d)
&quot;&quot;&quot;
deque(['World', 'a', 'b', 'c', 'Hello'])
&quot;&quot;&quot;

# 还可以使用 insert, 如果范围越界，自动添加在两端
d.insert(100, &quot;古明地觉&quot;)
print(d)
&quot;&quot;&quot;
deque(['World', 'a', 'b', 'c', 'Hello', '古明地觉'])
&quot;&quot;&quot;

# 也可以通过extend，extendleft 一次添加多个元素
d = deque([1, 2, 3])
d.extend([4, 5, 6])
print(d)
&quot;&quot;&quot;
deque([1, 2, 3, 4, 5, 6])
&quot;&quot;&quot;
d.extendleft([7, 8, 9])
print(d)
&quot;&quot;&quot;
deque([9, 8, 7, 1, 2, 3, 4, 5, 6])
&quot;&quot;&quot;
# 注意添加的顺序，我们是从左边开始添加的
# 先添加 7，然后 8 会跑到 7 的左边，所以是结果是倒过来的
</code></pre>
<p>再来看看删除元素：</p>
<pre><code class="language-python">from collections import deque

d = deque(range(1, 7))
print(d)
&quot;&quot;&quot;
deque([1, 2, 3, 4, 5, 6])
&quot;&quot;&quot;

# 调用 pop 方法可以从尾部弹出一个元素
print(d.pop())  # 6
print(d.pop())  # 5
print(d.pop())  # 4
# pop 是从右端删除一个元素，popleft 是从左端开始删除一个元素
# 但如果想 pop 掉指定索引的元素，则只能用 pop 函数，传入索引值即可
print(d.popleft())  # 1
print(d)
&quot;&quot;&quot;
deque([2, 3])
&quot;&quot;&quot;
# 注意：deque 和 queue一样，是线程安全的
# 它们均受 GIL 这把超级大锁保护，可以不同的线程中进行消费
# 如果想清空里面的元素，可以像 list、dict 一样，使用 clear 方法
d.clear()
print(d)  
&quot;&quot;&quot;
deque([])
&quot;&quot;&quot;
</code></pre>
<p>最后 deque 还有一个非常有意思的方法，叫 rotate，它是做什么的呢？来看一下。</p>
<pre><code class="language-python">from collections import deque

# 按任意一个方向进行旋转，从而跳过某些元素。
# d.rotate(n)：n 大于0，从右边开始取 n 个元素放到左边
# n 小于 0，从左边取 n 个元素放到右边
d = deque(range(10))
print(d)  
&quot;&quot;&quot;
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&quot;&quot;&quot;

# 从右边取 2 个元素放到左边，所以 8 和 9 被放到了左边
d.rotate(2)
print(d)  
&quot;&quot;&quot;
deque([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
&quot;&quot;&quot;
d.rotate(-3)
# 从左边取 3 个元素放到右边，所以 8、9、0 被放到了右边
print(d)  
&quot;&quot;&quot;
deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])
&quot;&quot;&quot;
</code></pre>
<p>当然双端队列默认是容量无限的，但很多时候我们需要给队列加上容量限制，如何加呢？</p>
<pre><code class="language-python">from collections import deque

# 限制队列的大小
# 我们在初始化一个双端队列的时候，还可以限制它的大小
d = deque(&quot;abcdefg&quot;, maxlen=5)
# 我们初始化 7 个元素，但是指定最大长度只有 5
# 所以前面两个元素（&quot;a&quot; 和 &quot;b&quot;）就被挤出去了
print(d)
&quot;&quot;&quot;
deque(['c', 'd', 'e', 'f', 'g'], maxlen=5)
&quot;&quot;&quot;

# 当我往前面添加元素的时候，后面的就被挤出去了
# 因为队列最多只能容纳 5 个元素
d.appendleft(&quot;Hello&quot;)
print(d)  
&quot;&quot;&quot;
deque(['Hello', 'c', 'd', 'e', 'f'], maxlen=5)
&quot;&quot;&quot;
</code></pre>
<p>当你要维护一个从首尾两端添加、删除元素的序列时，使用 deque 是一个非常正确的选择。比如 asyncio 的锁 Lock，当获取锁时，就会创建一个 Future 对象，并保存在双端队列中。</p>
<h2 id="带有名字的元组"><a class="header" href="#带有名字的元组">带有名字的元组</a></h2>
<p>元组的话，我们都是通过索引来获取元素，但通过索引的话，如果你不手动数一数，你是不知道该索引会对应哪一个元素的。所以问题来了，可不可以给里面的元素一个字段名呢？我们通过字段名来获取对应的值不就行啦，没错，这就是 namedtuple。</p>
<pre><code class="language-python">from collections import namedtuple

# 传入名字，和字段
Person = namedtuple(&quot;Person&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;gender&quot;])
person1 = Person(name=&quot;satori&quot;, age=16, gender=&quot;f&quot;)
print(person1)
&quot;&quot;&quot;
Person(name='satori', age=16, gender='f')
&quot;&quot;&quot;
print(person1.name, person1.age, person1.gender)
&quot;&quot;&quot;
satori 16 f
&quot;&quot;&quot;
print(person1[0])
&quot;&quot;&quot;
satori
&quot;&quot;&quot;
# 不仅可以像普通的 tuple 一样使用索引访问
# 还可以像类一样通过 . 字段名访问

person2 = Person(&quot;satori&quot;, 16, &quot;f&quot;)
# 注意：这个和普通的元组一样，是不可以修改的
try:
    person2.name = &quot;xxx&quot;
except AttributeError as e:
    print(e)  # can't set attribute

# 非法字段名，不能使用 Python 的关键字
try:
    namedtuple(&quot;keywords&quot;, [&quot;for&quot;, &quot;in&quot;])
except ValueError as e:
    print(e)
    &quot;&quot;&quot;
    Type names and field names cannot be a keyword: 'for'
    &quot;&quot;&quot;

# 如果字段名重复了，会报错
try:
    namedtuple(&quot;Person&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;age&quot;])
except ValueError as e:
    print(e)
    &quot;&quot;&quot;
    Encountered duplicate field name: 'age'
    &quot;&quot;&quot;

# 如果非要加上重名字段，可以设置一个参数
Person = namedtuple(&quot;Person&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;age&quot;],
                    rename=True)
print(Person)  
&quot;&quot;&quot;
&lt;class '__main__.Person'&gt;
&quot;&quot;&quot;
person3 = Person(&quot;koishi&quot;, 15, 15)
# 可以看到重复的字段名会按照索引的值，在前面加上一个下划线
# 比如第二个 age 重复，它的索引是多少呢？是 2，所以默认帮我们把字段名修改为 _2
print(person3)  
&quot;&quot;&quot;
Person(name='koishi', age=15, _2=15)
&quot;&quot;&quot;
# 此外我们所有的字段名都保存在 _fields 属性中
print(person3._fields)  
&quot;&quot;&quot;
('name', 'age', '_2')
&quot;&quot;&quot;
</code></pre>
<p>但 namedtuple 还有一个不完美的地方，就是它无法指定字段的类型，所以我们更推荐使用 typing 模块里的 NamedTuple。</p>
<pre><code class="language-python">from typing import NamedTuple

class Person(NamedTuple):
    name: str
    age: int
    gender: str

p = Person(&quot;satori&quot;, 16, &quot;f&quot;)
print(p)
&quot;&quot;&quot;
Person(name='satori', age=16, gender='f')
&quot;&quot;&quot;
# 同样能够基于索引和字段名来获取值
print(p[0], p.name)
&quot;&quot;&quot;
satori satori
&quot;&quot;&quot;

# 创建类的话，还可以这么创建
Person = NamedTuple('Person', name=str, age=int, gender=str)
Person = NamedTuple(
    'Person', [(&quot;name&quot;, str), (&quot;age&quot;, int), (&quot;gender&quot;, str)]
)
</code></pre>
<p>更建议使用 NamedTuple。</p>
<h2 id="记住键值对顺序的字典"><a class="header" href="#记住键值对顺序的字典">记住键值对顺序的字典</a></h2>
<p>从 Python3.6 开始，字典遍历默认是有序的，但我们不应该依赖这个特性。如果希望字典有序，应该使用 OrderDict 字典子类。</p>
<pre><code class="language-python">from collections import OrderedDict

d = OrderedDict()
d[&quot;a&quot;] = &quot;A&quot;
d[&quot;b&quot;] = &quot;B&quot;
d[&quot;c&quot;] = &quot;C&quot;
for k, v in d.items():
    print(k, v)
&quot;&quot;&quot;
a A
b B
c C
&quot;&quot;&quot;
# 此外也可以在初始化的时候，添加元素
print(OrderedDict({&quot;a&quot;: 1}))  
&quot;&quot;&quot;
OrderedDict([('a', 1)])
&quot;&quot;&quot;

# 相等性，对于常规字典来说，只要里面元素一样便是相等的，不考虑顺序
# 但是对于OrderDict来说，除了元素，顺序也要一样，否则就不相等
d1 = {&quot;a&quot;: 1, &quot;b&quot;: 2}
d2 = {&quot;b&quot;: 2, &quot;a&quot;: 1}
print(d1 == d2)  
&quot;&quot;&quot;
True
&quot;&quot;&quot;

d1 = OrderedDict({&quot;a&quot;: 1, &quot;b&quot;: 2})
d2 = OrderedDict({&quot;b&quot;: 2, &quot;a&quot;: 1})
print(d1 == d2)  
&quot;&quot;&quot;
False
&quot;&quot;&quot;

# 重排，在 OrderDict 中可以使用 move_to_end 方法
# 将某个键移动到序列的起始位置或末尾位置来改变顺序
d3 = OrderedDict({&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4})
# 表示将 key=&quot;c&quot; 的键值对移动到末尾
d3.move_to_end(&quot;c&quot;)  
print(d3)  
&quot;&quot;&quot;
OrderedDict([('a', 1), ('b', 2), ('d', 4), ('c', 3)])
&quot;&quot;&quot;
# 表示将 key=&quot;c&quot; 的这个键值对移动到行首
d3.move_to_end(&quot;c&quot;, last=False)  
print(d3)  
&quot;&quot;&quot;
OrderedDict([('c', 3), ('a', 1), ('b', 2), ('d', 4)])
&quot;&quot;&quot;

# 从尾部弹出一个元素
print(d3.popitem())
&quot;&quot;&quot;
('d', 4)
&quot;&quot;&quot;
# 从头部弹出一个元素
print(d3.popitem(last=False))
&quot;&quot;&quot;
('c', 3)
&quot;&quot;&quot;
</code></pre>
<p>使用 OrderDict 要比 dict 更加耗费内存，因此在存储大量键值对的时候，思考一下，是否需要保证键值对有序。</p>
<p>但在实现 LRU 缓存的时候，OrderDict 非常常用，比如某个键被访问了，通过 move_to_end 移到头部。当缓存满了的时候，通过 popitem 弹出尾部元素。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>以上就是 collections 模块的用法，这个模块还是非常好用的，我们拿出来说一说。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../通过 contextlib 模块详细复习一下 with 语句的用法/doc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../使用 unicodedata 模块对字符串标准化/doc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../通过 contextlib 模块详细复习一下 with 语句的用法/doc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../使用 unicodedata 模块对字符串标准化/doc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/custom.js"></script>
    </body>
</html>
