<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>解密可迭代对象的排序问题 - Python 实用技巧</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../如何优雅地遍历可迭代对象？/doc.html">如何优雅地遍历可迭代对象？</a></li><li class="chapter-item expanded "><a href="../解密可迭代对象的排序问题/doc.html" class="active">解密可迭代对象的排序问题</a></li><li class="chapter-item expanded "><a href="../通过 TOP K 问题，探究堆和优先队列的秘密/doc.html">通过 TOP K 问题，探究堆和优先队列的秘密</a></li><li class="chapter-item expanded "><a href="../如何优雅地对数据进行分组？/doc.html">如何优雅地对数据进行分组？</a></li><li class="chapter-item expanded "><a href="../全方位解析 f-string/doc.html">全方位解析 f-string</a></li><li class="chapter-item expanded "><a href="../最好的日期处理库：pendulum/doc.html">最好的日期处理库：pendulum</a></li><li class="chapter-item expanded "><a href="../你知道创建模块都有哪些方式吗？/doc.html">你知道创建模块都有哪些方式吗？</a></li><li class="chapter-item expanded "><a href="../exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？/doc.html">exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？</a></li><li class="chapter-item expanded "><a href="../文件处理的一些最佳实践/doc.html">文件处理的一些最佳实践</a></li><li class="chapter-item expanded "><a href="../使用 os 模块更高效地读写文件/doc.html">使用 os 模块更高效地读写文件</a></li><li class="chapter-item expanded "><a href="../将文件映射到内存，像数组一样访问/doc.html">将文件映射到内存，像数组一样访问</a></li><li class="chapter-item expanded "><a href="../使用 psutil 获取硬件、网络以及进程信息/doc.html">使用 psutil 获取硬件、网络以及进程信息</a></li><li class="chapter-item expanded "><a href="../使用临时文件保存数据/doc.html">使用临时文件保存数据</a></li><li class="chapter-item expanded "><a href="../shutil：更优雅地拷贝文件/doc.html">shutil：更优雅地拷贝文件</a></li><li class="chapter-item expanded "><a href="../使用 contextvars 管理上下文变量/doc.html">使用 contextvars 管理上下文变量</a></li><li class="chapter-item expanded "><a href="../自定义异常堆栈信息/doc.html">自定义异常堆栈信息</a></li><li class="chapter-item expanded "><a href="../prettytable：像数据库一样格式化输出内容/doc.html">prettytable：像数据库一样格式化输出内容</a></li><li class="chapter-item expanded "><a href="../轻松绘制动态条形图/doc.html">轻松绘制动态条形图</a></li><li class="chapter-item expanded "><a href="../自定义 jupyter 魔法命令/doc.html">自定义 jupyter 魔法命令</a></li><li class="chapter-item expanded "><a href="../解析 ini、yaml、toml 配置文件/doc.html">解析 ini、yaml、toml 配置文件</a></li><li class="chapter-item expanded "><a href="../使用 fuzzywuzzy 模块计算两个字符串之间的相似度/doc.html">使用 fuzzywuzzy 模块计算两个字符串之间的相似度</a></li><li class="chapter-item expanded "><a href="../命令行解析工具 argparse/doc.html">命令行解析工具 argparse</a></li><li class="chapter-item expanded "><a href="../使用 urllib.parse 模块优雅地处理 URL/doc.html">使用 urllib.parse 模块优雅地处理 URL</a></li><li class="chapter-item expanded "><a href="../Python 实现复制粘贴/doc.html">Python 实现复制粘贴</a></li><li class="chapter-item expanded "><a href="../Python 生成、解析二维码/doc.html">Python 生成、解析二维码</a></li><li class="chapter-item expanded "><a href="../解密 __getattr__ 和 __getattribute__ 的用法与区别/doc.html">解密 __getattr__ 和 __getattribute__ 的用法与区别</a></li><li class="chapter-item expanded "><a href="../使用 fcntl 模块对文件进行加解锁/doc.html">使用 fcntl 模块对文件进行加解锁</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 实用技巧</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/python-tech" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>假设有一个可迭代对象，现在想要对它内部的元素进行排序，我们一般会使用内置函数 sorted，举个例子：</p>
<pre><code class="language-python">data = (3, 4, 1, 2, 5)
print(sorted(data))  # [1, 2, 3, 4, 5]

data = (3.14, 2, 1.75)
print(sorted(data))  # [1.75, 2, 3.14]

data = [&quot;satori&quot;, &quot;koishi&quot;, &quot;marisa&quot;]
print(sorted(data))  # ['koishi', 'marisa', 'satori']
</code></pre>
<p>如果可迭代对象里面的元素是数值，那么会按照数值的大小进行排序；如果是字符串，那么会按照字符串的字典序进行排序，并且 sorted 函数会返回一个新的列表。</p>
<blockquote>
<p>sorted 函数默认是升序排序，如果想要降序，那么可以传递一个关键字参数 reverse=True。</p>
</blockquote>
<pre><code class="language-python">data = [
    (3, 4), (3, 1), (2, 3)
]
print(sorted(data))  # [(2, 3), (3, 1), (3, 4)]
</code></pre>
<p>如果可迭代对象里面都是元组的话，也是可以的，元组在比较大小的时候，会先按照元组的第一个元素比较；第一个元素相等，再按照第二个元素比较，依次类推。</p>
<p>因此在使用 sorted 函数的时候，可迭代对象内部的元素，要满足彼此之间都是可比较的，否则报错。</p>
<pre><code class="language-Python">data = [123, 456, &quot;123&quot;]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'str' and 'int'

data = [{&quot;a&quot;: 1}, {&quot;b&quot;: 2}, {&quot;c&quot;: 3}]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'

</code></pre>
<p>我们看到，由于 data 里面存在不可比较的元素，因此报错了。那么问题来了，假设有这样一个列表：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 字典是不可比较大小的，因此直接使用 sorted 会报错
# 我们希望按照字典内部的 &quot;age&quot; 字段进行排序，得到下面的结果

[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
</code></pre>
<p>如果是你的话，你会怎么做呢？很明显，我们将每个 &quot;age&quot; 字段的值取出来，和所在的字典拼接成一个元组（或列表）不就行了，然后对元组进行排序，举个例子：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 由于 data 内部的元素是一个元组
# 所以排序的时候会按照元组的第一个元素排序
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16}), 
 (17, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时顺序就排好了，然后再把字典取出来
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>显然这样就实现了基于字典内部某个字段的值，来对字典进行排序，只不过上面的代码还有一点点缺陷。我们说元组在比较的时候会先比较第一个元素，第一个元素相同的话，会比较第二个元素。</p>
<p>而我们上面 data 里面的元组，由于第一个元素都不相等，所以直接就比较出来了。但如果是下面这种情况呢？</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (16, {'name': 'marisa', 'age': 16}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;
try:
    sorted_data = sorted(data)
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'
</code></pre>
<p>此时就报错了，因为第二个元组和第三个元组内部的第一个元素都是 16，所以第一个元素相等，那么会比较第二个元素。而第二个元素是字典，字典之间无法比较，所以报错了。</p>
<p>但我们只是希望让字典的 &quot;age&quot; 字段的值参与比较，如果相等的话，那么就不用再比较了，相对顺序就保持现状。所以我们可以这么做：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 将索引也加进去
data = [(d[&quot;age&quot;], i, d) for i, d in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, {'name': 'satori', 'age': 17}), 
 (16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 如果 &quot;age&quot; 字段的值、或者说元组的第一个元素相等
# 那么就按照索引比较，而索引一定是不重复的
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16}), 
 (17, 0, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时就成功排好序了，并且 &quot;age&quot; 字段的值相等的字典之间的相对顺序
# 在排序之前和排序之后都保持一致，这正是我们想要的结果
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>再比如，我们想要对元组排序，但我们希望按照元组的第二个元素进行排序：</p>
<pre><code class="language-python">data = [(&quot;satori&quot;, 17), 
        (&quot;marisa&quot;, 15), 
        (&quot;koishi&quot;, 16)]

data = [(item[1], i, item) for i, item in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, ('satori', 17)), 
 (15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16))]
&quot;&quot;&quot;

sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16)), 
 (17, 0, ('satori', 17))]
&quot;&quot;&quot;

sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[('marisa', 15), 
 ('koishi', 16), 
 ('satori', 17)]
&quot;&quot;&quot;
</code></pre>
<p>所以当可迭代对象内部的元素无法进行排序，或者说我们不希望基于整个元素进行排序，那么就可以使用上面这个方法。将用来排序的值、索引、原始值放在一个元组里面，然后对元组排序，排完了再把最后一个值（也就是原始值）筛出来即可。</p>
<p>或者我们还可以做的再复杂一些：</p>
<pre><code class="language-python">data = [-3, -2, 3, 2, -1, 1, 0]
&quot;&quot;&quot;
对 data 进行排序，排序规则如下
先按照内部元素的正负进行排序，排序之后正数在后面
如果符号一样，再按照绝对值的大小进行排序
也就是说，排完之后是下面这样一个结果

[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

# 如果只按照正负排序
data1 = [(n &gt;= 0, i, n) for i, n in enumerate(data)]
sorted_data = sorted(data1)
print(sorted_data)
&quot;&quot;&quot;
[(False, 0, -3), (False, 1, -2), (False, 4, -1), 
 (True, 2, 3), (True, 3, 2), (True, 5, 1), (True, 6, 0)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 此时正数就排在了负数的后面
print(sorted_data)
&quot;&quot;&quot;
[-3, -2, -1, 3, 2, 1, 0]
&quot;&quot;&quot;

# 如果只按照绝对值排序
data2 = [(abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data2)
print(sorted_data)
&quot;&quot;&quot;
[(0, 6, 0), (1, 4, -1), (1, 5, 1), 
 (2, 1, -2), (2, 3, 2), (3, 0, -3), (3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[0, -1, 1, -2, 2, -3, 3]
&quot;&quot;&quot;

# 同时按照正负和绝对值排序
data3 = [(n &gt;= 0, abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data3)
print(sorted_data)
&quot;&quot;&quot;
[(False, 1, 4, -1), (False, 2, 1, -2), 
 (False, 3, 0, -3), (True, 0, 6, 0), 
 (True, 1, 5, 1), (True, 2, 3, 2), (True, 3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 大功告成
print(sorted_data)
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;
</code></pre>
<p>那么接下来，我们就可以封装一个属于我们自己的 my_sorted 函数了。</p>
<pre><code class="language-python">def my_sorted(data, *, key=None, reverse=False):
    &quot;&quot;&quot;
    :paramdata: 可迭代对象
    :paramkey: callable
    :paramreverse: 是否逆序
    :return:
    &quot;&quot;&quot;
    if key is not None:
        data = [(key(item), i, item) for i, item in enumerate(data)]
    sorted_data = sorted(data)
    if key is not None:
        sorted_data = [item[-1] for item in sorted_data]
    if reverse:
        sorted_data = sorted_data[:: -1]
    return sorted_data

# 下面来测试一下
data = [-3, -2 ,3, 2, -1, 1, 0]
print(my_sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(my_sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>结果一切正常，当然啦，实际工作中我们肯定不会专门封装一个 my_sorted 函数，因为内置的 sorted 已经包含了我们上面的所有功能。</p>
<pre><code class="language-python">data = [-3, -2 ,3, 2, -1, 1, 0]
print(sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>内置函数 sorted 除了接收一个可迭代对象之外，还接收两个关键字参数 key 和 reverse，含义就是我们介绍的那样。在 sorted 的内部，它的处理方式和我们上面是一致的，如果指定了 key，也就是自定义排序规则，那么在底层会将可迭代对象内部的值封装成元组，然后对元组排序。排完序之后，再将元组的最后一个值、也就是原始值取出来，并返回。</p>
<p>所以这就是 sorted 函数的全部秘密，它里面的参数 key 赋予了 sorted 函数强大的能力，有了这个参数，我们想怎么排序，就怎么排序。</p>
<pre><code class="language-python">class A:
    
    def __init__(self, a):
        self.a = a
    
    def __repr__(self):
        return f&quot;self.a = {self.a}&quot;
    
    def __hash__(self):
        return self.a
    
a1 = A(1)
a2 = A(2)
a3 = A(3)
a4 = A(4)

data = [a2, a3, a1, a4]
print(data)
&quot;&quot;&quot;
[self.a = 2, self.a = 3, self.a = 1, self.a = 4]
&quot;&quot;&quot;

# A 的实例对象无法比较，我们希望按照内部的属性 a 进行比较
print(sorted(data, key=lambda x: x.a))
&quot;&quot;&quot;
[self.a = 1, self.a = 2, self.a = 3, self.a = 4]
&quot;&quot;&quot;

# 或者按照哈希值比较，此时仍相当于按照 self.a 比较
print(sorted(data, key=lambda x: hash(x), reverse=True))
&quot;&quot;&quot;
[self.a = 4, self.a = 3, self.a = 2, self.a = 1]
&quot;&quot;&quot;
</code></pre>
<p>因此我们想怎么比就怎么比，参数 key 赋予了我们极大的自由，key 接收一个函数（当然其它 callable 也可以，但大部分场景都是匿名函数），此函数接收一个参数，该参数会对应可迭代对象里面的每一个元素。而函数的返回值，决定了 sorted 的比较逻辑。</p>
<p>比如，我们不光可以对元组、列表排序，还可以对字典内部的键值对排序。</p>
<pre><code class="language-Python">data = {&quot;satori&quot;: 17, &quot;marisa&quot;: 15, &quot;koishi&quot;: 16}

# 对字典调用 sorted，针对的是字典里面的键，所以返回的也是键
print(sorted(data))  # ['koishi', 'marisa', 'satori']

# 匿名函数里面的参数 x 对应可迭代对象里面的每一个元素
# 这里就是字典的键，函数返回 d[x] 表示按照值来排序，但排序之后得到的仍然是键
print(sorted(data, key=lambda x: data[x]))  # ['marisa', 'koishi', 'satori']

# 此时的 x 就是键值对组成的元组，这里按照值来排序
print(
    sorted(data.items(), key=lambda x: x[1])
)  # [('marisa', 15), ('koishi', 16), ('satori', 17)]
</code></pre>
<p>当然啦，还有很多其它排序方式，比如按照数量排序：</p>
<pre><code class="language-python">string = &quot;a&quot; * 4 + &quot;b&quot; * 3 + &quot;c&quot; * 5 + &quot;d&quot; * 2
data = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

print(
    sorted(data, key=lambda x: string.count(x))
)  # ['d', 'b', 'a', 'c']
</code></pre>
<p>最后再来介绍一个知识点，sorted 在对可迭代对象内部的元素进行排序的时候，肯定要有大小比较的过程，这是肯定的。但问题是比较的时候，用的什么方式呢？举个例子，我想判断 a 和 b 的大小关系（假设不相等），无论是执行 a &gt; b 还是 a &lt; b，根据结果我都能得出它们谁大谁小。</p>
<p>而 sorted 在比较的时候是怎么做的呢，这里给出结论：每次在比较两个对象的时候，都会调用左边对象的 __lt__ 方法。其实关于 sorted 内部是怎么比的，我们无需太关注，但之所以说这一点，是因为在极端场景下可能会遇到。举个例子：</p>
<pre><code class="language-python"># 第一个元素表示 &quot;商品名称&quot;
# 第二个元素表示 &quot;销量&quot;
data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

# 我们需要先按照 &quot;销量&quot; 的大小降序排序
# 如果 &quot;销量&quot; 相同，则按照 &quot;商品名称&quot; 的字典序升序排序
# 该怎么做呢？

# 由于一部分升序，一部分降序
# 我们无法直接使用 reverse 参数，所以就默认按照升序排
# 虽然 &quot;销量&quot; 要求降序排，但可以对它取反
# 这样值越大，取反之后的值就越小，从而实现降序效果
print(
    sorted(data, key=lambda x: (~x[1], x[0]))
)
&quot;&quot;&quot;
[('apple', 200), 
 ('banana', 200), 
 ('cherry', 150), 
 ('orange', 150), 
 ('peach', 150)]
&quot;&quot;&quot;
</code></pre>
<p>可能有小伙伴觉得这也没什么难的，那么我们将问题稍微换一下。如果让你先按照 &quot;销量&quot; 升序排序，如果 &quot;销量相同&quot;，再按照 &quot;商品名称&quot; 的字典序降序排序，你要怎么做呢？</p>
<p>显然这个问题的难点就在于字符串要怎么降序排，整数可以取反，但字符串是无法取反的。所以我们可以自定义一个类，实现它的 __lt__ 方法。</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

class STR(str):
    def __lt__(self, other):
        # 调用 str 的 __lt__，得到布尔值，然后再取反
        # 当然，把 not 换成 ~ 也是可以的
        # 因此：&quot;apple&quot; &lt; &quot;banana&quot; 为 True
        # 但是：STR(&quot;apple&quot;) &lt; STR(&quot;banana&quot;) 为 False
        return not super().__lt__(other)

# 销量升序排，直接 x[1] 即可
# 但是商品名称降序排，需要使用类 STR 将 x[0] 包起来
print(sorted(data, key=lambda x: (x[1], STR(x[0]))))
&quot;&quot;&quot;
[('peach', 150), 
 ('orange', 150), 
 ('cherry', 150), 
 ('banana', 200), 
 ('apple', 200)]
&quot;&quot;&quot;

# 事实上，如果你的思维够灵活，你会发现
# &quot;销量&quot;降序排、&quot;商品名称&quot;升序排，排完之后再整体取反
# 就是这里 &quot;销量&quot;升序排、&quot;商品名称&quot;将序排 的结果
print(
    sorted(data, key=lambda x: (~x[1], x[0]), reverse=True)
    ==
    sorted(data, key=lambda x: (x[1], STR(x[0])))
)  # True
# 当然这个思路也很巧妙
</code></pre>
<p>由于默认是调用 __lt__ 进行比较的，因此我们需要实现 __lt__。</p>
<p>以上就是 Python 中如何对可迭代对象进行排序，还是很有意思的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../如何优雅地遍历可迭代对象？/doc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../通过 TOP K 问题，探究堆和优先队列的秘密/doc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../如何优雅地遍历可迭代对象？/doc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../通过 TOP K 问题，探究堆和优先队列的秘密/doc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/custom.js"></script>
    </body>
</html>
