<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>使用 contextvars 管理上下文变量 - Python 实用技巧</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../如何优雅地遍历可迭代对象？/doc.html">如何优雅地遍历可迭代对象？</a></li><li class="chapter-item expanded "><a href="../解密可迭代对象的排序问题/doc.html">解密可迭代对象的排序问题</a></li><li class="chapter-item expanded "><a href="../通过 TOP K 问题，探究堆和优先队列的秘密/doc.html">通过 TOP K 问题，探究堆和优先队列的秘密</a></li><li class="chapter-item expanded "><a href="../如何优雅地对数据进行分组？/doc.html">如何优雅地对数据进行分组？</a></li><li class="chapter-item expanded "><a href="../全方位解析 f-string/doc.html">全方位解析 f-string</a></li><li class="chapter-item expanded "><a href="../最好的日期处理库：pendulum/doc.html">最好的日期处理库：pendulum</a></li><li class="chapter-item expanded "><a href="../你知道创建模块都有哪些方式吗？/doc.html">你知道创建模块都有哪些方式吗？</a></li><li class="chapter-item expanded "><a href="../exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？/doc.html">exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？</a></li><li class="chapter-item expanded "><a href="../文件处理的一些最佳实践/doc.html">文件处理的一些最佳实践</a></li><li class="chapter-item expanded "><a href="../使用 os 模块更高效地读写文件/doc.html">使用 os 模块更高效地读写文件</a></li><li class="chapter-item expanded "><a href="../将文件映射到内存，像数组一样访问/doc.html">将文件映射到内存，像数组一样访问</a></li><li class="chapter-item expanded "><a href="../使用 psutil 获取硬件、网络以及进程信息/doc.html">使用 psutil 获取硬件、网络以及进程信息</a></li><li class="chapter-item expanded "><a href="../使用临时文件保存数据/doc.html">使用临时文件保存数据</a></li><li class="chapter-item expanded "><a href="../shutil：更优雅地拷贝文件/doc.html">shutil：更优雅地拷贝文件</a></li><li class="chapter-item expanded "><a href="../使用 contextvars 管理上下文变量/doc.html" class="active">使用 contextvars 管理上下文变量</a></li><li class="chapter-item expanded "><a href="../自定义异常堆栈信息/doc.html">自定义异常堆栈信息</a></li><li class="chapter-item expanded "><a href="../prettytable：像数据库一样格式化输出内容/doc.html">prettytable：像数据库一样格式化输出内容</a></li><li class="chapter-item expanded "><a href="../轻松绘制动态条形图/doc.html">轻松绘制动态条形图</a></li><li class="chapter-item expanded "><a href="../自定义 jupyter 魔法命令/doc.html">自定义 jupyter 魔法命令</a></li><li class="chapter-item expanded "><a href="../解析 ini、yaml、toml 配置文件/doc.html">解析 ini、yaml、toml 配置文件</a></li><li class="chapter-item expanded "><a href="../使用 fuzzywuzzy 模块计算两个字符串之间的相似度/doc.html">使用 fuzzywuzzy 模块计算两个字符串之间的相似度</a></li><li class="chapter-item expanded "><a href="../命令行解析工具 argparse/doc.html">命令行解析工具 argparse</a></li><li class="chapter-item expanded "><a href="../使用 urllib.parse 模块优雅地处理 URL/doc.html">使用 urllib.parse 模块优雅地处理 URL</a></li><li class="chapter-item expanded "><a href="../Python 实现复制粘贴/doc.html">Python 实现复制粘贴</a></li><li class="chapter-item expanded "><a href="../Python 生成、解析二维码/doc.html">Python 生成、解析二维码</a></li><li class="chapter-item expanded "><a href="../解密 __getattr__ 和 __getattribute__ 的用法与区别/doc.html">解密 __getattr__ 和 __getattribute__ 的用法与区别</a></li><li class="chapter-item expanded "><a href="../使用 fcntl 模块对文件进行加解锁/doc.html">使用 fcntl 模块对文件进行加解锁</a></li><li class="chapter-item expanded "><a href="../详解新一代 HTTP 请求库：httpx/doc.html">详解新一代 HTTP 请求库：httpx</a></li><li class="chapter-item expanded "><a href="../通过 contextlib 模块详细复习一下 with 语句的用法/doc.html">通过 contextlib 模块详细复习一下 with 语句的用法</a></li><li class="chapter-item expanded "><a href="../使用 collections 模块扩展你的数据类/doc.html">使用 collections 模块扩展你的数据类</a></li><li class="chapter-item expanded "><a href="../使用 unicodedata 模块对字符串标准化/doc.html">使用 unicodedata 模块对字符串标准化</a></li><li class="chapter-item expanded "><a href="../使用 struct 模块打包、解包二进制数据/doc.html">使用 struct 模块打包、解包二进制数据</a></li><li class="chapter-item expanded "><a href="../使用 watchfiles 模块监控目录变更/doc.html">使用 watchfiles 模块监控目录变更</a></li><li class="chapter-item expanded "><a href="../读取照片的 Exif 信息/doc.html">读取照片的 Exif 信息</a></li><li class="chapter-item expanded "><a href="../模拟 TLS 指纹实现反反爬/doc.html">模拟 TLS 指纹实现反反爬</a></li><li class="chapter-item expanded "><a href="../生成词云/doc.html">生成词云</a></li><li class="chapter-item expanded "><a href="../你知道 Python 其实自带了小型数据库吗/doc.html">你知道 Python 其实自带了小型数据库吗</a></li><li class="chapter-item expanded "><a href="../聊一聊 Python 的换行以及转义/doc.html">聊一聊 Python 的换行以及转义</a></li><li class="chapter-item expanded "><a href="../分享一个 Python 处理音频的库/doc.html">分享一个 Python 处理音频的库</a></li><li class="chapter-item expanded "><a href="../pyquery：一个灵活方便的 HTML 解析库/doc.html">pyquery：一个灵活方便的 HTML 解析库</a></li><li class="chapter-item expanded "><a href="../生成并识别图片验证码/doc.html">生成并识别图片验证码</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 实用技巧</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/python-tech" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>Python 在 3.7 的时候引入了一个模块：contextvars，从名字上很容易看出它指的是上下文变量（Context Variables），所以在介绍 contextvars 之前我们需要先了解一下什么是上下文（Context）。</p>
<p>Context 是一个包含了相关信息内容的对象，举个例子：&quot;比如一部 13 集的动漫，你直接点进第八集，看到女主角在男主角面前流泪了&quot;。相信此时你是不知道为什么女主角会流泪的，因为你没有看前面几集的内容，缺失了相关的上下文信息。</p>
<p>所以 Context 并不是什么神奇的东西，它的作用就是携带一些指定的信息。</p>
<h2 id="web-框架中的-request"><a class="header" href="#web-框架中的-request">web 框架中的 request</a></h2>
<p>我们以 fastapi 和 sanic 为例，看看当一个请求过来的时候，它们是如何解析的。</p>
<pre><code class="language-Python"># fastapi
from fastapi import FastAPI, Request
import uvicorn

app = FastAPI()


@app.get(&quot;/index&quot;)
async def index(request: Request):
    name = request.query_params.get(&quot;name&quot;)
    return {&quot;name&quot;: name}


uvicorn.run(&quot;__main__:app&quot;, host=&quot;127.0.0.1&quot;, port=5555)

# -------------------------------------------------------

# sanic
from sanic import Sanic
from sanic.request import Request
from sanic import response

app = Sanic(&quot;sanic&quot;)


@app.get(&quot;/index&quot;)
async def index(request: Request):
    name = request.args.get(&quot;name&quot;)
    return response.json({&quot;name&quot;: name})


app.run(host=&quot;127.0.0.1&quot;, port=6666) 
</code></pre>
<p>发请求测试一下，会看到请求都是成功的，并且对于 fastapi 和 sanic 而言，其 request 和 视图函数是绑定在一起的。也就是在请求到来的时候，会被封装成一个 Request 对象、然后传递到视图函数中。</p>
<p>但对于 flask 而言则不是这样子的，我们看一下 flask 是如何接收请求参数的。</p>
<pre><code class="language-Python">from flask import Flask, request

app = Flask(&quot;flask&quot;)


@app.route(&quot;/index&quot;)
def index():
    name = request.args.get(&quot;name&quot;)
    return {&quot;name&quot;: name}


app.run(host=&quot;127.0.0.1&quot;, port=7777)
</code></pre>
<p>我们看到对于 flask 而言则是通过 import request 的方式，如果不需要的话就不用 import，当然我这里并不是在比较哪种方式好，主要是为了引出我们今天的主题。首先对于 flask 而言，如果我再定义一个视图函数的话，那么获取请求参数依旧是相同的方式，但是这样问题就来了，不同的视图函数内部使用同一个 request，难道不会发生冲突吗？</p>
<p>显然根据我们使用 flask 的经验来说，答案是不会的，至于原因就是 ThreadLocal。</p>
<h2 id="threadlocal"><a class="header" href="#threadlocal">ThreadLocal</a></h2>
<p>ThreadLocal，从名字上看可以得出它肯定是和线程相关的。没错，它专门用来创建局部变量，并且创建的局部变量是和线程绑定的。</p>
<pre><code class="language-python">import threading

# 创建一个 local 对象
local = threading.local()

def get():
    name = threading.current_thread().name
    # 获取绑定在 local 上的 value
    value = local.value
    print(f&quot;线程: {name}, value: {value}&quot;)

def set_():
    name = threading.current_thread().name
    # 为不同的线程设置不同的值
    if name == &quot;one&quot;:
        local.value = &quot;ONE&quot;
    elif name == &quot;two&quot;:
        local.value = &quot;TWO&quot;
    # 执行 get 函数
    get()

t1 = threading.Thread(target=set_, name=&quot;one&quot;)
t2 = threading.Thread(target=set_, name=&quot;two&quot;)
t1.start()
t2.start()
&quot;&quot;&quot;
线程 one, value: ONE
线程 two, value: TWO
&quot;&quot;&quot;
</code></pre>
<p>可以看到两个线程之间是互不影响的，因为每个线程都有自己唯一的 id，在绑定值的时候会绑定在当前的线程中，获取也会从当前的线程中获取。可以把 ThreadLocal 想象成一个字典：</p>
<pre><code class="language-python">{
    &quot;one&quot;: {&quot;value&quot;: &quot;ONE&quot;},
    &quot;two&quot;: {&quot;value&quot;: &quot;TWO&quot;}
}
</code></pre>
<p>更准确的说 key 应该是线程的 id，为了直观我们就用线程的 name 代替了，但总之在获取的时候只会获取绑定在该线程上的变量的值。</p>
<p>而 flask 内部也是这么设计的，只不过它没有直接用 threading.local，而是自己实现了一个 Local 类，除了支持线程之外还支持 greenlet 协程，那么它是怎么实现的呢？首先我们知道 flask 内部存在 &quot;请求 context&quot; 和 &quot;应用 context&quot;，它们都是通过栈来维护的（两个不同的栈）。</p>
<pre><code class="language-python"># flask/globals.py
_request_ctx_stack = LocalStack()
_app_ctx_stack = LocalStack()
current_app = LocalProxy(_find_app)
request = LocalProxy(partial(_lookup_req_object, &quot;request&quot;))
session = LocalProxy(partial(_lookup_req_object, &quot;session&quot;))
</code></pre>
<p>每个请求都会绑定在当前的 Context 中，等到请求结束之后再销毁，这个过程由框架完成，开发者只需要直接使用 request 即可。所以请求的具体细节流程可以点进源码中查看，这里我们重点关注一个对象：werkzeug.local.Local，也就是上面说的 Local 类，它是变量的设置和获取的关键。直接看部分源码：</p>
<pre><code class="language-python"># werkzeug/local.py

class Local(object):
    __slots__ = (&quot;__storage__&quot;, &quot;__ident_func__&quot;)

    def __init__(self):
        # 内部有两个成员：__storage__ 是一个字典，值就存在这里面
        # __ident_func__ 只需要知道它是用来获取线程 id 的即可
        object.__setattr__(self, &quot;__storage__&quot;, {})
        object.__setattr__(self, &quot;__ident_func__&quot;, get_ident)

    def __call__(self, proxy):
        &quot;&quot;&quot;Create a proxy for a name.&quot;&quot;&quot;
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)

    def __getattr__(self, name):
        try:
            # 根据线程 id 得到 value（一个字典）
            # 然后再根据 name 获取对应的值
            # 所以只会获取绑定在当前线程上的值
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        ident = self.__ident_func__()
        storage = self.__storage__
        try:
            # 将线程 id 作为 key，然后将值设置在对应的字典中
            # 所以只会将值设置在当前的线程中
            storage[ident][name] = value
        except KeyError:
            storage[ident] = {name: value}

    def __delattr__(self, name):
        # 删除逻辑也很简单
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)
</code></pre>
<p>所以我们看到 flask 内部的逻辑其实很简单，通过 ThreadLocal 实现了线程之间的隔离。每个请求都会绑定在各自的 Context 中，获取值的时候也会从各自的 Context 中获取，因为它就是用来保存相关信息的（重要的是同时也实现了隔离）。</p>
<p>相应此刻你已经理解了上下文，但是问题来了，不管是 threading.local 也好、还是类似于 flask 自己实现的 Local 也罢，它们都是针对线程的。如果是使用 async def 定义的协程该怎么办呢？如何实现每个协程的上下文隔离呢？所以终于引出了我们的主角：contextvars。</p>
<h2 id="contextvars"><a class="header" href="#contextvars">contextvars</a></h2>
<p>该模块提供了一组接口，可用于在协程中管理、设置、访问局部 Context 的状态。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get():
    # 获取值
    return c.get() + &quot;~~~&quot;

async def set_(val):
    # 设置值
    c.set(val)
    print(await get())

async def main():
    coro1 = set_(&quot;协程1&quot;)
    coro2 = set_(&quot;协程2&quot;)
    await asyncio.gather(coro1, coro2)


asyncio.run(main())
&quot;&quot;&quot;
协程1~~~
协程2~~~
&quot;&quot;&quot;
</code></pre>
<p>ContextVar 提供了两个方法，分别是 get 和 set，用于获取值和设置值。我们看到效果和 ThreadingLocal 类似，数据在协程之间是隔离的，不会受到彼此的影响。</p>
<p>但我们再仔细观察一下，我们是在 set_ 函数中设置的值，然后在 get 函数中获取值。可 await get() 相当于是开启了一个新的协程，那么意味着设置值和获取值不是在同一个协程当中。但即便如此，我们依旧可以获取到希望的结果。因为 Python 的协程是无栈协程，通过 await 可以实现级联调用。</p>
<p>我们不妨再套一层：</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get1():
    return await get2()

async def get2():
    return c.get() + &quot;~~~&quot;

async def set_(val):
    # 设置值
    c.set(val)
    print(await get1())
    print(await get2())

async def main():
    coro1 = set_(&quot;协程1&quot;)
    coro2 = set_(&quot;协程2&quot;)
    await asyncio.gather(coro1, coro2)


asyncio.run(main())
&quot;&quot;&quot;
协程1~~~
协程1~~~
协程2~~~
协程2~~~
&quot;&quot;&quot;
</code></pre>
<p>我们看到不管是 await get1() 还是 await get2()，得到的都是 set_ 中设置的结果，说明它是可以嵌套的。</p>
<p>并且在这个过程当中，可以重新设置值。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get1():
    c.set(&quot;重新设置&quot;)
    return await get2()

async def get2():
    return c.get() + &quot;~~~&quot;

async def set_(val):
    # 设置值
    c.set(val)
    print(&quot;------------&quot;)
    print(await get2())
    print(await get1())
    print(await get2())
    print(&quot;------------&quot;)

async def main():
    coro1 = set_(&quot;协程1&quot;)
    coro2 = set_(&quot;协程2&quot;)
    await asyncio.gather(coro1, coro2)


asyncio.run(main())
&quot;&quot;&quot;
------------
协程1~~~
重新设置~~~
重新设置~~~
------------
------------
协程2~~~
重新设置~~~
重新设置~~~
------------
&quot;&quot;&quot;
</code></pre>
<p>先 await get2() 得到的就是 set_ 函数中设置的值，这是符合预期的。但是我们在 get1 中将值重新设置了，那么之后不管是 await get1() 还是直接 await get2()，得到的都是新设置的值。</p>
<p>这也说明了，一个协程内部 await 另一个协程，另一个协程内部 await 另另一个协程，不管套娃（await）多少次，它们获取的值都是一样的。并且在任意一个协程内部都可以重新设置值，然后获取会得到最后一次设置的值。再举个栗子：</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get1():
    return await get2()

async def get2():
    val = c.get() + &quot;~~~&quot;
    c.set(&quot;重新设置啦&quot;)
    return val

async def set_(val):
    # 设置值
    c.set(val)
    print(await get1())
    print(c.get())

async def main():
    coro = set_(&quot;古明地觉&quot;)
    await coro

asyncio.run(main())
&quot;&quot;&quot;
古明地觉~~~
重新设置啦
&quot;&quot;&quot;
</code></pre>
<p>await get1() 的时候会执行 await get2()，然后在里面拿到 c.set 设置的值，打印 &quot;古明地觉~~~&quot;。但是在 get2 里面，又将值重新设置了，所以第二个 print 打印的就是新设置的值。</p>
<p>如果在 get 之前没有先 set，那么会抛出一个 LookupError，所以 ContextVar 支持默认值。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;, default=&quot;哼哼&quot;)

async def set_(val):
    print(c.get())
    c.set(val)
    print(c.get())

async def main():
    coro = set_(&quot;古明地觉&quot;)
    await coro

asyncio.run(main())
&quot;&quot;&quot;
哼哼
古明地觉
&quot;&quot;&quot;
</code></pre>
<p>除了在 ContextVar 中指定默认值之外，也可以在 get 中指定。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;, default=&quot;哼哼&quot;)

async def set_(val):
    print(c.get(&quot;古明地恋&quot;))
    c.set(val)
    print(c.get())

async def main():
    coro = set_(&quot;古明地觉&quot;)
    await coro

asyncio.run(main())
&quot;&quot;&quot;
古明地恋
古明地觉
&quot;&quot;&quot;
</code></pre>
<p>所以结论如下，如果在 c.set 之前使用 c.get：</p>
<ul>
<li>当 ContextVar 和 get 中都没有指定默认值，会抛出 LookupError；</li>
<li>只要有一方设置了，那么会得到默认值；</li>
<li>如果都设置了，那么以 get 为准；</li>
</ul>
<p>如果 c.get 之前执行了 c.set，那么无论 ContextVar 和 get 有没有指定默认值，获取到的都是 c.set 设置的值。</p>
<p>所以总的来说还是比较好理解的，并且 ContextVar 除了可以作用在协程上面，它也可以用在线程上面。没错，它可以替代 threading.local，我们来试一下：</p>
<pre><code class="language-python">import threading
import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)

def get():
    name = threading.current_thread().name
    value = c.get()
    print(f&quot;线程 {name}, value: {value}&quot;)

def set_():
    name = threading.current_thread().name
    if name == &quot;one&quot;:
        c.set(&quot;ONE&quot;)
    elif name == &quot;two&quot;:
        c.set(&quot;TWO&quot;)
    get()

t1 = threading.Thread(target=set_, name=&quot;one&quot;)
t2 = threading.Thread(target=set_, name=&quot;two&quot;)
t1.start()
t2.start()
&quot;&quot;&quot;
线程 one, value: ONE
线程 two, value: TWO
&quot;&quot;&quot;
</code></pre>
<p>和 threading.local 的表现是一样的，但是更建议使用 ContextVars。不过前者可以绑定任意多个值，而后者只能绑定一个值（可以通过传递字典的方式解决这一点）。</p>
<h3 id="ctoken"><a class="header" href="#ctoken">c.Token</a></h3>
<p>当我们调用 c.set 的时候，其实会返回一个 Token 对象：</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)
print(token)
&quot;&quot;&quot;
&lt;Token var=&lt;ContextVar name='context_var' at 0x00..&gt; at 0x00...&gt;
&quot;&quot;&quot;
</code></pre>
<p>Token 对象有一个 var 属性，它是只读的，会返回指向此 token 的 ContextVar 对象。</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)

print(token.var is c)  # True
print(token.var.get())  # val

print(
    token.var.set(&quot;val2&quot;).var.set(&quot;val3&quot;).var is c
)  # True
print(c.get())  # val3
</code></pre>
<p>Token 对象还有一个 old_value 属性，它会返回上一次 set 设置的值，如果是第一次 set，那么会返回一个 &lt;Token.MISSING&gt;。</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)

# 该 token 是第一次 c.set 所返回的
# 在此之前没有 set，所以 old_value 是 &lt;Token.MISSING&gt;
print(token.old_value)  # &lt;Token.MISSING&gt;

token = c.set(&quot;val2&quot;)
print(c.get())  # val2
# 返回上一次 set 的值
print(token.old_value)  # val
</code></pre>
<p>那么这个 Token 对象有什么作用呢？从目前来看貌似没太大用处啊，其实它最大的用处就是和 reset 搭配使用，可以对状态进行重置。</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)
# 显然是可以获取的
print(c.get())  # val

# 将其重置为 token 之前的状态
# 但这个 token 是第一次 set 返回的
# 那么之前就相当于没有 set 了
c.reset(token)
try:
    c.get()  # 此时就会报错
except LookupError:
    print(&quot;报错啦&quot;)  # 报错啦

# 但是我们可以指定默认值
print(c.get(&quot;默认值&quot;))  # 默认值
</code></pre>
<h3 id="contextvarscontext"><a class="header" href="#contextvarscontext">contextvars.Context</a></h3>
<p>它负责保存 ContextVars 对象和设置的值之间的映射，但是我们不会直接通过 contextvars.Context 来创建，而是通过 contentvars.copy_context 函数来创建。</p>
<pre><code class="language-Python">import contextvars

c1 = contextvars.ContextVar(&quot;context_var1&quot;)
c1.set(&quot;val1&quot;)
c2 = contextvars.ContextVar(&quot;context_var2&quot;)
c2.set(&quot;val2&quot;)

# 此时得到的是所有 ContextVar 对象和设置的值之间的映射
# 它实现了 collections.abc.Mapping 接口
# 因此我们可以像操作字典一样操作它
context = contextvars.copy_context()
# key 就是对应的 ContextVar 对象，value 就是设置的值
print(context[c1])  # val1
print(context[c2])  # val2
for ctx, value in context.items():
    print(ctx.get(), ctx.name, value)
    &quot;&quot;&quot;
    val1 context_var1 val1
    val2 context_var2 val2
    &quot;&quot;&quot;

print(len(context))  # 2
</code></pre>
<p>除此之外，context 还有一个 run 方法：</p>
<pre><code class="language-python">import contextvars

c1 = contextvars.ContextVar(&quot;context_var1&quot;)
c1.set(&quot;val1&quot;)
c2 = contextvars.ContextVar(&quot;context_var2&quot;)
c2.set(&quot;val2&quot;)

context = contextvars.copy_context()

def change(val1, val2):
    c1.set(val1)
    c2.set(val2)
    print(c1.get(), context[c1])
    print(c2.get(), context[c2])

# 在 change 函数内部，重新设置值
# 然后里面打印的也是新设置的值
context.run(change, &quot;VAL1&quot;, &quot;VAL2&quot;)
&quot;&quot;&quot;
VAL1 VAL1
VAL2 VAL2
&quot;&quot;&quot;

print(c1.get(), context[c1])
print(c2.get(), context[c2])
&quot;&quot;&quot;
val1 VAL1
val2 VAL2
&quot;&quot;&quot;
</code></pre>
<p>我们看到 run 方法接收一个 callable，如果在里面修改了 ContextVar 实例设置的值，那么对于 ContextVar 而言只会在函数内部生效，一旦出了函数，那么还是原来的值。但是对于 Context 而言，它是会受到影响的，即便出了函数，也是新设置的值，因为它直接把内部的字典给修改了。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>以上就是 contextvars 模块的用法，在多个协程之间传递数据是非常方便的，并且也是并发安全的。如果你用过 Go 的话，你应该会发现和 Go 在 1.7 版本引入的 context 模块比较相似，当然 Go 的 context 模块功能要更强大一些，除了可以传递数据之外，对多个 goroutine 的级联管理也提供了非常清蒸的解决方案。</p>
<p>然后需要强调一点，Python 的 context 是协程隔离的，我们只需要创建一个全局的 context 即可。比如协程 A 不断嵌套调用，最终调用了协程 F，但协程 F 需要使用协程 A 中的某个数据，那么这时候就可以在协程 A 中通过 context 设置数据，在协程 F 中通过 context 获取数据。</p>
<p>整个过程只需要一个 context 即可，并且也不需要手动传递 context（不然的话，还不如直接传个字典）。然后 context 是并发安全的，我们只需要一个全局的 context，需要用的时候直接导入即可。</p>
<p>当然啦，对于 contextvars 而言，它传递的数据应该是多个协程之间需要共享的数据，像 cookie, session, token 之类的，比如上游接收了一个 token，然后不断地向下透传。但是不要把本应该作为函数参数的数据，也通过 contextvars 来传递，这样就有点本末倒置了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../shutil：更优雅地拷贝文件/doc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../自定义异常堆栈信息/doc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../shutil：更优雅地拷贝文件/doc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../自定义异常堆栈信息/doc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/custom.js"></script>
    </body>
</html>
