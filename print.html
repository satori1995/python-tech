<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python 实用技巧</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="如何优雅地遍历可迭代对象？/doc.html">如何优雅地遍历可迭代对象？</a></li><li class="chapter-item expanded "><a href="解密可迭代对象的排序问题/doc.html">解密可迭代对象的排序问题</a></li><li class="chapter-item expanded "><a href="通过 TOP K 问题，探究堆和优先队列的秘密/doc.html">通过 TOP K 问题，探究堆和优先队列的秘密</a></li><li class="chapter-item expanded "><a href="如何优雅地对数据进行分组？/doc.html">如何优雅地对数据进行分组？</a></li><li class="chapter-item expanded "><a href="全方位解析 f-string/doc.html">全方位解析 f-string</a></li><li class="chapter-item expanded "><a href="最好的日期处理库：pendulum/doc.html">最好的日期处理库：pendulum</a></li><li class="chapter-item expanded "><a href="你知道创建模块都有哪些方式吗？/doc.html">你知道创建模块都有哪些方式吗？</a></li><li class="chapter-item expanded "><a href="exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？/doc.html">exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？</a></li><li class="chapter-item expanded "><a href="文件处理的一些最佳实践/doc.html">文件处理的一些最佳实践</a></li><li class="chapter-item expanded "><a href="使用 os 模块更高效地读写文件/doc.html">使用 os 模块更高效地读写文件</a></li><li class="chapter-item expanded "><a href="将文件映射到内存，像数组一样访问/doc.html">将文件映射到内存，像数组一样访问</a></li><li class="chapter-item expanded "><a href="使用 psutil 获取硬件、网络以及进程信息/doc.html">使用 psutil 获取硬件、网络以及进程信息</a></li><li class="chapter-item expanded "><a href="使用临时文件保存数据/doc.html">使用临时文件保存数据</a></li><li class="chapter-item expanded "><a href="shutil：更优雅地拷贝文件/doc.html">shutil：更优雅地拷贝文件</a></li><li class="chapter-item expanded "><a href="使用 contextvars 管理上下文变量/doc.html">使用 contextvars 管理上下文变量</a></li><li class="chapter-item expanded "><a href="自定义异常堆栈信息/doc.html">自定义异常堆栈信息</a></li><li class="chapter-item expanded "><a href="prettytable：像数据库一样格式化输出内容/doc.html">prettytable：像数据库一样格式化输出内容</a></li><li class="chapter-item expanded "><a href="轻松绘制动态条形图/doc.html">轻松绘制动态条形图</a></li><li class="chapter-item expanded "><a href="自定义 jupyter 魔法命令/doc.html">自定义 jupyter 魔法命令</a></li><li class="chapter-item expanded "><a href="解析 ini、yaml、toml 配置文件/doc.html">解析 ini、yaml、toml 配置文件</a></li><li class="chapter-item expanded "><a href="使用 fuzzywuzzy 模块计算两个字符串之间的相似度/doc.html">使用 fuzzywuzzy 模块计算两个字符串之间的相似度</a></li><li class="chapter-item expanded "><a href="命令行解析工具 argparse/doc.html">命令行解析工具 argparse</a></li><li class="chapter-item expanded "><a href="使用 urllib.parse 模块优雅地处理 URL/doc.html">使用 urllib.parse 模块优雅地处理 URL</a></li><li class="chapter-item expanded "><a href="Python 实现复制粘贴/doc.html">Python 实现复制粘贴</a></li><li class="chapter-item expanded "><a href="Python 生成、解析二维码/doc.html">Python 生成、解析二维码</a></li><li class="chapter-item expanded "><a href="解密 __getattr__ 和 __getattribute__ 的用法与区别/doc.html">解密 __getattr__ 和 __getattribute__ 的用法与区别</a></li><li class="chapter-item expanded "><a href="使用 fcntl 模块对文件进行加解锁/doc.html">使用 fcntl 模块对文件进行加解锁</a></li><li class="chapter-item expanded "><a href="详解新一代 HTTP 请求库：httpx/doc.html">详解新一代 HTTP 请求库：httpx</a></li><li class="chapter-item expanded "><a href="通过 contextlib 模块详细复习一下 with 语句的用法/doc.html">通过 contextlib 模块详细复习一下 with 语句的用法</a></li><li class="chapter-item expanded "><a href="使用 collections 模块扩展你的数据类/doc.html">使用 collections 模块扩展你的数据类</a></li><li class="chapter-item expanded "><a href="使用 unicodedata 模块对字符串标准化/doc.html">使用 unicodedata 模块对字符串标准化</a></li><li class="chapter-item expanded "><a href="使用 struct 模块打包、解包二进制数据/doc.html">使用 struct 模块打包、解包二进制数据</a></li><li class="chapter-item expanded "><a href="使用 watchfiles 模块监控目录变更/doc.html">使用 watchfiles 模块监控目录变更</a></li><li class="chapter-item expanded "><a href="读取照片的 Exif 信息/doc.html">读取照片的 Exif 信息</a></li><li class="chapter-item expanded "><a href="模拟 TLS 指纹实现反反爬/doc.html">模拟 TLS 指纹实现反反爬</a></li><li class="chapter-item expanded "><a href="生成词云/doc.html">生成词云</a></li><li class="chapter-item expanded "><a href="你知道 Python 其实自带了小型数据库吗/doc.html">你知道 Python 其实自带了小型数据库吗</a></li><li class="chapter-item expanded "><a href="聊一聊 Python 的换行以及转义/doc.html">聊一聊 Python 的换行以及转义</a></li><li class="chapter-item expanded "><a href="分享一个 Python 处理音频的库/doc.html">分享一个 Python 处理音频的库</a></li><li class="chapter-item expanded "><a href="pyquery：一个灵活方便的 HTML 解析库/doc.html">pyquery：一个灵活方便的 HTML 解析库</a></li><li class="chapter-item expanded "><a href="生成并识别图片验证码/doc.html">生成并识别图片验证码</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 实用技巧</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/python-tech" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>本篇文章来介绍如何优雅地遍历可迭代对象，举个例子：</p>
<pre><code class="language-Python">data = [&quot;古明地觉&quot;, &quot;芙兰朵露&quot;, &quot;雾雨魔理沙&quot;]

for item in data:
    print(item)
&quot;&quot;&quot;
古明地觉
芙兰朵露
雾雨魔理沙
&quot;&quot;&quot; 
</code></pre>
<p>遍历一个可迭代对象，可以使用 for 循环，每次会从可迭代对象中迭代出一个元素。当迭代完毕时，抛出 StopIteration，然后 for 循环捕获，终止循环。</p>
<p>当然，可迭代对象对内部的元素没有要求，可以指向任意的对象。</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

for item in data:
    print(item)
&quot;&quot;&quot;
('古明地觉', '女', '地灵殿')
('琪露诺', '女', '雾之湖')
('芙兰朵露', '女', '红魔馆')
&quot;&quot;&quot;
</code></pre>
<p>此时迭代出来的元素就是一个个的元组，如果想获取元组里面的元素，那么可以通过索引的方式获取，比如 item[0]。但是基于索引的话，代码可读性不高，于是你可能会这么做。</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

for item in data:
    name, gender, address = item
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>通过这种方式，代码的可读性变得更高了一些。但实际上，这段代码有点冗余，我们可以简化一下：</p>
<pre><code class="language-Python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

# name, gender, address 周围的小括号可以省略
for (name, gender, address) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>for 后面可以跟一个循环变量，也可以跟多个循环变量组成的元组。如果 for 后面跟的是一个普通的变量，那么可迭代对象里面的元素迭代出来之后会直接赋值给该变量。</p>
<p>如果 for 后面跟的是多个变量组成的元组，那么可迭代对象里迭代出来的元素必须仍是一个可迭代对象，并且迭代出来的每一个可迭代对象里面的元素个数，都必须和 for 后面的元组里的变量个数相同。最后进行解包，按照顺序将值分别赋给 for 后面的变量，这里就是 name, gender, address。</p>
<p>那么问题来了，这两种迭代方式有什么不同呢？</p>
<pre><code class="language-Python"># 第一种迭代方式
for item in data:
    name, gender, address = item
    print(name, gender, address)

# 第二种迭代方式
for name, gender, address in data:
    print(name, gender, address)
</code></pre>
<p>我们看一下字节码就清楚了，字节码面前没有秘密：</p>
<pre><code class="language-Python"> # 第一种迭代方式对应的字节码
 
 # 加载变量 data
 0 LOAD_NAME                0 (data)
 # 获取可迭代对象对应的迭代器
 2 GET_ITER
 # 将元素迭代出来
 4 FOR_ITER                13 (to 32)
 # 赋值给变量 item
 6 STORE_NAME               1 (item)
 # 加载变量 item，item 一定也指向一个可迭代对象
 8 LOAD_NAME                1 (item)
 # 解包
10 UNPACK_SEQUENCE          3
 # 按照顺序将里面的值赋给变量 name, gender, address
12 STORE_NAME               2 (name)
14 STORE_NAME               3 (gender)
16 STORE_NAME               4 (address)


 # 第二种迭代方式对应的字节码

 0 LOAD_NAME                0 (data)
 2 GET_ITER
 4 FOR_ITER                11 (to 28)
 6 UNPACK_SEQUENCE          3
 # 前面三条字节码没有区别
 # 但是这里将元素迭代出来之后，直接就解包了
 8 STORE_NAME               1 (name)
10 STORE_NAME               2 (gender)
12 STORE_NAME               3 (address)
</code></pre>
<p>所以这两种方式没有本质上的区别，只是第一种方式在将元素迭代出来之后需要单独用一个变量保存，然后加载变量，最后进行解包；而第二种方式在将元素迭代出来之后，直接就解包了。因此虽然效果是一样的，但是第二种方式要稍微快一点点，因为它少执行了两条指令。</p>
<p>另外，还有一种特殊情况：</p>
<pre><code class="language-python">data = [[1], [2], [3], [4]]
# for 后面是一个变量
for item in data:
    print(item)
&quot;&quot;&quot;
[1]
[2]
[3]
[4]
&quot;&quot;&quot;    

# for 后面是包含一个变量的元组
for item, in data:
    print(item)
&quot;&quot;&quot;
1
2
3
4
&quot;&quot;&quot;
</code></pre>
<p>由于 data 里面的元素也是列表，所以 for 后面仍然可以跟一个元组，迭代的时候会自动解包。只是当元组里面只有一个元素的时候，需要在第一个元素的后面加上一个逗号，什么意思呢？举个例子：</p>
<pre><code class="language-python">data = [[1], [2], [3], [4]]
# 这里虽然给 item 加上了括号，但它仍然不是一个元组
for (item) in data:
    print(item)
&quot;&quot;&quot;
[1]
[2]
[3]
[4]
&quot;&quot;&quot;    

# 如果元组里面只有一个元素
# 那么第一个元素后面必须要有一个逗号
# 否则解释器会认为这个括号只是起到一个限定优先级的作用
for (item,) in data:
    print(item)
&quot;&quot;&quot;
1
2
3
4
&quot;&quot;&quot;

# 再举个栗子
a, b, c = 3, 2, 4
# 此时 a + b 周围的括号只是起到了一个限定作用
# 用于提高 a + b 的优先级
print((a + b) * c)  # 20

# 但如果是这样的话，就不同了
# 此时和 c 相乘的不再是整数，而是一个元组
print((a + b,) * c)  # (5, 5, 5, 5)
</code></pre>
<p>当然啦，变量赋值也是同样的道理，因为每一次 for 循环本质上也是一次变量赋值。</p>
<pre><code class="language-Python">numbers = (99, 96, 100)

a, b, c = numbers
print(a, b, c)  # 99 96 100

# 也可以显式地使用括号括起来
(a, b, c) = (99, 96, 100)
print(a, b, c)  # 99 96 100

# 如果变量名字比较长，那么还可以换行写
(
    a,
    b,
    c
) = numbers
print(a, b, c)  # 99 96 100

# 当可迭代对象只包含一个元素时，也是同理
numbers = (88,)
(a,) = numbers
print(a)  # 88
# 赋值的时候，元组周围的小括号可以不要 
a, = numbers
print(a)  # 88
</code></pre>
<p>最后还有一个神奇的地方，在赋值的时候，多个变量不仅可以组成一个元组，还可以组成一个列表，举个例子：</p>
<pre><code class="language-python">numbers = (99, 96, 100)

[a, b, c] = numbers
print(a, b, c)  # 99 96 100

# 如果是列表的话，当只有一个元素的时候，就不需要逗号了
numbers = [88]
[a] = numbers
print(a)  # 88

# for 循环的时候也是同理
data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]
for [name, gender, place] in data:
    print(name, gender, place)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>当然啦，无论多个变量组成的是元组还是列表，字节码都没有区别。只是我们更习惯写成元组，并且将元组周围的小括号省略掉。</p>
<p>另外可迭代对象也是可以嵌套的，举个例子：</p>
<pre><code class="language-Python">data = [(&quot;古明地觉&quot;, (&quot;女&quot;, &quot;地灵殿&quot;)),
        (&quot;琪露诺&quot;, (&quot;女&quot;, &quot;雾之湖&quot;)),
        (&quot;芙兰朵露&quot;, (&quot;女&quot;, &quot;红魔馆&quot;))]

# 每个可迭代对象内部只有两个元素，所以在迭代的时候
# for 后面的元组或列表里面也只能有两个变量
for name, gender_address in data:
    print(name, gender_address)
&quot;&quot;&quot;
古明地觉 ('女', '地灵殿')
琪露诺 ('女', '雾之湖')
芙兰朵露 ('女', '红魔馆')
&quot;&quot;&quot;

# 于是聪明的你可能想到了
for name, (gender, address) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

# 使用列表也是可以的
for [name, (gender, address)] in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;    

# 以下几种方式也是可以的
&quot;&quot;&quot;
for [name, [gender, address]] in data:
    print(name, gender, address)

for (name, [gender, address]) in data:
    print(name, gender, address)

for (name, (gender, address)) in data:
    print(name, gender, address)
&quot;&quot;&quot;
</code></pre>
<p>并且嵌套的可迭代对象的数量也是任意的，举个例子：</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, (&quot;女&quot;,), (&quot;地灵殿&quot;,)),
        (&quot;琪露诺&quot;, (&quot;女&quot;,), (&quot;雾之湖&quot;,)),
        (&quot;芙兰朵露&quot;, (&quot;女&quot;,), (&quot;红魔馆&quot;,))]

for name, gender, address in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 ('女',) ('地灵殿',)
琪露诺 ('女',) ('雾之湖',)
芙兰朵露 ('女',) ('红魔馆',)
&quot;&quot;&quot;

for name, [gender], [address] in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

for name, (gender,), (address,) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

# 变量赋值也是同理
numbers = [[[3]]]
a = numbers
print(a)  # [[[3]]]

a, = numbers
print(a)  # [[3]]

((a,),) = numbers
print(a)  # [3]

(((a,),),) = numbers
print(a)  # 3
[[[a]]] = numbers
print(a)  # 3

# 再来一个恶心人的，当然啦，这个做法没啥意义
# 只是想表明可迭代对象之间的嵌套是非常自由的
numbers = [[[3], [[[[4]], 5], 6]], 7]
(((a,), ((((b,),), c), d)), e) = numbers
print(a, b, c, d, e)  # 3 4 5 6 7
</code></pre>
<p>最后再来介绍一个高级特性，不过介绍之前先来看看上面的迭代方式有什么缺陷：</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
</code></pre>
<p>如果是这种情况的话，那么 for 循环在遍历的时候，要使用几个变量去遍历呢？两个、三个、还是四个呢？我们先用三个变量看看：</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for a, b, c in data:
    print(a, b, c)
&quot;&quot;&quot;
Traceback (most recent call last):
  File &quot;...&quot;, line 6, in &lt;module&gt;
    for a, b, c in data:
ValueError: too many values to unpack (expected 3)
&quot;&quot;&quot;
</code></pre>
<p>很明显它报错了，所以这种方式有一个缺陷，就是它除了要求可迭代对象里面的元素也是可迭代对象之外，还要满足它们内部的值的个数都相等，并且个数已知。</p>
<p>但是问题来了，如果我在遍历的时候，只想拿到里面的第一个值和最后一个值，该怎么办呢？</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for item in data:
    print(item[0], item[-1])
&quot;&quot;&quot;
1 4
5 6
7 9
&quot;&quot;&quot;
</code></pre>
<p>首先上面这种方式肯定是可以的，但还有没有另外的方式呢？显然是有的。</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for first, *middle, last in data:
    print(first, middle, last)
&quot;&quot;&quot;
1 [2, 3] 4
5 [] 6
7 [8] 9
&quot;&quot;&quot;
</code></pre>
<p>在迭代的时候，第一个值会赋给 first，这没有问题。然后是 middle，它的前面加上了一个 *，那么 middle 就会变成一个列表，这个类似正则的贪婪匹配，会不断地匹配值。而 *middle 后面还有一个 last，因此 *middle 就会匹配到倒数第二个值为止，最后一个值留给 last。</p>
<p>我们再举几个例子：</p>
<pre><code class="language-python">data = [
    (1, 2, 3, 4, 5),
    (6, 7, 8, 9, 10),
    (11, 12, 13, 14, 15)
]

# 第 1 个值给 a、剩余的 4 个值给 b
for a, *b in data:
    print(a, b)
&quot;&quot;&quot;
1 [2, 3, 4, 5]
6 [7, 8, 9, 10]
11 [12, 13, 14, 15]
&quot;&quot;&quot;

# 第 1 个值给 a、第 2 个值给 b，剩余的 3 个值给 c
for a, b, *c in data:
    print(a, b, c)
&quot;&quot;&quot;
1 2 [3, 4, 5]
6 7 [8, 9, 10]
11 12 [13, 14, 15]
&quot;&quot;&quot;

# 第 1 个值给 a、第 2 个值给 b
# 倒数第 1 个值给 d，剩余的值给 c
for a, b, *c, d in data:
    print(a, b, c, d)
&quot;&quot;&quot;
1 2 [3, 4] 5
6 7 [8, 9] 10
11 12 [13, 14] 15
&quot;&quot;&quot;

# 倒数第 1 个值给 b，前面的值给 a
for *a, b in data:
    print(a, b)
&quot;&quot;&quot;
[1, 2, 3, 4] 5
[6, 7, 8, 9] 10
[11, 12, 13, 14] 15
&quot;&quot;&quot;    

# 每次迭代的元素内部只有 5 个值，所以 b 是一个空列表
for a, *b, c, d, e, f in data:
    print(a, b, c, d, e, f)
&quot;&quot;&quot;
1 [] 2 3 4 5
6 [] 7 8 9 10
11 [] 12 13 14 15
&quot;&quot;&quot;

# 所有的值都给 a，但是需要注意：
# 如果出现了 *，那么 for 后面的变量必须组成一个元组或列表
# 所以如果是 for *a in data: 会报出语法错误
# 必须是 for *a, in data: 或者 for [*a] in data:
for *a, in data:
    print(a)
&quot;&quot;&quot;
[1, 2, 3, 4, 5]
[6, 7, 8, 9, 10]
[11, 12, 13, 14, 15]
&quot;&quot;&quot;    
</code></pre>
<p>另外还有一个约定或者说规范，如果在遍历的时候，有一部分的值我们不需要，那么可以使用下划线代替。比如我们只需要第一个值和倒数第二个值，那么遍历的时候就可以像下面这么做：</p>
<pre><code class="language-python">for a, *_, b, _ in data:
    pass
</code></pre>
<p>当然啦，* 不仅可以在 for 循环的时候用，普通的变量赋值也是可以使用的，一样的道理。</p>
<blockquote>
<p>在赋值的时候， * 最多只能出现一次，否则会报出语法错误。</p>
</blockquote>
<p>以上就是可迭代对象的遍历，是不是很有趣呢？</p>
<div style="break-before: page; page-break-before: always;"></div><p>假设有一个可迭代对象，现在想要对它内部的元素进行排序，我们一般会使用内置函数 sorted，举个例子：</p>
<pre><code class="language-python">data = (3, 4, 1, 2, 5)
print(sorted(data))  # [1, 2, 3, 4, 5]

data = (3.14, 2, 1.75)
print(sorted(data))  # [1.75, 2, 3.14]

data = [&quot;satori&quot;, &quot;koishi&quot;, &quot;marisa&quot;]
print(sorted(data))  # ['koishi', 'marisa', 'satori']
</code></pre>
<p>如果可迭代对象里面的元素是数值，那么会按照数值的大小进行排序；如果是字符串，那么会按照字符串的字典序进行排序，并且 sorted 函数会返回一个新的列表。</p>
<blockquote>
<p>sorted 函数默认是升序排序，如果想要降序，那么可以传递一个关键字参数 reverse=True。</p>
</blockquote>
<pre><code class="language-python">data = [
    (3, 4), (3, 1), (2, 3)
]
print(sorted(data))  # [(2, 3), (3, 1), (3, 4)]
</code></pre>
<p>如果可迭代对象里面都是元组的话，也是可以的，元组在比较大小的时候，会先按照元组的第一个元素比较；第一个元素相等，再按照第二个元素比较，依次类推。</p>
<p>因此在使用 sorted 函数的时候，可迭代对象内部的元素，要满足彼此之间都是可比较的，否则报错。</p>
<pre><code class="language-Python">data = [123, 456, &quot;123&quot;]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'str' and 'int'

data = [{&quot;a&quot;: 1}, {&quot;b&quot;: 2}, {&quot;c&quot;: 3}]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'

</code></pre>
<p>我们看到，由于 data 里面存在不可比较的元素，因此报错了。那么问题来了，假设有这样一个列表：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 字典是不可比较大小的，因此直接使用 sorted 会报错
# 我们希望按照字典内部的 &quot;age&quot; 字段进行排序，得到下面的结果

[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
</code></pre>
<p>如果是你的话，你会怎么做呢？很明显，我们将每个 &quot;age&quot; 字段的值取出来，和所在的字典拼接成一个元组（或列表）不就行了，然后对元组进行排序，举个例子：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 由于 data 内部的元素是一个元组
# 所以排序的时候会按照元组的第一个元素排序
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16}), 
 (17, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时顺序就排好了，然后再把字典取出来
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>显然这样就实现了基于字典内部某个字段的值，来对字典进行排序，只不过上面的代码还有一点点缺陷。我们说元组在比较的时候会先比较第一个元素，第一个元素相同的话，会比较第二个元素。</p>
<p>而我们上面 data 里面的元组，由于第一个元素都不相等，所以直接就比较出来了。但如果是下面这种情况呢？</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (16, {'name': 'marisa', 'age': 16}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;
try:
    sorted_data = sorted(data)
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'
</code></pre>
<p>此时就报错了，因为第二个元组和第三个元组内部的第一个元素都是 16，所以第一个元素相等，那么会比较第二个元素。而第二个元素是字典，字典之间无法比较，所以报错了。</p>
<p>但我们只是希望让字典的 &quot;age&quot; 字段的值参与比较，如果相等的话，那么就不用再比较了，相对顺序就保持现状。所以我们可以这么做：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 将索引也加进去
data = [(d[&quot;age&quot;], i, d) for i, d in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, {'name': 'satori', 'age': 17}), 
 (16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 如果 &quot;age&quot; 字段的值、或者说元组的第一个元素相等
# 那么就按照索引比较，而索引一定是不重复的
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16}), 
 (17, 0, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时就成功排好序了，并且 &quot;age&quot; 字段的值相等的字典之间的相对顺序
# 在排序之前和排序之后都保持一致，这正是我们想要的结果
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>再比如，我们想要对元组排序，但我们希望按照元组的第二个元素进行排序：</p>
<pre><code class="language-python">data = [(&quot;satori&quot;, 17), 
        (&quot;marisa&quot;, 15), 
        (&quot;koishi&quot;, 16)]

data = [(item[1], i, item) for i, item in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, ('satori', 17)), 
 (15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16))]
&quot;&quot;&quot;

sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16)), 
 (17, 0, ('satori', 17))]
&quot;&quot;&quot;

sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[('marisa', 15), 
 ('koishi', 16), 
 ('satori', 17)]
&quot;&quot;&quot;
</code></pre>
<p>所以当可迭代对象内部的元素无法进行排序，或者说我们不希望基于整个元素进行排序，那么就可以使用上面这个方法。将用来排序的值、索引、原始值放在一个元组里面，然后对元组排序，排完了再把最后一个值（也就是原始值）筛出来即可。</p>
<p>或者我们还可以做的再复杂一些：</p>
<pre><code class="language-python">data = [-3, -2, 3, 2, -1, 1, 0]
&quot;&quot;&quot;
对 data 进行排序，排序规则如下
先按照内部元素的正负进行排序，排序之后正数在后面
如果符号一样，再按照绝对值的大小进行排序
也就是说，排完之后是下面这样一个结果

[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

# 如果只按照正负排序
data1 = [(n &gt;= 0, i, n) for i, n in enumerate(data)]
sorted_data = sorted(data1)
print(sorted_data)
&quot;&quot;&quot;
[(False, 0, -3), (False, 1, -2), (False, 4, -1), 
 (True, 2, 3), (True, 3, 2), (True, 5, 1), (True, 6, 0)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 此时正数就排在了负数的后面
print(sorted_data)
&quot;&quot;&quot;
[-3, -2, -1, 3, 2, 1, 0]
&quot;&quot;&quot;

# 如果只按照绝对值排序
data2 = [(abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data2)
print(sorted_data)
&quot;&quot;&quot;
[(0, 6, 0), (1, 4, -1), (1, 5, 1), 
 (2, 1, -2), (2, 3, 2), (3, 0, -3), (3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[0, -1, 1, -2, 2, -3, 3]
&quot;&quot;&quot;

# 同时按照正负和绝对值排序
data3 = [(n &gt;= 0, abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data3)
print(sorted_data)
&quot;&quot;&quot;
[(False, 1, 4, -1), (False, 2, 1, -2), 
 (False, 3, 0, -3), (True, 0, 6, 0), 
 (True, 1, 5, 1), (True, 2, 3, 2), (True, 3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 大功告成
print(sorted_data)
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;
</code></pre>
<p>那么接下来，我们就可以封装一个属于我们自己的 my_sorted 函数了。</p>
<pre><code class="language-python">def my_sorted(data, *, key=None, reverse=False):
    &quot;&quot;&quot;
    :paramdata: 可迭代对象
    :paramkey: callable
    :paramreverse: 是否逆序
    :return:
    &quot;&quot;&quot;
    if key is not None:
        data = [(key(item), i, item) for i, item in enumerate(data)]
    sorted_data = sorted(data)
    if key is not None:
        sorted_data = [item[-1] for item in sorted_data]
    if reverse:
        sorted_data = sorted_data[:: -1]
    return sorted_data

# 下面来测试一下
data = [-3, -2 ,3, 2, -1, 1, 0]
print(my_sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(my_sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>结果一切正常，当然啦，实际工作中我们肯定不会专门封装一个 my_sorted 函数，因为内置的 sorted 已经包含了我们上面的所有功能。</p>
<pre><code class="language-python">data = [-3, -2 ,3, 2, -1, 1, 0]
print(sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>内置函数 sorted 除了接收一个可迭代对象之外，还接收两个关键字参数 key 和 reverse，含义就是我们介绍的那样。在 sorted 的内部，它的处理方式和我们上面是一致的，如果指定了 key，也就是自定义排序规则，那么在底层会将可迭代对象内部的值封装成元组，然后对元组排序。排完序之后，再将元组的最后一个值、也就是原始值取出来，并返回。</p>
<p>所以这就是 sorted 函数的全部秘密，它里面的参数 key 赋予了 sorted 函数强大的能力，有了这个参数，我们想怎么排序，就怎么排序。</p>
<pre><code class="language-python">class A:
    
    def __init__(self, a):
        self.a = a
    
    def __repr__(self):
        return f&quot;self.a = {self.a}&quot;
    
    def __hash__(self):
        return self.a
    
a1 = A(1)
a2 = A(2)
a3 = A(3)
a4 = A(4)

data = [a2, a3, a1, a4]
print(data)
&quot;&quot;&quot;
[self.a = 2, self.a = 3, self.a = 1, self.a = 4]
&quot;&quot;&quot;

# A 的实例对象无法比较，我们希望按照内部的属性 a 进行比较
print(sorted(data, key=lambda x: x.a))
&quot;&quot;&quot;
[self.a = 1, self.a = 2, self.a = 3, self.a = 4]
&quot;&quot;&quot;

# 或者按照哈希值比较，此时仍相当于按照 self.a 比较
print(sorted(data, key=lambda x: hash(x), reverse=True))
&quot;&quot;&quot;
[self.a = 4, self.a = 3, self.a = 2, self.a = 1]
&quot;&quot;&quot;
</code></pre>
<p>因此我们想怎么比就怎么比，参数 key 赋予了我们极大的自由，key 接收一个函数（当然其它 callable 也可以，但大部分场景都是匿名函数），此函数接收一个参数，该参数会对应可迭代对象里面的每一个元素。而函数的返回值，决定了 sorted 的比较逻辑。</p>
<p>比如，我们不光可以对元组、列表排序，还可以对字典内部的键值对排序。</p>
<pre><code class="language-Python">data = {&quot;satori&quot;: 17, &quot;marisa&quot;: 15, &quot;koishi&quot;: 16}

# 对字典调用 sorted，针对的是字典里面的键，所以返回的也是键
print(sorted(data))  # ['koishi', 'marisa', 'satori']

# 匿名函数里面的参数 x 对应可迭代对象里面的每一个元素
# 这里就是字典的键，函数返回 d[x] 表示按照值来排序，但排序之后得到的仍然是键
print(sorted(data, key=lambda x: data[x]))  # ['marisa', 'koishi', 'satori']

# 此时的 x 就是键值对组成的元组，这里按照值来排序
print(
    sorted(data.items(), key=lambda x: x[1])
)  # [('marisa', 15), ('koishi', 16), ('satori', 17)]
</code></pre>
<p>当然啦，还有很多其它排序方式，比如按照数量排序：</p>
<pre><code class="language-python">string = &quot;a&quot; * 4 + &quot;b&quot; * 3 + &quot;c&quot; * 5 + &quot;d&quot; * 2
data = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

print(
    sorted(data, key=lambda x: string.count(x))
)  # ['d', 'b', 'a', 'c']
</code></pre>
<p>最后再来介绍一个知识点，sorted 在对可迭代对象内部的元素进行排序的时候，肯定要有大小比较的过程，这是肯定的。但问题是比较的时候，用的什么方式呢？举个例子，我想判断 a 和 b 的大小关系（假设不相等），无论是执行 a &gt; b 还是 a &lt; b，根据结果我都能得出它们谁大谁小。</p>
<p>而 sorted 在比较的时候是怎么做的呢，这里给出结论：每次在比较两个对象的时候，都会调用左边对象的 __lt__ 方法。其实关于 sorted 内部是怎么比的，我们无需太关注，但之所以说这一点，是因为在极端场景下可能会遇到。举个例子：</p>
<pre><code class="language-python"># 第一个元素表示 &quot;商品名称&quot;
# 第二个元素表示 &quot;销量&quot;
data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

# 我们需要先按照 &quot;销量&quot; 的大小降序排序
# 如果 &quot;销量&quot; 相同，则按照 &quot;商品名称&quot; 的字典序升序排序
# 该怎么做呢？

# 由于一部分升序，一部分降序
# 我们无法直接使用 reverse 参数，所以就默认按照升序排
# 虽然 &quot;销量&quot; 要求降序排，但可以对它取反
# 这样值越大，取反之后的值就越小，从而实现降序效果
print(
    sorted(data, key=lambda x: (~x[1], x[0]))
)
&quot;&quot;&quot;
[('apple', 200), 
 ('banana', 200), 
 ('cherry', 150), 
 ('orange', 150), 
 ('peach', 150)]
&quot;&quot;&quot;
</code></pre>
<p>可能有小伙伴觉得这也没什么难的，那么我们将问题稍微换一下。如果让你先按照 &quot;销量&quot; 升序排序，如果 &quot;销量相同&quot;，再按照 &quot;商品名称&quot; 的字典序降序排序，你要怎么做呢？</p>
<p>显然这个问题的难点就在于字符串要怎么降序排，整数可以取反，但字符串是无法取反的。所以我们可以自定义一个类，实现它的 __lt__ 方法。</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

class STR(str):
    def __lt__(self, other):
        # 调用 str 的 __lt__，得到布尔值，然后再取反
        # 当然，把 not 换成 ~ 也是可以的
        # 因此：&quot;apple&quot; &lt; &quot;banana&quot; 为 True
        # 但是：STR(&quot;apple&quot;) &lt; STR(&quot;banana&quot;) 为 False
        return not super().__lt__(other)

# 销量升序排，直接 x[1] 即可
# 但是商品名称降序排，需要使用类 STR 将 x[0] 包起来
print(sorted(data, key=lambda x: (x[1], STR(x[0]))))
&quot;&quot;&quot;
[('peach', 150), 
 ('orange', 150), 
 ('cherry', 150), 
 ('banana', 200), 
 ('apple', 200)]
&quot;&quot;&quot;

# 事实上，如果你的思维够灵活，你会发现
# &quot;销量&quot;降序排、&quot;商品名称&quot;升序排，排完之后再整体取反
# 就是这里 &quot;销量&quot;升序排、&quot;商品名称&quot;将序排 的结果
print(
    sorted(data, key=lambda x: (~x[1], x[0]), reverse=True)
    ==
    sorted(data, key=lambda x: (x[1], STR(x[0])))
)  # True
# 当然这个思路也很巧妙
</code></pre>
<p>由于默认是调用 __lt__ 进行比较的，因此我们需要实现 __lt__。</p>
<p>以上就是 Python 中如何对可迭代对象进行排序，还是很有意思的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>在工作中我们经常会遇到这样一个需求，就是获取可迭代对象中的前 K 个最大或最小的元素。我们之前介绍过排序，所以一个最简单的办法就是先排序，排完了再选择前 K 个元素即可。</p>
<pre><code class="language-Python">data = [3, 1, 2, 5, 4]

# 选择前 3 个最大的元素，和前 3 个最小的元素
sorted_data = sorted(data)
print(f&quot;TOP 3 MAX：{sorted_data[-3:]}&quot;)
print(f&quot;TOP 3 MIN：{sorted_data[: 3]}&quot;)
&quot;&quot;&quot;
TOP 3 MAX：[3, 4, 5]
TOP 3 MIN：[1, 2, 3]
&quot;&quot;&quot;

# 或者这么做
sorted_data = sorted(data, reverse=True)
print(f&quot;TOP 3 MAX：{sorted_data[: 3]}&quot;)
print(f&quot;TOP 3 MIN：{sorted_data[-3:]}&quot;)
&quot;&quot;&quot;
TOP 3 MAX：[5, 4, 3]
TOP 3 MIN：[3, 2, 1]
&quot;&quot;&quot;
</code></pre>
<p>显然这是一种解决办法，但如果列表的长度非常大，排序就会带来不小的开销。而且有时我们只要前几个元素即可，比如长度为 10000 的列表，我们只想要前三个最大或最小的元素，那么此时对整个列表进行排序显然会存在性能上的浪费。</p>
<blockquote>
<p>sorted 函数的时间复杂度是 O(NlogN)</p>
</blockquote>
<p>所以接下来我们要介绍一个模块叫 heapq，通过该模块我们能快速地获取前 K 个元素。</p>
<pre><code class="language-Python">import random
import heapq

data = [random.randint(10, 10000) for _ in range(1000)]

# 选择前 3 个最大的元素
print(heapq.nlargest(3, data))
print(sorted(data, reverse=True)[: 3])
&quot;&quot;&quot;
[9997, 9995, 9984]
[9997, 9995, 9984]
&quot;&quot;&quot;

# 选择前 3 个最小的元素
print(heapq.nsmallest(3, data))
print(sorted(data)[: 3])
&quot;&quot;&quot;
[23, 39, 52]
[23, 39, 52]
&quot;&quot;&quot;
</code></pre>
<p>得到的结果是一样的，但是性能差异如何呢？我们来测一下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./1.png" alt="" /></p>
<p>可以看到性能差异还是蛮大的，并且列表长度越大，性能差距越明显。而根本原因就在于 sorted 会对列表进行全局排序，而 heapq 没有。因此在获取前 K 个元素、并且 K 和列表长度差距比较大的时候，不妨使用 heapq 的 nsmallest 和 nlargest 函数，性能会有明显提升。</p>
<blockquote>
<p>但如果 K 和列表长度相差不大，那么先 sorted 排序，再使用切片的方式会更好一些。</p>
</blockquote>
<p>nsmallest 和 nlargest 这两个函数都接收 3 个参数，第一个参数表示要获取前多少个元素、第二个参数表示可迭代对象（一般是列表）、第三个参数是 key（和 sorted 函数里面的 key 含义相同）。</p>
<pre><code class="language-python">import random
import heapq

data = [{&quot;number&quot;: random.randint(10, 10000)} for _ in range(1000)]

# data 内部都是字典
# 获取前 3 个 number 字段的值最大的字典
print(heapq.nlargest(3, data, key=lambda x: x[&quot;number&quot;]))
print(sorted(data, key=lambda x: x[&quot;number&quot;], reverse=True)[: 3])
&quot;&quot;&quot;
[{'number': 9998}, {'number': 9963}, {'number': 9956}]
[{'number': 9998}, {'number': 9963}, {'number': 9956}]
&quot;&quot;&quot;
</code></pre>
<p>特别提示，如果 K 为 1，那么使用内置函数 min 和 max 是最佳选择。</p>
<pre><code class="language-Python">import random
import heapq

data = [{&quot;number&quot;: random.randint(10, 10000)} for _ in range(1000)]

# data 内部都是字典
# 获取前 3 个 number 字段的值最大的字典
print(heapq.nlargest(1, data, key=lambda x: x[&quot;number&quot;]))
print(sorted(data, key=lambda x: x[&quot;number&quot;], reverse=True)[0])
print(max(data, key=lambda x: x[&quot;number&quot;]))
&quot;&quot;&quot;
[{'number': 9997}]
{'number': 9997}
{'number': 9997}
&quot;&quot;&quot;
</code></pre>
<p>所以结论如下，当获取最大或最小元素的个数为 K，列表（可迭代对象）长度为 L 时：</p>
<ul>
<li>K 等于 1，使用内置函数 max 或 min；</li>
<li>K 不等于 1、且远小于 L，使用 heapq 模块的 nlargest 或 nsmallest 函数；</li>
<li>K 和 L 差别不大，使用 sorted 先全局排序、然后再通过切片方式截取；</li>
</ul>
<p>当然啦，以上都属于基础知识，比较简单。其实选择前 K 个元素就是我们常说的 TOP K 问题，如果只是单纯地想解决 TOP K 问题的话，上面已经给出了方案。这里我主要是想通过 TOP K 来引出一种数据结构，也就是堆。</p>
<p>堆是一种非常高效的数据结构，我们可以用它实现优先队列，堆实现的优先队列在元素入队、出队的时间复杂度上均为 O(logN)。</p>
<h2 id="什么是堆"><a class="header" href="#什么是堆">什么是堆？</a></h2>
<p>首先堆本身是一棵树，如果这棵树是二叉树，那么实现的堆就被称为二叉堆。当然除了二叉堆，还有三叉堆等等，只不过二叉堆是一种最主流的堆的实现方式。因此，堆（二叉堆）就是一棵满足一些特殊性质的二叉树，那么问题来了，它都满足哪些性质呢？</p>
<ul>
<li>堆是一棵完全二叉树；</li>
<li>堆里的每一个节点都大于等于（或小于等于）它的孩子节点；
<ul>
<li>如果每个节点都大于等于它的孩子节点，或者说每个节点都不大于它的父节点，那么这个堆就是大根堆；</li>
<li>如果每个节点都小于等于它的孩子节点，或者说每个节点都不小于它的父节点，那么这个堆就是小根堆；</li>
</ul>
</li>
</ul>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./2.png" alt="" /></p>
<p>注意：堆要求的是每个节点和其孩子节点之间要满足相应的大小关系，如果两个节点之间没有父子关系，那么它们谁大谁小无关紧要。比如图上的大根堆，第三层的最后一个节点是 13，可第四层的节点却都比它大，但它们之间没有父子关系，所以当前这个堆是成立的。</p>
<p>正是因为堆的这个性质，我们可以使用数组来表示堆，直接按照层序遍历的方式将每一层的元素放在数组中即可，比如：</p>
<p><code>[62, 41, 30, 28, 16, 22, 13, 19, 17, 15]</code></p>
<p>很明显，堆顶（数组索引为 0）的元素永远是值最大或最小的元素，如果构建的是大根堆，堆顶元素最大；构建的是小根堆，堆顶元素最小。</p>
<p>但是问题来了，如果我有一个节点，要如何找到它的父节点或者孩子节点呢？结论如下，假设当前节点所在的索引为 i。</p>
<ul>
<li>父节点的索引：(i - 1) / 2</li>
<li>左孩子节点的索引：2 * i + 1</li>
<li>右孩子节点的索引：2 * i + 2</li>
</ul>
<p>我们以索引为 3 这个元素（值为 28）为例，它父节点的索引是 (3 - 1) / 2 = 1，也就是 41 这个元素。左孩子节点的索引是 2 * 3 + 1 = 7，也就是 19 这个元素。右孩子节点的索引显然是 8，也就是 17 这个元素。可以对照上图，检验一下是否有误，或者你也可以创建一个更大的堆，自己测试一下，但前提必须是完全二叉树才具备这个性质。</p>
<p>显然通过这种方式，我们就不需要两个指针来维持节点之间的父子关系了，使用数组索引即可，并且通过索引定位元素的速度也会更快。</p>
<h2 id="向堆中添加元素sift-up"><a class="header" href="#向堆中添加元素sift-up">向堆中添加元素（Sift Up）</a></h2>
<p>我们来看看如何往堆中添加元素，首先堆是一个完全二叉树，往堆中添加一个元素，从树的层面来看，就是往最后一层的最右端添加一个元素，如果最后一层已经满了，那么就新加一层。如果从数组的层面来看，就相当于 append 一个元素。</p>
<p>假设我们往刚才的堆中添加一个 52，那么堆的示意图就会变成如下这样：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./3.png" alt="" /></p>
<p>添加的过程非常简单，因为往堆里面添加一个节点，就是往数组里面 append 一个元素，但显然还没有结束。因为堆有两个性质，虽然我们添加元素之后仍然满足是一棵完全二叉树，但是不满足子节点都不大于它的父节点（这里我们构建的是大根堆），因为 52 明显大于它的父节点 16。</p>
<p>因此还要进行调整，将新添加的节点放到属于它的位置，具体过程也很简单：将该节点和它的父节点进行比较，如果比它的父节点大，那么就进行交换；交换之后再和它新的父节点进行比较，如果还大于新的父节点则继续交换，直到不大于为止。</p>
<p>所以从尾部添加的节点，一直向上浮动，直到找到属于它的位置，因此这个过程也被称为 Sift Up（上浮），具体示意图如下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./4.png" alt="" /></p>
<p>当交换之后，发现不大于它的父节点，那么该节点就可以停下来了。可能有人问，它父节点之上的节点该怎么办？比如爷爷节点。答案是不需要关心，因为大根堆的性质就是每个子节点不大于父节点。所以当新添加的节点不大于它的父节点时，也更不可能大于父节点之上的爷爷节点。</p>
<p>下面我们就编写代码实现一下：</p>
<pre><code class="language-python">class BinaryHeap:
    &quot;&quot;&quot;
    大根堆
    &quot;&quot;&quot;
    def __init__(self):
        # 通过数组来模拟堆，为避免直接修改堆
        # 这个数组不对外暴露，而是专门提供一个接口
        self.__data = []
    
    def show_heap(self):
        return self.__data
    
    @staticmethod
    def get_parent(i: int) -&gt; int:
        # 根据节点的索引找到其父节点的索引
        return (i - 1) // 2

    def heappush(self, item: int):
        # 往堆中添加一个节点，对于数组而言，直接 append 即可
        self.__data.append(item)
        # 但是还没有结束，添加完之后不满足堆的性质
        # 我们还要对堆进行调整，由 sift_up 函数负责，它接收一个索引
        # 表示对指定索引的节点进行上浮，显然这里是最后一个
        self.sift_up(len(self.__data) - 1)
    
    def sift_up(self, i: int):
        # 对指定索引位置的节点进行上浮
        while i &gt; 0:
            parent = self.get_parent(i)
            # 当该元素不是根节点的时候，将其和父节点进行比较
            # 如果大于父节点，两者进行交换
            if self.__data[i] &gt; self.__data[parent]:
                self.__data[i], self.__data[parent] = self.__data[parent], self.__data[i]
                # 交换之后该节点成为了父节点，然后将 parent 赋值为 i
                # 因为它还要继续作为新的子节点和新的父节点比较
                i = parent
            else:
                # 如果不大于父节点，说明该元素已经找到属于它的位置了
                # 直接将循环结束掉即可
                break
        
heap = BinaryHeap()
for item in [62, 41, 30, 28, 16, 22, 13, 19, 17, 15]:
    heap.heappush(item)
print(heap.show_heap())
&quot;&quot;&quot;
[62, 41, 30, 28, 16, 22, 13, 19, 17, 15]

                        62
            41                       30
      28          16           22          13
  19      17  15
&quot;&quot;&quot;

# 这个时候再添加一个元素 52
heap.heappush(52)
print(heap.show_heap())
&quot;&quot;&quot;
[62, 52, 30, 28, 41, 22, 13, 19, 17, 15, 16]

                        62
            52                       30
      28          41           22          13
  19      17  15      16
&quot;&quot;&quot;
</code></pre>
<p>可以看到结果是没有问题的，以上我们添加元素就成功了，下面我们再来看看如何从堆中取出元素。</p>
<h2 id="从堆中取出元素sift-down"><a class="header" href="#从堆中取出元素sift-down">从堆中取出元素（Sift Down）</a></h2>
<p>正如添加节点从堆底添加，取出节点只能从堆顶取出（也就是只能取根节点），不能取其它位置的节点。</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./5.png" alt="" /></p>
<p>但问题是，如果直接将堆顶的节点取走的话，就会形成两个独立的堆，两个堆的根节点分别是它的左右节点。我们还要手动将两个堆合并在一起，会比较麻烦，因此可以换个思路，将堆顶和堆底的元素进行交换。交换之后，弹出堆底的元素，这样就得到了最大值。</p>
<p>但该做法同时也破坏了堆的第二个性质，因为之前的堆底元素现在跑到了堆顶，肯定不满足父节点和子节点之间的大小关系，所以还要进行调整。</p>
<p>对于大根堆而言，将该节点和左右子节点中大的那一个进行比较，如果比子节点小，那么进行交换。交换之后再和它新的子节点进行比较，如果还小于新的子节点则继续交换，直到不小于为止。</p>
<p>所以从顶部的节点，一直向下沉，直到找到属于它的位置，因此这个过程也被称为 Sift Down（下沉），具体示意图如下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./6.png" alt="" /></p>
<p>注意：堆顶节点和堆底节点交换之后，就被弹出了，所以图中的 62 不再是堆节点，因此我们刻意画的淡了一些。</p>
<p>下面完善一下之前的代码：</p>
<pre><code class="language-python">class BinaryHeap:
    &quot;&quot;&quot;
    大根堆
    &quot;&quot;&quot;
    def __init__(self):
        self.__data = []
    
    def show_heap(self):
        return self.__data
    
    @staticmethod
    def get_parent(i: int) -&gt; int:
        # 根据节点的索引找到其父节点的索引
        return (i - 1) // 2
    
    @staticmethod
    def get_left_child(i: int) -&gt; int:
        # 根据节点的索引找到左孩子节点的索引
        return 2 * i + 1
    
    @staticmethod
    def get_right_child(i: int) -&gt; int:
        # 根据节点的索引找到右孩子节点的索引
        return 2 * i + 2

    def heappush(self, item: int):
        self.__data.append(item)
        self.sift_up(len(self.__data) - 1)
    
    def sift_up(self, i: int):
        while i &gt; 0:
            parent = self.get_parent(i)
            if self.__data[i] &gt; self.__data[parent]:
                self.__data[i], self.__data[parent] = self.__data[parent], self.__data[i]
                i = parent
            else:
                break
            
    def heappop(self):
        # 弹出堆顶元素
        if len(self.__data) == 0:
            raise IndexError(&quot;pop from empty heap&quot;)
        # 将第一个元素和最后一个元素进行交换
        self.__data[0], self.__data[-1] = self.__data[-1], self.__data[0]
        # 弹出最后一个元素
        item = self.__data.pop()
        # 不过在返回之前，记得调整一下堆，由 sift_down 函数负责
        # 此函数接收一个索引，表示对指定节点的索引进行下沉
        # 显然这里是第一个
        self.sift_down(0)
        return item
    
    def sift_down(self, i: int):
        # 对索引为 i 的节点进行下沉，这里需要判断孩子节点是否存在的情况
        # 如果左孩子节点的索引越界，说明该节点已经是叶子节点了
        while self.get_left_child(i) &lt; len(self.__data):
            left_child = self.get_left_child(i)
            right_child = self.get_right_child(i)
            # 获取子节点大的那一个，注意：需要考虑右节点是否存在的情况
            if right_child &lt; len(self.__data) and self.__data[right_child] &gt; self.__data[left_child]:
                child = right_child
            else:
                child = left_child
            # 将该节点和孩子节点进行比较，如果比孩子节点小，那么交换位置
            # 并继续和新的孩子节点进行比较
            if self.__data[i] &lt; self.__data[child]:
                self.__data[i], self.__data[child] = self.__data[child], self.__data[i]
                i = child
            # 否则直接跳出循环
            else:
                break

heap = BinaryHeap()
data = [4, 8, 1, 5, 3, 9, 2, 7, 6]
# 依次添加到堆中
for item in data:
    heap.heappush(item)
# 从堆中弹出，由于每次都会弹出最大值
# 所以得到的新列表是降序排序的    
print([heap.heappop() for _ in range(len(data))])
&quot;&quot;&quot;
[9, 8, 7, 6, 5, 4, 3, 2, 1]
&quot;&quot;&quot;
</code></pre>
<p>显然是没有问题的，因此我们这里就实现了一个堆排序，只不过这个堆排序还不太完美，不完美之处有两个地方：</p>
<ul>
<li>默认是从大到小排序的，应该提供一个参数供外界选择究竟是从大到小还是从小到大；</li>
<li>开辟了一个额外的数组，合适的做法应该是接收一个数组，然后原地排序；</li>
</ul>
<p>那么下面我们完善一下堆排序。</p>
<pre><code class="language-python">def get_left_child(i: int):
    return 2 * i + 1

def get_right_child(i: int):
    return 2 * i + 2

def sift_down_large(data: list, i: int, length: int):
    # 大根堆下沉，但是参数多了一个 length，这是为啥呢？
    # 因为之前是将堆顶和堆底的元素交换之后，就将堆底的元素弹出去了
    # 以至于我们需要单独开辟一个数组去接收
    # 但很明显，我们这里要求原地排序，那么交换之后的元素在堆底不可以动
    # 因此每 sift_down 一次，length 要减去 1
    while get_left_child(i) &lt; length:
        left_child = get_left_child(i)
        right_child = get_right_child(i)
        # 判断是否有右孩子，如果有右孩子，那么选择值较大的那一个孩子节点
        if right_child &lt; length and data[right_child] &gt; data[left_child]:
            child = right_child
        else:
            child = left_child
        # 如果比孩子节点的值小，那么两者进行交换，因为大根堆要求父节点不小于子节点
        if data[i] &lt; data[child]:
            data[i], data[child] = data[child], data[i]
            i = child
        else:
            break


def sift_down_small(data: list, i: int, length: int):
    # 小根堆下沉
    while get_left_child(i) &lt; length:
        left_child = get_left_child(i)
        right_child = get_right_child(i)
        # 判断是否有右孩子，如果有右孩子，那么选择值较小的那一个孩子节点
        if right_child &lt; length and data[right_child] &lt; data[left_child]:
            child = right_child
        else:
            child = left_child
        # 如果比孩子节点的值大，那么两者进行交换，因为小根堆要求父节点不大于子节点
        if data[i] &gt; data[child]:
            data[i], data[child] = data[child], data[i]
            i = child
        else:
            break

def heapify_large(data: list):
    # 将一个数组整理成大根堆的形状
    # 从最后一个非叶子节点进行 sift_down 即可
    for i in range((len(data) - 1) &gt;&gt; 1, -1, -1):
        sift_down_large(data, i, len(data))

def heapify_small(data: list):
    # 将一个数组整理成小根堆的形状
    for i in range((len(data) - 1) &gt;&gt; 1, -1, -1):
        sift_down_small(data, i, len(data))
        
def heap_sort(data: list, reverse: bool = False):
    # 堆排序，首先将 data 整理成堆的形状
    if reverse:
        heapify_small(data)
    else:
        heapify_large(data)
    # i 从最后一个元素开始
    for i in range(len(data) - 1, -1, -1):
        # 交换完之后的元素就不可以动了
        data[0], data[i] = data[i], data[0]
        # 并且也不能再参与后续的 sift_down，因此依旧调整堆，但是范围变了
        # 比如第一次交换，那么最后一个元素为最大值
        # sift_down 的时候，整个范围就是 [0: len(data) - 1]
        # 同理第二次 sift_down 的时候，范围就是 [0: len(data) - 2]
        if reverse:
            sift_down_small(data, 0, i)
        else:
            sift_down_large(data, 0, i)


import random
data = [random.randint(0, 100) for _ in range(10)]
print(data)
&quot;&quot;&quot;
[51, 4, 38, 31, 87, 18, 39, 8, 98, 61]
&quot;&quot;&quot;
heap_sort(data)
print(data)
&quot;&quot;&quot;
[4, 8, 18, 31, 38, 39, 51, 61, 87, 98]
&quot;&quot;&quot;

data = [random.randint(0, 100) for _ in range(10)]
print(data)
&quot;&quot;&quot;
[78, 11, 83, 30, 99, 61, 45, 63, 17, 81]
&quot;&quot;&quot;
heap_sort(data, reverse=True)
print(data)
&quot;&quot;&quot;
[99, 83, 81, 78, 63, 61, 45, 30, 17, 11]
&quot;&quot;&quot;
</code></pre>
<p>以上我们就实现了堆排序，那么问题来了，你觉得 heapq 模块里的 nlargest 和 nsmallest 是怎么实现的呢？</p>
<p>很简单，假设我们要选取 k 个最小的元素，那么首先可以从数组中截取前 k 个元素，构建一个大根堆。然后从第 k + 1 个元素开始遍历数组，如果当前元素大于等于堆顶元素，那么它肯定就不是前 k 小的元素，如果当前元素小于堆顶的元素，那么两者进行交换，然后进行一次 Sift Down 操作。当数组遍历完毕之后，堆中的 k 个元素就是最小的前 k 个元素。同理，如果想选择前 k 个最大的元素，那么就构建一个小根堆。</p>
<blockquote>
<p>或者将整个数组构建成一个堆，然后heappop k 次即可，这样也能选择前 k 个元素。</p>
</blockquote>
<h2 id="优先队列"><a class="header" href="#优先队列">优先队列</a></h2>
<p>其实在排序的时候，堆排序不是效率最高的排序，它比三路快排要慢一些。但是堆存在的目的绝不仅仅是为了排序，由于它可以动态添加元素、删除元素，并且时间复杂度都为 O(logN) 级别，所以堆的强大之处就在于非常适合实现优先队列。</p>
<p>事实上 heapq 也已经为我们提供了堆的相关操作：</p>
<pre><code class="language-Python">&quot;&quot;&quot;
heapq.heapify(data)
    将数组 data 整理成堆的形状，只支持小根堆

heapq.heappush(data, item)
    向堆中添加元素，并维护堆的形状
    要求 data 已经是一个小根堆

heapq.heappop(data, item)
    从堆中弹出元素，并维护堆的形状
    要求 data 已经是一个小根堆
&quot;&quot;&quot;
</code></pre>
<p>而 Python 的优先队列，底层就是借助于 heapq 实现的，我们看一下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./7.png" alt="" /></p>
<p>里面的 item 是一个元组，第一个元素是优先级（值越小、优先级越高），第二个元素是具体的数据，这就是优先队列，是不是比你想象中的要简单许多呢？</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>堆是一种非常高效的数据结构，它可以动态地添加、删除元素，并且时间复杂度均为 O(logN) 级别。这个特性就决定了它非常适合实现优先队列，维护一个堆，在往堆中添加元素的时候，只需要加一个优先级即可，也就是将优先级和数据组合成一个元组添加到堆中。如果构建的是小根堆，值越小、优先级越高；构建的是大根堆，值越大，优先级越高。</p>
<p>另外我们说，当获取最大值或最小值时，推荐使用内置函数 max 和 min。但如果数组 data 一直在动态变化，并且要随时获取里面的最大值或最小值，那么相比使用内置函数 max、min，更好的做法是将 data 维护成一个堆。然后添加元素使用 heappush，获取元素直接 data[0] 即可。因为这整体是一个 O(logN) 的操作，而是 min、max 是一个 O(N) 的操作。</p>
<p>最后，堆可以用来实现排序，效率也很高，但相比三路快排还差了那么一点。但堆存在的目的不在于排序，而在于它的动态性。优先队列就不必说了，还有 TOP K。虽然三路快排和堆都可以实现 TOP K，但前者要求数据必须一次性全部给出，而堆则没有这个要求，换句话说堆可以满足对流式数据的处理。</p>
<p>比如 1T 的文件，一行就是一串数字，如果想在 16G 内存的机器上查找最大的 100 个数字，用快排是无法实现的，因为无法将文件一次性加载到内存中。但堆可以实现这个需求，先读取 100 行维护一个小根堆，然后从 101 行继续读取，依次和堆顶进行比较。如果小于堆顶元素，那么它一定不是前 100 个最大的数字；如果大于堆顶元素，那么就替换掉，然后 sift_down，维护堆的形状。这样总有一刻，能够选出最大的 100 个数字。</p>
<p>所以当数组 data 不断变化时，将其维护成一个堆，然后通过 heappush 添加元素、heappop 弹出堆顶元素、data[0] 获取堆顶元素，往往是最佳选择。并且添加和弹出都是 logN 级别的时间复杂度，也正是这个特性，它适合优先队列以及流式数据（数据无法一次性全部给出）的处理。</p>
<div style="break-before: page; page-break-before: always;"></div><p>假设有这样一种数据：</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

# 我们需要变成如下格式
&quot;&quot;&quot;
[('apple', [30, 35, 32]),
 ('pear', [60, 32, 60]),
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>如果是你的话，你会怎么做呢？很容易想到的一种解决方案是构造一个字典：</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

data_dict = {}
for name, count in data:
    if name not in data_dict:
        data_dict[name] = []
    data_dict[name].append(count)

print(data_dict)
&quot;&quot;&quot;
{'apple': [30, 35, 32], 
 'pear': [60, 32, 60], 
 'banana': [102, 104]}
&quot;&quot;&quot;
print(list(data_dict.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]), 
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>这种方案完全没有问题，不过我们还可以写的更优雅一些，也就是使用字典的 setdefault 方法：</p>
<pre><code class="language-Python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

data_dict = {}
for name, count in data:
    # setdefault(k, v) 含义如下
    # 当 k 不存在时，将 k: v 设置在字典中，并返回 v
    # 当 k 存在时，直接返回 k 对应值
    data_dict.setdefault(name, []).append(count)

print(list(data_dict.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]), 
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>setdefault 是一个非常方便的方法，但是使用频率却不怎么高，或者说该方法不太让人喜欢。主要是每次调用都要给一个初始值，比如代码中的空列表 []。另外这里的初始值可以任意，如果你希望添加的时候还能实现去重效果，那么就将空列表换成空集合即可。</p>
<p>或者我们还可以使用 defaultdict，它位于 collections 模块中。</p>
<pre><code class="language-Python">from collections import defaultdict

data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

# 里面接收一个 callable
# 当访问的 k 不存在时，返回 callable 调用之后的值
data_dict1 = defaultdict(list)
for name, count in data:
    data_dict1[name].append(count)

print(list(data_dict1.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]),
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;

# 也可以指定为 set
data_dict2 = defaultdict(set)
for name, count in data:
    data_dict2[name].add(count)

print(list(data_dict2.items()))
&quot;&quot;&quot;
[('apple', {32, 35, 30}), 
 ('pear', {32, 60}), 
 ('banana', {104, 102})]
&quot;&quot;&quot;
</code></pre>
<p>总的来说，defaultdict 和字典的 setdefault 方法非常类似，我们使用 setdefault 即可，因为 setdefault 其实更加方便。我们不妨再看个更复杂的例子。</p>
<pre><code class="language-Python">data = [
    (&quot;a&quot;, &quot;x&quot;, 1),
    (&quot;a&quot;, &quot;x&quot;, 2),
    (&quot;a&quot;, &quot;x&quot;, 3),
    (&quot;a&quot;, &quot;y&quot;, 4),
    (&quot;a&quot;, &quot;y&quot;, 5),
    (&quot;a&quot;, &quot;z&quot;, 6),
    
    (&quot;b&quot;, &quot;x&quot;, 7),
    (&quot;b&quot;, &quot;x&quot;, 8),
    (&quot;b&quot;, &quot;y&quot;, 9),
    (&quot;b&quot;, &quot;z&quot;, 10),
]
# 如果我想得到下面的结果，怎么做呢？
&quot;&quot;&quot;
{'a': {'x': [1, 2, 3], 'y': [4, 5], 'z': [6]}, 
 'b': {'x': [7, 8], 'y': [9], 'z': [10]}}
&quot;&quot;&quot;
# 使用 setdefault 会非常方便
data_dict = {}
for first, second, value in data:
    data_dict.setdefault(first, {}).setdefault(second, []).append(value)

print(data_dict)
</code></pre>
<p>以上就是数据分组，比较简单，setdefault 这个方法非常方便，但总是容易被遗忘。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-1"><a class="header" href="#楔子-1">楔子</a></h2>
<p>在 Python3.6 之前，格式化字符串一般会使用百分号占位符或者 format 函数，举个例子：</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;

# 使用百分号占位符格式化字符串
print(
    &quot;我是 %s, 来自 %s&quot; % (name, address)
)  # 我是 古明地觉, 来自 地灵殿

# 使用format函数格式化字符串
print(
    &quot;我是 {}, 来自 {}&quot;.format(name, address)
)  # 我是 古明地觉, 来自 地灵殿

# format 函数还支持关键字参数
print(
    &quot;我是 {name}, 来自 {address}&quot;.format(address=address, name=name)
)  # 我是 古明地觉, 来自 地灵殿
</code></pre>
<p>但是从 3.6 开始，Python 新增了一个格式化字符串的方法，称之为 f-string。f-string 的功能非常强大，可以说是一把 &quot;瑞士军刀&quot;。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;

print(
    f&quot;我是 {name}, 来自 {address}&quot;
)  # 我是 古明地觉, 来自 地灵殿
</code></pre>
<p>使用 f-string 需要给字符串增加一个前缀 f，此时 <strong>{}</strong> 和它里面的内容则不再表示字符串，而是整体作为一个需要单独计算的值或者表达式、或者变量。我们再举个例子：</p>
<pre><code class="language-Python">print(f&quot;1 + 1 = {1 + 1}&quot;)  # 1 + 1 = 2
print(f&quot;sum([1, 2, 3]) = {sum([1, 2, 3])}&quot;)  # sum([1, 2, 3]) = 6
print(f&quot;{'--'.join(['a', 'b', 'c', 'd'])}&quot;)  # a--b--c--d

try:
    print(f&quot;{a}&quot;)
except Exception as e:
    print(e)  # name 'a' is not defined

# 在f-string中，{} 里面的内容是需要单独计算的
# 可以是常量，比如 {123}、{'hello'} 等等。可以是表达式，比如 {1 + 1}、{2 &gt; 1} 等等
# 可以是变量，比如 {a}、{name}，但是变量要定义好，而上面的 a 没有定义，所以报错

# 或者定义一个变量
a = lambda x: x + 100
print(f&quot;{a}&quot;)  # &lt;function &lt;lambda&gt; at 0x000...&gt;
print(f&quot;{a(1)}&quot;)  # 101
</code></pre>
<p>我们看到 f-string 还是很方便的，并且和 format 功能类似，但是性能要优于 format 函数。当然 f-string 的功能远没有目前介绍的这么简单，它支持的操作非常多，下面就来逐一介绍。</p>
<h2 id="实现-repr-打印"><a class="header" href="#实现-repr-打印">实现 repr 打印</a></h2>
<p>有时候我们在打印的时候需要带上引号。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

print(name)  # 古明地觉
print(&quot;%s&quot; % name)  # 古明地觉
# 如果使用 %r 打印，会带上单引号
print(&quot;%r&quot; % name)  # '古明地觉'

# 上面类似于 str 和 repr 的区别
print(str(name))  # 古明地觉
print(repr(name))  # '古明地觉'

# 等价于调用 __str__ 和 __repr__
print(name.__str__())  # 古明地觉
print(name.__repr__())  # '古明地觉'
</code></pre>
<p>如果在交互式环境下，不使用 print，而是直接输入变量 name、然后回车，那么会调用 __repr__ 方法。如果使用 print(name)，那么不管在什么环境，都会调用 __str__ 方法。</p>
<p>那么在字符串周围带上一层单引号，有什么意义呢？</p>
<pre><code class="language-python">birthday = &quot;1995-07-05&quot;
print(&quot;select name from where birthday &gt; %s&quot; % birthday)  
print(&quot;select name from where birthday &gt; %r&quot; % birthday)  
&quot;&quot;&quot;
select name from where birthday &gt; 1995-07-05
select name from where birthday &gt; '1995-07-05'
&quot;&quot;&quot;
</code></pre>
<p>看到区别了吗？如果是第一个查询，那么肯定是会报错的。重点来了，如何通过 f-string 实现这种效果呢？</p>
<pre><code class="language-Python">birthday = &quot;1995-07-05&quot;

# 我们只需要在打印的内容后面加上一个!r即可
print(f&quot;{birthday!r}&quot;)  # '1995-07-05'
print(f&quot;{birthday}&quot;)  # 1995-07-05

# &quot;{name}&quot; &lt;==&gt; str(name) &lt;==&gt; name.__str__()
# &quot;{name!r}&quot; &lt;==&gt; repr(name) &lt;==&gt; name.__repr__()

print(f&quot;{'.'.join(['a', 'b', 'c'])}&quot;)  # a.b.c
print(f&quot;{'.'.join(['a', 'b', 'c'])!r}&quot;)  # 'a.b.c'

# 注意：!r 针对的是字符串
# 虽然也可以作用于其它对象，不过没有效果
print(f&quot;{123!r}&quot;)  # 123
print(f&quot;{3.14!r}&quot;)  # 3.14

# 另外除了 !r，还有 !s 和 !a，只有这三种
# !a 和 !r 类似，!s是默认选择、加不加均可
print(f&quot;{birthday}&quot;)  # 1995-07-05
print(f&quot;{birthday!s}&quot;)  # 1995-07-05
print(f&quot;{birthday!a}&quot;)  # '1995-07-05'
print(f&quot;{birthday!r}&quot;)  # '1995-07-05'
</code></pre>
<p>以上就是字符串的 repr 打印。</p>
<h2 id="整数的进制转换"><a class="header" href="#整数的进制转换">整数的进制转换</a></h2>
<p>我们在打印整数的时候，有时候需要转成某个进制之后再打印。</p>
<pre><code class="language-Python">i = 123
# 打印 2 进制
print(f&quot;{i:b}&quot;)  # 1111011
# 打印 8 进制
print(f&quot;{i:o}&quot;)  # 173
# 打印 10 进制
# 默认是 10 进制，也可以直接使用 {i}
print(f&quot;{i:d}&quot;)  # 123
# 打印 16 进制
print(f&quot;{i:x}&quot;)  # 7b

# 类似于内置函数 bin、oct、hex
# 但是这些内置函数调用之后会带上一个前缀
print(bin(i))  # 0b1111011
print(oct(i))  # 0o173
print(hex(i))  # 0x7b

# f-string 可不可以实现呢？答案是可以的
print(f&quot;{i:#b}&quot;)  # 0b1111011
print(f&quot;{i:#o}&quot;)  # 0o173
print(f&quot;{i:#x}&quot;)  # 0x7b
# 对于表示 16 进制的 x，我们还可以将 x 大写
# 此时输出的内容也是大写格式的
print(f&quot;{i:#X}&quot;)  # 0X7B
</code></pre>
<p>另外除了 # 号，还可以使用 +、-、以及空格，功能如下：</p>
<ul>
<li>+：显示正负号；</li>
<li>-：负数显示符号、正数不显示；</li>
<li>空格：正数显示空格、负数不显示，只能是一个空格；</li>
<li>#：显示前缀，比如 0b、0o、0x</li>
</ul>
<p>注意：这几个符号不可混用，并且最多只能出现一次。</p>
<pre><code class="language-Python">print(f&quot;{123:+x}, {-123:+x}&quot;)  # +7b, -7b
print(f&quot;{123:-x}, {-123:-x}&quot;)  # 7b, -7b
print(f&quot;{123: x}, {-123: x}&quot;)  #  7b, -7b
print(f&quot;{123:#x}, {-123:#x}&quot;)  # 0x7b, -0x7b
</code></pre>
<p>另外，Python 在创建整数的时候，还支持使用 _ 进行分隔，但打印的时候不会将 _ 显示出来。</p>
<pre><code class="language-Python">num = 100_000_000
print(num)  # 100000000

# 但如果是 f-string 的话
print(f&quot;{num:_d}&quot;)
&quot;&quot;&quot;
100_000_000
&quot;&quot;&quot;
print(f&quot;{num:_b}&quot;)
print(f&quot;{num:#_b}&quot;)
&quot;&quot;&quot;
101_1111_0101_1110_0001_0000_0000
0b101_1111_0101_1110_0001_0000_0000
&quot;&quot;&quot;
print(f&quot;{num:_o}&quot;)
print(f&quot;{num:#_o}&quot;)
&quot;&quot;&quot;
5_7536_0400
0o5_7536_0400
&quot;&quot;&quot;
print(f&quot;{num:_x}&quot;)
print(f&quot;{num:#_x}&quot;)
&quot;&quot;&quot;
5f5_e100
0x5f5_e100
&quot;&quot;&quot;

# 只需要在 b、d、o、x 前面加上一个 _ 即可
# 这样打印出来的字符串也会带上 _ 分隔符
# 另外分隔符还可以使用逗号
print(f&quot;{num:,d}&quot;)
&quot;&quot;&quot;
100,000,000
&quot;&quot;&quot;
</code></pre>
<p>注意：b、o、d、x 这些只能用于整数，不能是其它类型的对象。</p>
<pre><code class="language-Python">print(f&quot;{'aaa':b}&quot;)
&quot;&quot;&quot;
    print(f&quot;{'aaa':b}&quot;)
ValueError: Unknown format code 'b' for object of type 'str'
&quot;&quot;&quot;
</code></pre>
<p>最后再来补充一个字符，整数除了可以使用 b、o、d、x 之外， 还可以使用一个字符，也就是 c。</p>
<pre><code class="language-Python">num = 97

print(chr(num))  # a
print(f&quot;{num:c}&quot;)  # a
</code></pre>
<p>以上就是整数的进制转换。</p>
<h2 id="整数的填充"><a class="header" href="#整数的填充">整数的填充</a></h2>
<p>很多时候，打印出来的整数都会进行位数的填充，比如 1 的话，就打印 001，18 则打印 018，123 则打印本身的 123。这种需求，要怎么去处理它呢？</p>
<pre><code class="language-Python">num = 1
# 还记得这个 d 吗？
# 我们说直接打印的话，有它没它无影响
# 但是对于填充的话，它就派上用场了
print(f&quot;{num:03d}&quot;)  # 001
print(f&quot;{num:013d}&quot;)  # 0000000000001
</code></pre>
<p>填充只能用 0 或者空格来填充，比如 0123d，表示打印出来要占 123 个字符，够的话不管了，不够则使用 0 在左边填充。</p>
<p>如果是 123d，它代表的可不是占 23 个字符、不够用 1 填充，它代表的还是占 123 个字符，但是由于我们没有指定 0，所以默认使用空格在左边填充。</p>
<pre><code class="language-Python"># 长度 23，不够使用空格填充
print(f&quot;{1:23d}&quot;)   #                       1
# 长度 23，不够使用 0 填充
print(f&quot;{1:023d}&quot;)  # 00000000000000000000001

# 当然我们同样可以结合 +、-、空格、#
print(f&quot;{1:+08d}&quot;)  # +0000001
# 可以的话，再将分隔符包含进来
print(f&quot;{1:+023_d}&quot;)  # +00_000_000_000_000_001
print(f&quot;{1:+023,d}&quot;)  # +00,000,000,000,000,001
</code></pre>
<p>当然，以上规则除了适用于十进制的 d，也同样适用于二进制的 b、八进制的 o、十六进制的 x。</p>
<pre><code class="language-Python">print(f&quot;{123:x}&quot;)
print(f&quot;{123:016x}&quot;)
&quot;&quot;&quot;
7b
000000000000007b
&quot;&quot;&quot;

# 打印显示正负号，然后占 8 个字符
print(f&quot;{123:+08d}&quot;)
print(f&quot;{123:+8d}&quot;)
&quot;&quot;&quot;
+0000123
    +123
&quot;&quot;&quot;

# 打印的时候带上前缀，占 18 个字符
print(f&quot;{123:#018b}&quot;)
print(f&quot;{123:#18b}&quot;)
# 打印的时候带上前缀和分隔符，占 18 个字符
print(f&quot;{123:#18_b}&quot;)
&quot;&quot;&quot;
0b0000000001111011
         0b1111011
        0b111_1011
&quot;&quot;&quot;
</code></pre>
<p>我们看到填充的时候，如果用 0 填充，那么会填充在 0b、+ 等前缀的后面；如果用空格填充，那么会填充在前缀的前面。当然这也符合我们正常人的思维：</p>
<ul>
<li>如果是 &quot;+    123&quot; 或者 &quot;00000+123&quot;，明显觉得别扭；</li>
<li>如果是 &quot;    +123&quot; 或者 &quot;+00000123&quot;，则明显顺眼多了；</li>
</ul>
<p>当然工作中我们不会用的这么复杂，知道整数如何填充即可。</p>
<h2 id="浮点数的小数保留"><a class="header" href="#浮点数的小数保留">浮点数的小数保留</a></h2>
<p>浮点数的小数比较长的话，我们打印的时候一般会只打印前两位或前三位，这在 f-string 里面如何实现呢？</p>
<pre><code class="language-Python">num = 123.13421

# f 是保留小数，但我们没有指定精度，所以默认保留后 6 位，不够用 0 补齐
print(f&quot;{num:f}&quot;)
&quot;&quot;&quot;
123.134210
&quot;&quot;&quot;

# .2f 则是保留两位小数
print(f&quot;{num:.2f}&quot;)
&quot;&quot;&quot;
123.13
&quot;&quot;&quot;

# 10.2f 也是保留两位小数，然后整体占满 10 个字符长度，不够的话使用空格在左边填充
print(f&quot;{num:10.2f}&quot;)
&quot;&quot;&quot;
    123.13
&quot;&quot;&quot;

# 如果不想使用空格填充的话
# 那么也可以使用(也只能使用) 0 来进行填充，规则和整数是类似的
print(f&quot;{num:010.2f}&quot;)
&quot;&quot;&quot;
0000123.13
&quot;&quot;&quot;
</code></pre>
<p>当然 +、-、空格 同样可以适用于浮点数，规则也和整数类似，同样的，下面这些在工作中也不常用，所以我们知道怎么保留指定位数的小数即可。</p>
<pre><code class="language-Python">num = 123.13421

print(f&quot;{num:+10.2f}&quot;)   
print(f&quot;{num:+010.2f}&quot;)  
&quot;&quot;&quot;
   +123.13
+000123.13
&quot;&quot;&quot;

# 同理，浮点数也支持使用下划线或者逗号进行分隔
print(f&quot;{num:+10_.2f}&quot;)  
print(f&quot;{num:+10,.2f}&quot;) 
&quot;&quot;&quot;
   +123.13
   +123.13
&quot;&quot;&quot;

# 上面由于有效字符比较少，所以没有分隔符
# 我们用 0 填充一下
print(f&quot;{num:+010_.2f}&quot;)
print(f&quot;{num:+010,.2f}&quot;)
&quot;&quot;&quot;
+00_123.13
+00,123.13
&quot;&quot;&quot;
</code></pre>
<p>以上就是浮点数的小数保留。</p>
<h2 id="任意字符的填充"><a class="header" href="#任意字符的填充">任意字符的填充</a></h2>
<p>我们上面介绍的还只是 f-string 的一部分，接下来就是 f-string 的杀手锏。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

print(f&quot;~{name:&gt;10}~&quot;)
print(f&quot;~{name:^10}~&quot;)
print(f&quot;~{name:&lt;10}~&quot;)
&quot;&quot;&quot;
~      古明地觉~
~   古明地觉   ~
~古明地觉      ~
&quot;&quot;&quot;
</code></pre>
<ul>
<li>&gt;n：输出的字符串占 n 个字符，原始的内容右对齐，长度不够则在左边用空格填充；</li>
<li>^n：输出的字符串占 n 个字符，原始的内容居中对齐，长度不够则在左右两端用空格填充；</li>
<li>&lt;n：输出的字符串占 n 个字符，原始的内容左对齐，长度不够则在右边用空格填充；</li>
</ul>
<p>还可以将 !r、!s、!a 结合起来使用。</p>
<pre><code class="language-Python">print(f&quot;{'abc'!s:&gt;10}&quot;) 
print(f&quot;{'abc'!r:&gt;10}&quot;) 
print(f&quot;{'abc'!a:&gt;10}&quot;) 
&quot;&quot;&quot;
       abc
     'abc'
     'abc'
&quot;&quot;&quot;
</code></pre>
<p>这些规则也适用于数值：</p>
<pre><code class="language-Python">print(f&quot;{3:&gt;10}&quot;)
print(f&quot;{3.14:&gt;10}&quot;)
&quot;&quot;&quot;
         3
      3.14
&quot;&quot;&quot;
</code></pre>
<p>另外默认是使用空格填充的，那么可不可以使用指定字符填充呢？答案是可以的, 直接在 &gt;、&lt;、^ 的左边写上用来填充的字符即可，但是只能写一个字符，多了报错。</p>
<pre><code class="language-Python">print(f&quot;~{'a':1&gt;10}~&quot;)  # ~111111111a~
print(f&quot;~{'a':1^10}~&quot;)  # ~1111a11111~
# 使用空格填充，'a': &gt;10 等价于 'a':&gt;10
print(f&quot;~{'a': &gt;10}~&quot;)  # ~         a~

# 这里我们实现了 {1:03d} 的效果
print(f&quot;{1:0&gt;3}&quot;)  # 001

print(f&quot;{123:b}&quot;)  # 1111011
print(f&quot;{123:b&lt;}&quot;)  # 123
&quot;&quot;&quot;
对于 f&quot;{123:b}&quot;，里面的 b 表示整数的进制转换
此时只能作用于整数，不能是字符串

但是对于 f&quot;{123:b&lt;}，由于里面出现了&lt;
那么此时的 b 就不再代表进制了，而是代表填充字符

只不过 &lt; 后面没有指定个数
所以解释器不知道要填充多少个，因此就原本输出了
&quot;&quot;&quot;

# 但是 f&quot;{'aaa':b}&quot; 报错
# 因为此时 b 代表进制，无法作用于字符串
print(f&quot;{'aaa':b&lt;}&quot;)  # aaa
print(f&quot;{'aaa':b&lt;4}&quot;)  # aaab
</code></pre>
<p>问题来了，如果我们希望整数在填充的时候，还能进制转化，该怎么做呢？</p>
<pre><code class="language-Python"># 转成十六进制
print(f&quot;{255:x}&quot;)
&quot;&quot;&quot;
ff
&quot;&quot;&quot;
# 转成十六进制，带前缀
print(f&quot;{123:#x}&quot;)
&quot;&quot;&quot;
0x7b
&quot;&quot;&quot;
# 转成十六进制，占满10位
# 不够使用字符 s 来左填充
print(f&quot;{123:s&gt;#10x}&quot;)
&quot;&quot;&quot;
ssssss0x7b
&quot;&quot;&quot;
</code></pre>
<p>浮点数也是类似的，在保留指定位数的同时，也可以进行填充。</p>
<pre><code class="language-Python">num = 123.1234

# 保留一位小数
print(f&quot;{num:.1f}&quot;)
&quot;&quot;&quot;
123.1
&quot;&quot;&quot;

# 保留一位小数，同时占满 10 位，此时只能用 0 或 空格填充
print(f&quot;{num:10.1f}&quot;)
print(f&quot;{num:010.1f}&quot;)
&quot;&quot;&quot;
     123.1
00000123.1
&quot;&quot;&quot;

# 如果想使用其它字符填充
print(f&quot;{num:s&lt;10.1f}&quot;)
print(f&quot;{num:s&gt;10.1f}&quot;)
print(f&quot;{num:s^10.1f}&quot;)
&quot;&quot;&quot;
123.1sssss
sssss123.1
ss123.1sss
&quot;&quot;&quot;

# 填充的时候带上正负号
print(f&quot;{num:s&lt;+10.1f}&quot;)
print(f&quot;{num:s&gt;+10.1f}&quot;)
print(f&quot;{num:s^+10.1f}&quot;)
&quot;&quot;&quot;
+123.1ssss
ssss+123.1
ss+123.1ss
&quot;&quot;&quot;

# 填充的时候带上正负号和分隔符
num = 123123123.1234
print(f&quot;{num:s&lt;+20_.1f}&quot;)
print(f&quot;{num:s&gt;+20_.1f}&quot;)
print(f&quot;{num:s^+20_.1f}&quot;)
&quot;&quot;&quot;
+123_123_123.1ssssss
ssssss+123_123_123.1
sss+123_123_123.1sss
&quot;&quot;&quot;
</code></pre>
<p>总的来说，f-string 还是非常强大的，但说实话，工作中不会用到这么多花里胡哨的功能。基本上就是简单的填充、进制转换、保留小数。很少会有 <code>f&quot;{num:s&lt;+20_.1f}&quot;</code> 这种保留小数的同时，还要带正负号、以及填充位数的情况出现。</p>
<h2 id="日期的截取"><a class="header" href="#日期的截取">日期的截取</a></h2>
<p>很多小伙伴应该没想到 f-string 还可以操作日期，这也算是一大亮点吧。我们在格式化或者截取日期的时候，一般会使用 datetime 模块，这些也是可以使用 f-string 来实现的。</p>
<pre><code class="language-Python">import datetime

dt = datetime.datetime(
    1995, 7, 5, 13, 30, 45, 100000)
print(dt)
&quot;&quot;&quot;
1995-07-05 13:30:45.100000
&quot;&quot;&quot;

# %F: 返回年月日（使用 - 连接）
print(f&quot;{dt:%F}&quot;)
&quot;&quot;&quot;
1995-07-05
&quot;&quot;&quot;
# %D: 返回日月年（使用 / 连接），但是年是两位的
# 并且也不符合中国人的日期表达习惯，建议只用 %F
print(f&quot;{dt:%D}&quot;)
&quot;&quot;&quot;
07/05/95
&quot;&quot;&quot;

# %X: 返回时间，精确到秒（小数点后面的会截断）
# 这里注意的 X 要大写，如果是 %x 那么等价于 %D
print(f&quot;{dt:%X}&quot;)
&quot;&quot;&quot;
13:30:45
&quot;&quot;&quot;

# 所以返回字符串格式的完整日期就可以这么写
print(f&quot;{dt:%F %X}&quot;)
&quot;&quot;&quot;
1995-07-05 13:30:45
&quot;&quot;&quot;

# %Y: 返回年（四位）
# %y: 返回年（两位）
print(f&quot;{dt:%Y}&quot;)
print(f&quot;{dt:%y}&quot;)
&quot;&quot;&quot;
1995
95
&quot;&quot;&quot;

# %m: 返回月
# %d: 返回天
# 注意：会占满两位，不够补0
print(f&quot;{dt:%m}&quot;)
print(f&quot;{dt:%d}&quot;)
&quot;&quot;&quot;
07
05
&quot;&quot;&quot;

# 所以 %F，我们还可以这么实现，这些符号是可以连用的
print(f&quot;{dt:%Y-%m-%d}&quot;)
&quot;&quot;&quot;
1995-07-05
&quot;&quot;&quot;

# %H: 返回小时（24小时制度）
# %I: 返回小时（12小时制度）
# 注意：会占满两位，不够补0
print(f&quot;{dt:%H}&quot;)
print(f&quot;{dt:%I}&quot;)
&quot;&quot;&quot;
13
01
&quot;&quot;&quot;

# %M: 返回分钟
# %S: 返回秒
# 注意：会占满两位，不够补0
print(f&quot;{dt:%M}&quot;)
print(f&quot;{dt:%S}&quot;)
&quot;&quot;&quot;
30
45
&quot;&quot;&quot;

# 所以完整的 &quot;年-月-日 时:分:秒&quot;
# 就可以这么实现
print(f&quot;{dt:%Y-%m-%d %H:%M:%S}&quot;)
&quot;&quot;&quot;
1995-07-05 13:30:45
&quot;&quot;&quot;

# %f: 返回微妙
# 注意：会占满六位，不够补0
print(f&quot;{dt:%f}&quot;)
&quot;&quot;&quot;
100000
&quot;&quot;&quot;

# %p: 早上还是下午（本地时间）
# 早上返回 AM、下午返回 PM
print(f&quot;{dt:%p}&quot;)
&quot;&quot;&quot;
PM
&quot;&quot;&quot;

# %j: 一年中的第几天，从 1 开始，1月1号就是 1
# 注意：会占满三位，不够补 0
print(f&quot;{dt:%j}&quot;)
&quot;&quot;&quot;
186
&quot;&quot;&quot;

# %w: 星期几（0 是周日、1 到 6 是周一到周六）
# %u: 星期几（1 到 7 是周一到周日）
# 可以看到两种格式只有星期天不一样
print(f&quot;{dt:%w}&quot;)
print(f&quot;{dt:%u}&quot;)
&quot;&quot;&quot;
3
3
&quot;&quot;&quot;

# %U: 一年中的第几周（以全年首个周日所在的星期为第 0 周）
# %W: 一年中的第几周（以全年首个周一所在的星期为第 1 周）
# %V: 一年中的第几周（以全年首个包含 1 月 4 日的星期为第 1 周）
# 都是占满两位，不够补 0
print(f&quot;{dt:%U}&quot;)
print(f&quot;{dt:%W}&quot;)
print(f&quot;{dt:%V}&quot;)
&quot;&quot;&quot;
27
27
27
&quot;&quot;&quot;
# 所以如果对应的年的第一天恰好是星期一，那么 %U 会比 %W 少 1。
# 如果不是星期一，那么两者是相等的，比如 2007 年的 1 月 1 号恰好是星期一
dt = datetime.datetime(2007, 10, 13)
print(f&quot;{dt:%U}&quot;)
print(f&quot;{dt:%W}&quot;)
print(f&quot;{dt:%V}&quot;)
&quot;&quot;&quot;
40
41
41
&quot;&quot;&quot;

# %Z: 返回时区名，如果没有则返回空字符串
print(f&quot;'{dt:%Z}'&quot;)  # ''
from pytz import timezone
dt = datetime.datetime(2007, 10, 13, tzinfo=timezone(&quot;UTC&quot;))
print(f&quot;'{dt:%Z}'&quot;)  # 'UTC'
</code></pre>
<p>怎么样，是不是很方便呢？以后在做日期的格式化和解析的时候，不妨使用 f-string 试一下。</p>
<h2 id="f-string-的注意事项"><a class="header" href="#f-string-的注意事项">f-string 的注意事项</a></h2>
<p>使用 f-string 需要注意单双引号的问题，如果限定字符串使用的是双引号，那么 {} 里面出现的必须是单引号，反之亦然。</p>
<pre><code class="language-Python">d = {&quot;a&quot;: 1}
# 外面是双引号，{} 里面必须是单引号，不能是 d[&quot;a&quot;]
print(f&quot;{d['a'] + 1}&quot;)  # 2
</code></pre>
<p>我们限定字符串的时候使用的是双引号，{} 里面必须是单引号。可能有人好奇，如果里面仍使用双引号，但通过反斜杠 \ 进行转义的话会怎么样呢？答案是不行的，因为 f-string 的 {} 里面不可以出现 \。注意：{} 是不可以出现 \，一个都不可以，所以也不要再想是不是可以使用两个 \ 进行转义啥的。</p>
<pre><code class="language-Python">try:
    print(f&quot;{\\}&quot;)
except Exception as e:
    pass
# 我们即便使用异常捕获，也是无用的，依旧会抛出 SyntaxError
# 因为 try except 是捕捉运行时的错误
# 而 {} 里面出现反斜杠属于语法上的错误，在编译成字节码阶段就会检测出来
&quot;&quot;&quot;
    print(f&quot;{\\}&quot;)
          ^
SyntaxError: f-string expression part cannot include a backslash
&quot;&quot;&quot;
</code></pre>
<p>因此：使用 f-string 同样需要注意单双引号的问题，并且 {} 里面不可以出现反斜杠。如果真的需要反斜杠，那么可以将反斜杠赋值给一个变量，然后将变量传递到 {} 里面去。</p>
<pre><code class="language-Python">a = &quot;\\&quot;
print(f&quot;{a}&quot;)  # \
</code></pre>
<p>另外，使用 f-string 时一定要注意：<strong>{</strong> 和 <strong>}</strong> 的个数要匹配。</p>
<pre><code class="language-Python"># 如果不使用 f-string，没有任何问题
# 但是使用了f-string，那么会报错
# 因为里面出现了 { 但是却没有对应的 }
# 这段代码不会通过编译
print(f&quot;我永远喜欢{古明地觉&quot;)
&quot;&quot;&quot;
    print(f&quot;我永远喜欢{古明地觉&quot;)
          ^
SyntaxError: f-string: expecting '}'
&quot;&quot;&quot;
</code></pre>
<p>可能有人好奇了，如果我只是想单纯地输入 <strong>{</strong> 这个字符呢？答案是用两个 <strong>{</strong> 进行转义。</p>
<pre><code class="language-Python">print(f&quot;我永远喜欢{{古明地觉&quot;)
&quot;&quot;&quot;
我永远喜欢{古明地觉
&quot;&quot;&quot;

# } 也是同理，需要使用两个 }} 进行转义
print(f&quot;我永远喜欢古明地觉}}&quot;)
&quot;&quot;&quot;
我永远喜欢古明地觉}
&quot;&quot;&quot;

print(f&quot;我永远喜欢{{古明地觉}}&quot;)
&quot;&quot;&quot;
我永远喜欢{古明地觉}
&quot;&quot;&quot;
</code></pre>
<p>不过这就又产生了一个问题，如果我希望外面的 <strong>{}</strong> 表示限定符，里面的 <strong>{}</strong> 表示集合该怎么办？</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

# 打印的不是我们想要的结果
print(f&quot;{{name}}&quot;)
&quot;&quot;&quot;
{name}
&quot;&quot;&quot;

# 在内部的 {} 周围套上一层小括号即可
print(f&quot;{({name})}&quot;)
&quot;&quot;&quot;
{'古明地觉'}
&quot;&quot;&quot;

# 字典也是同理
print(f&quot;{{'name': name}}&quot;)
print(f&quot;{({'name': name})}&quot;)
&quot;&quot;&quot;
{'name': name}
{'name': '古明地觉'}
&quot;&quot;&quot;
</code></pre>
<p>还有字符串的拼接：</p>
<pre><code class="language-Python"># 等价于 &quot;你好世界&quot;
s = &quot;你好&quot; &quot;世界&quot;
print(s)  # 你好世界

name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;
# 每一部分都要带上 f
s = f&quot;{name}&quot; f&quot;{address}&quot;
print(s)  # 古明地觉,地灵殿

s = f&quot;{name}&quot; &quot;{address}&quot;
print(s)  # 古明地觉{address}

# 多行显示也是同理
s = (f&quot;{name}&quot;
     f&quot;{address}&quot;)
print(s)  # 古明地觉地灵殿
</code></pre>
<p>最后则是 lambda 表达式的问题。</p>
<pre><code class="language-Python"># 使用 lambda 表达式的时候一定要使用括号括起来
# 否则会将 lambda 中的 : 解释成表达式与格式描述符之间的分隔符
print(f&quot;{(lambda x: x + 123)(123)}&quot;)  # 246
</code></pre>
<h2 id="小结-1"><a class="header" href="#小结-1">小结</a></h2>
<p>个人觉得 f-string 算是 Python3.6 新增的一大亮点，虽然有着一些限制，但是这都不是什么问题，毕竟在做分词解析的时候肯定是有一些限制的，但总体来说 f-string 是非常强大的一个工具了。因此在格式化字符串的时候，推荐使用f-string，相信它一定可以在格式化字符串的时候给你提供很大的帮助。</p>
<p>对了，再补充一点，在 3.8 的时候给 f-string 增加了一个功能：</p>
<pre><code class="language-Python">num = 123

print(f&quot;{num=}&quot;)
print(f&quot;{num =}&quot;)
print(f&quot;{num = }&quot;)
&quot;&quot;&quot;
num=123
num =123
num = 123
&quot;&quot;&quot;
# 可以看到加上了 =，还会将 {} 里面的内容输出出来
# 像我们之前的例子
print(f&quot;sum([1, 2, 3]) = {sum([1, 2, 3])}&quot;)
&quot;&quot;&quot;
sum([1, 2, 3]) = 6
&quot;&quot;&quot;
# 加上 = 就会简洁很多
print(f&quot;{sum([1, 2, 3]) = }&quot;)
&quot;&quot;&quot;
sum([1, 2, 3]) = 6
&quot;&quot;&quot;

print(f&quot;{1 + 1 = }&quot;)
&quot;&quot;&quot;
1 + 1 = 2
&quot;&quot;&quot;

print(f&quot;{len('古明地觉') = }&quot;)
&quot;&quot;&quot;
len('古明地觉') = 4
&quot;&quot;&quot;
</code></pre>
<p>以上就是 f-string 相关的内容，这些用法你是不是都了如指掌呢？</p>
<div style="break-before: page; page-break-before: always;"></div><p>关于日期处理，Python 提供了很多的库，比如标准库 datetime、第三方库 dateutil、arrow 等等。这里介绍一个我个人最喜欢的库 pendulum，用起来可以说非常的方便，任何对日期的操作它都能满足。</p>
<p>在使用之前需要先安装，直接 pip install pendulum 即可。</p>
<p>下面来看一下用法，首先是 datetime, date, time 的创建。</p>
<pre><code class="language-python">import pendulum

dt = pendulum.datetime(
    2022, 3, 28, 20, 10, 30)
print(dt.__class__)
print(dt)
&quot;&quot;&quot;
&lt;class 'pendulum.datetime.DateTime'&gt;
2022-03-28T20:10:30+00:00
&quot;&quot;&quot;
# 创建的对象是 DateTime 类型，并且带有时区，默认是 UTC
# 我们可以换一个时区
dt = pendulum.datetime(2022, 3, 28, 20, 10, 30, tz=&quot;Asia/Shanghai&quot;)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30+08:00
&quot;&quot;&quot;

# 如果不想要时区，那么指定 tz=None
dt = pendulum.datetime(2022, 3, 28, 20, 10, 30, tz=None)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30
&quot;&quot;&quot;

# 然后是 date 的创建
d = pendulum.date(2022, 3, 28)
print(d.__class__)
print(d)
&quot;&quot;&quot;
&lt;class 'pendulum.date.Date'&gt;
2022-03-28
&quot;&quot;&quot;

# time 的创建
t = pendulum.time(20, 10, 30)
print(t.__class__)
print(t)
&quot;&quot;&quot;
&lt;class 'pendulum.time.Time'&gt;
20:10:30
&quot;&quot;&quot;
</code></pre>
<p>创建 datetime 时，时区默认是 UTC。如果不想要时区，或者希望时区是本地时区，那么 pendulum 还专门提供了两个方法。</p>
<pre><code class="language-Python">import pendulum

# 创建 datetime 时设置为本地时区
# 还是调用了 pendulum.datetime 函数
# 但是 tz 被设置成了 pendulum.local_timezone()
dt = pendulum.local(2022, 3, 28, 20, 10, 30)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30+08:00
&quot;&quot;&quot;
print(pendulum.local_timezone())
&quot;&quot;&quot;
Timezone('Asia/Shanghai')
&quot;&quot;&quot;

# 创建 datetime 时不设置时区
# 内部也是调用了 pendulum.datetime 函数
# 但是 tz 为 None
dt = pendulum.naive(2022, 3, 28, 20, 10, 30)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30
&quot;&quot;&quot;
</code></pre>
<p>然后 pendulum 还提供了几个方法，比如创建当前的 datetime，date 等等。</p>
<pre><code class="language-Python">import pendulum

# 创建当前的 datetime，默认是本地时区，但时区可以指定
dt = pendulum.now()
print(dt)
&quot;&quot;&quot;
2022-05-29T20:40:49.632182+08:00
&quot;&quot;&quot;

# 创建当前的 date，但返回的仍是 datetime
# 只不过时分秒均为 0，同样可以指定时区
dt = pendulum.today()
print(dt)
&quot;&quot;&quot;
2022-05-29T00:00:00+08:00
&quot;&quot;&quot;

# 获取明天对应的 date，返回的是 datetime，时分秒为 0
# 时区可以指定，默认是本地时区
dt = pendulum.tomorrow()
print(dt)
&quot;&quot;&quot;
2022-05-30T00:00:00+08:00
&quot;&quot;&quot;

# 获取昨天对应的 date
dt = pendulum.yesterday()
print(dt)
&quot;&quot;&quot;
2022-05-28T00:00:00+08:00
&quot;&quot;&quot;
</code></pre>
<p>我们还可以根据时间戳或者字符串来创建：</p>
<pre><code class="language-Python">import pendulum

# 根据时间戳创建
dt1 = pendulum.from_timestamp(1653828466)
dt2 = pendulum.from_timestamp(1653828466, tz=pendulum.local_timezone())
print(dt1)
print(dt2)
&quot;&quot;&quot;
2022-05-29T12:47:46+00:00
2022-05-29T20:47:46+08:00
&quot;&quot;&quot;

# 根据字符串创建
dt1 = pendulum.parse(&quot;2020-05-03 12:11:33&quot;)
dt2 = pendulum.parse(&quot;2020-05-03 12:11:33&quot;, tz=pendulum.local_timezone())
print(dt1)
print(dt2)
&quot;&quot;&quot;
2020-05-03T12:11:33+00:00
2020-05-03T12:11:33+08:00
&quot;&quot;&quot;
</code></pre>
<p>datetime、date、time 的创建我们说完了，然后再来看看它们支持的操作，这也是最核心的部分。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 28, 20, 10, 30)

# 获取 date 部分和 time 部分
print(dt.date())
print(dt.time())
&quot;&quot;&quot;
2022-03-28
20:10:30
&quot;&quot;&quot;

# 替换掉 dt 的某部分，返回新的 datetime
# 年月日时分秒、以及时区都可以替换
print(dt.replace(year=9999))
&quot;&quot;&quot;
9999-03-28T20:10:30+08:00
&quot;&quot;&quot;

# 转成时间戳
print(dt.timestamp())
&quot;&quot;&quot;
1648469430.0
&quot;&quot;&quot;

# 返回年、月、日、时、分、秒、时区
print(dt.year, dt.month, dt.day)
print(dt.hour, dt.minute, dt.second)
print(dt.tz)
&quot;&quot;&quot;
2022 3 28
20 10 30
Timezone('Asia/Shanghai')
&quot;&quot;&quot;
</code></pre>
<p>然后是生成字符串，pendulum.DateTime 对象可以转成各种格式的日期字符串。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 28, 20, 10, 30)

# 下面四个最为常用
print(&quot;datetime:&quot;, dt.to_datetime_string())
print(&quot;date:&quot;, dt.to_date_string())
print(&quot;time:&quot;, dt.to_time_string())
print(&quot;iso8601:&quot;, dt.to_iso8601_string())
&quot;&quot;&quot;
datetime: 2022-03-28 20:10:30
date: 2022-03-28
time: 20:10:30
iso8601: 2022-03-28T20:10:30+08:00
&quot;&quot;&quot;
# 当然还支持很多其它格式，不过用的不多，随便挑几个吧
print(&quot;atom:&quot;, dt.to_atom_string())
print(&quot;rss:&quot;, dt.to_rss_string())
print(&quot;w3c:&quot;, dt.to_w3c_string())
print(&quot;cookie:&quot;, dt.to_cookie_string())
print(&quot;rfc822:&quot;, dt.to_rfc822_string())
&quot;&quot;&quot;
atom: 2022-03-28T20:10:30+08:00
rss: Mon, 28 Mar 2022 20:10:30 +0800
w3c: 2022-03-28T20:10:30+08:00
rfc822: Mon, 28 Mar 22 20:10:30 +0800
&quot;&quot;&quot;
</code></pre>
<p>我们有时也需要判断当前日期是星期几、在当前这一年是第几天等等，pendulum 也已经帮我们封装好了。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 28, 20, 10, 30)

# 返回星期几
# 注意：星期一到星期天分别对应 1 到 7
print(dt.isoweekday())  # 1

# 返回一年当中的第几天
# 范围是 1 到 366
print(dt.day_of_year)  # 87

# 返回一个月当中的第几天
print(dt.days_in_month)  # 31

# 返回一个月当中的第几周
print(dt.week_of_month)  # 5

# 返回一年当中的第几周
print(dt.week_of_year)  # 13

# 是否是闰年
print(dt.is_leap_year())  # False
</code></pre>
<p>最后就是日期的运算，这是 pendulum 最为强大的地方，至于为什么强大，我们演示一下就知道了。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 30, 20, 10, 30)

# 返回下一个月的今天
print(dt.add(months=1))
&quot;&quot;&quot;
2022-04-30T20:10:30+08:00
&quot;&quot;&quot;

# 返回上一个月的今天
# 但是上一个月是 2 月，并且是平年，所以最多 28 天
print(dt.add(months=-1))
&quot;&quot;&quot;
2022-02-28T20:10:30+08:00
&quot;&quot;&quot;
# 我们看到处理的非常完美
# 该方法的原型如下，年月日时分秒都是支持的，当然还有星期也支持
&quot;&quot;&quot;
def add(
    self,
    years=0,
    months=0,
    weeks=0,
    days=0,
    hours=0,
    minutes=0,
    seconds=0,
    microseconds=0,
):
&quot;&quot;&quot;
</code></pre>
<p>像 Python 的内置模块 datetime 在将日期相加的时候，最多支持到天，我们无法计算下一周、下一个月、下一年的日期。而 pendulum 则可以很方便地处理，这也是我最喜欢的一点。当然啦，add 里面的值为正，相当于日期往后退；值为负，相当于日期往前推。</p>
<p>然后是两个日期还可以做减法：</p>
<pre><code class="language-Python">import pendulum

dt1 = pendulum.local(2021, 1, 20, 11, 22, 33)

dt2 = pendulum.local(2022, 3, 30, 20, 10, 30)

period = dt2 - dt1
# 返回的是 Period 对象，相当于 datetime 模块里面的 timedelta
print(period.__class__)
&quot;&quot;&quot;
&lt;class 'pendulum.period.Period'&gt;
&quot;&quot;&quot;

# 但是功能方面，Period 要强大很多
# 两者差了多少年
print(period.in_years())  # 1
# 两者差了多少个月
print(period.in_months())  # 14
# 两者差了多少个星期
print(period.in_weeks())  # 62
# 两者差了多少天
print(period.in_days())  # 434
# 两者差了多少个小时
print(period.in_hours())  # 10424
# 两者差了多少分钟
print(period.in_minutes())  # 625487
# 两者差了多少秒
print(period.in_seconds())  # 37529277
</code></pre>
<p>功能非常强大，Python 的 datetime 模块里面的 timedelta 最多只能计算两个日期差了多少天，而这里年月日时分秒均可。</p>
<p>以上就是本文的内容，当然 pendulum 的功能其实不止我们上面说的那些，有兴趣的话可以参考官网，但常用的差不多就这些东西。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-2"><a class="header" href="#楔子-2">楔子</a></h2>
<p>导入一个模块，我们一般都会使用 import 关键字，但有些场景下 import 难以满足我们的需要。所以除了 import 之外还有很多其它导入模块的方式，下面就来介绍一下。</p>
<h2 id="__import__"><a class="header" href="#__import__">__import__</a></h2>
<p>这是一个内置函数，解释器在 import 的时候，实际上就执行了这个函数。</p>
<pre><code class="language-python"># import os 等价于如下方式
os = __import__(&quot;os&quot;)
print(os)  # &lt;module 'os' from 'C:\\python38\\lib\\os.py'&gt;

# 但是这种方式不能多级导入
path = __import__(&quot;os.path&quot;)
print(path)  # &lt;module 'os' from 'C:\\python38\\lib\\os.py'&gt;
# 可以看到，导入的仍是 os，而不是 os.path

# 如果想导入子模块，需要一个参数 fromlist
# 我们给它传一个非空列表即可
path = __import__(&quot;os.path&quot;, fromlist=[&quot;&quot;])
print(path)  # &lt;module 'ntpath' from 'C:\\python38\\lib\\ntpath.py'&gt;
</code></pre>
<p>但是官方不建议使用这个函数，因为它是专门给解释器用的，我们可以使用一个模块。</p>
<pre><code class="language-Python">import importlib

os = importlib.import_module(&quot;os&quot;)
print(os)  # &lt;module 'os' from 'C:\\python38\\lib\\os.py'&gt;

# 可以多级导入
path = importlib.import_module(&quot;os.path&quot;)
print(path)  # &lt;module 'ntpath' from 'C:\\python38\\lib\\ntpath.py'&gt;
</code></pre>
<p>所以当导入的模块名以字符串的形式存在时，就可以使用这种方式。</p>
<h2 id="importlibmachinery"><a class="header" href="#importlibmachinery">importlib.machinery</a></h2>
<p>importlib.machinery 里面提供了三种 Loader，可以让我们以打开文件的方式导入一个模块。</p>
<pre><code class="language-Python">from importlib.machinery import (
    SourceFileLoader,  # 导入源文件
    SourcelessFileLoader,  # 导入 pyc 文件
    ExtensionFileLoader  # 导入扩展文件
)

# 参数一：给模块起个名字
# 参数二：文件路径
os = SourceFileLoader(
    &quot;我是 os 模块&quot;,
    r&quot;C:\python38\lib\os.py&quot;
).load_module()
print(os)
&quot;&quot;&quot;
&lt;module '我是 os 模块' from 'C:\\python38\\lib\\os.py'&gt;
&quot;&quot;&quot;
print(os.path.join(&quot;video&quot;, &quot;overwatch&quot;, &quot;hanzo.mp4&quot;))
&quot;&quot;&quot;
video\overwatch\hanzo.mp4
&quot;&quot;&quot;

# 我们看到结果一切正常，但有一点需要注意
# 如果是导入包的话，那么要导入包里面的 __init__.py 文件
pd = SourceFileLoader(
    &quot;我是 pandas 模块&quot;,
    r&quot;C:\python38\lib\site-packages\pandas\__init__.py&quot;
).load_module()
print(pd.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [4, 5, 6]}))
&quot;&quot;&quot;
   a  b
0  1  4
1  2  5
2  3  6
&quot;&quot;&quot;

# 如果只写到 pandas，那么会抛出 PermissionError，因为不能把目录当成文件来读取
# 至于 import 一个包，本质上也是加载包内部的 __init__.py 
# 但这里需要显式地加上 __init__.py
</code></pre>
<p>同理加载 pyc 和 pyd 也是类似的，但需要注意的是，加载普通文件和 pyc 文件时，我们可以随便起名字，也就是第一个参数任意。但对于 pyd 文件，第一个参数必须和 pyd 文件的名字保持一致。</p>
<h2 id="通过-module-类创建模块"><a class="header" href="#通过-module-类创建模块">通过 module 类创建模块</a></h2>
<p>Python 一切皆对象，模块自然也不例外。既然是对象，那么必然就会有相应的类来实例化它。</p>
<pre><code class="language-Python">import os
import hashlib
import numpy

# os.__class__ 等价于 type(os)
print(os.__class__)  # &lt;class 'module'&gt;
print(hashlib.__class__)  # &lt;class 'module'&gt;
print(numpy.__class__)  # &lt;class 'module'&gt;
</code></pre>
<p>在 Python 里面，我们一般会把单独的可导入文件称之为<strong>模块</strong>，把包含多个模块的目录称之为<strong>包</strong>。通过模块和包，我们可以对项目进行功能上的划分，分门别类地进行组织。但不管是模块、还是包，它们都是 module 这个类的实例对象，打印结果也能说明这一点。所以从解释器的角度来看的话，模块和包区分的并没有那么明显，直接把包看做是包内部的 __init__.py 即可。</p>
<p>既然模块的类型是 &lt;class 'module'&gt;，那么我们是不是也可以通过调用类型对象的方式创建呢？显然是可以的，但是 module 这个类解释器没有暴露给我们，直接用的话会提示<strong>变量 module 未定义</strong>。所以只能先随便导入一个模块，然后通过 type 函数或者 __class__ 属性获取。</p>
<pre><code class="language-python"># 当然 types 模块内部已经帮我们做好了
# ModuleType = type(sys)
from types import ModuleType

print(ModuleType)  # &lt;class 'module'&gt;

# 类对象有了，下面就可以创建了
# module 类接收两个参数
# 参数一：模块的名字，必须传递
# 参数二：模块的 doc，不传默认为 None
satori = ModuleType(&quot;古明地觉&quot;, &quot;模块的名字是一个女孩，她来自地灵殿&quot;)
print(satori)  # &lt;module '古明地觉'&gt;
print(satori.__doc__)  # 模块的名字是一个女孩，她来自地灵殿


# 但此时模块里面是没啥东西的，我们加一些属性吧
# 操作模块本质上是在操作它的属性字典
code = &quot;&quot;&quot;
age = 16

def foo():
    return &quot;^_^&quot;
&quot;&quot;&quot;
# 执行 code，结果会体现在 satori 的属性字典中
exec(code, satori.__dict__)
print(satori.age)  # 16
print(satori.foo())  # ^_^
</code></pre>
<p>需要注意的是里面 exec 函数，它会把字符串当成代码来执行，所以这就要求字符串的来源必须是可靠的，我们能够确保不会出现恶意内容。而如果是用户传递的字符串，那么绝不能用 exec 来执行，当然 eval 也是同理。</p>
<p>然后是 exec 的第二个参数，表示执行时的名字空间，默认是全局名字空间。所以当不指定第二个参数时，exec(code) 相当于创建了两个全局变量：age 和 foo。</p>
<pre><code class="language-Python">code = &quot;&quot;&quot;
age = 16

def foo():
    return &quot;^_^&quot;
&quot;&quot;&quot;

exec(code)
print(age)  # 16
print(foo())  # ^_^
</code></pre>
<p>但是我们在执行的时候，将它换成了 satori.__dict__，所以结果相当于给模块添加了两个变量，或者说属性。</p>
<h2 id="将一个类的实例变成一个模块"><a class="header" href="#将一个类的实例变成一个模块">将一个类的实例变成一个模块</a></h2>
<p>如果想将一个类的实例变成模块，那么这个类应该继承 ModuleType。</p>
<pre><code class="language-python">import sys
from types import ModuleType


class A(ModuleType):

    def __init__(self, module_name):
        super().__init__(module_name)

    def __getattr__(self, item):
        return f&quot;不存在的属性: {item}&quot;

    def __setattr__(self, key, value):
        self.__dict__[key] = value

    def __str__(self):
        return f&quot;&lt;module '{self.__name__}' from '我来自于虚无'&gt;&quot;


a = A(&quot;我是 A&quot;)
print(a)  # &lt;module '我是 A' from '我来自于虚无'&gt;
print(a.__name__)  # 我是 A
print(a.xx)  # 不存在的属性: xx
a.xx = &quot;xx&quot;
print(a.xx)  # xx

# 加入到 sys.modules 中
sys.modules[&quot;嘿嘿&quot;] = a
import 嘿嘿
print(嘿嘿.xx)  # xx
print(嘿嘿.yy)  # 不存在的属性: yy
</code></pre>
<p>是不是很好玩呢？</p>
<h2 id="小结-2"><a class="header" href="#小结-2">小结</a></h2>
<p>以上就是加载模块的几种方式，主要用途如下：</p>
<ul>
<li>导入一个在 sys.path 中的模块，并且模块名已知，那么直接使用 import 关键字即可；</li>
<li>导入一个在 sys.path 中的模块，但模块名是运行时的一个字符串，那么使用 importlib 模块的 import_module 函数；</li>
<li>导入一个不在 sys.path 中的模块，使用 importlib.machinery 的各种 Loader，只要把模块的路径传进去即可。当然啦，位于 sys.path 中的模块也可以使用该方法，但显然此时使用前两种更为方便；</li>
<li>直接创建一个模块，通过继承 module 类来实现，并且还可以加入到 sys.modules 中。Python 有一个第三方模块叫 sh，顾名思义是用来执行 Linux Shell 命令的，它内部就使用了继承 module 类来创建模块的这种方式。但是要知道 module 这个类解释器没有暴露给我们，我们需要通过 type(模块) 或者 模块.__class__ 的方式获取；</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>如果想主动退出 Python 程序，那么可以使用 exit, quit, sys.exit, os._exit 这四个函数，而这些函数之间有什么区别呢？</p>
<p>首先来说前三个，exit, quit, sys.exit 退出程序的原理是一样的，只不过 exit 和 quit 用在交互式环境中，sys.exit 用在非交互式环境中。当然啦，无论是交互式还是非交互式，这三个函数都是适用的。至于这个三个函数所做的事情，实际上就是 raise 一个 SystemExit 异常。如果没有捕获这个异常，那么程序就会退出。</p>
<pre><code class="language-python">import sys
sys.exit(100)
print(&quot;程序退出，这里不会打印&quot;)
</code></pre>
<p>当执行 sys.exit 的时候，会抛出 SystemExit，这里我们没有捕获它，所以程序会退出。并且函数接收一个整数，表示程序退出时的状态码。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./1.png" alt="" /></p>
<p>这里我用的 Cursor，结尾会显示程序退出时的状态码，可以看到结果是我们设置的 100。一般来说，如果程序正常退出，那么状态码为 0；程序执行出错，状态码为 1。当然啦，如果是解释器执行时内部出问题了，那么会抛出一个乱七八糟的状态码，不过这种情况基本只有在写 C 扩展的时候才会遇到。。</p>
<p>我们说 quit, exit, sys.exit 都可以接收一个整数，表示退出时的状态码。但如果接收的不是整数，那么会将参数作为打印信息输出到 stderr（标准错误输出）中，然后退出程序，并且状态码为 1。</p>
<pre><code class="language-Python">import sys
sys.exit(&quot;我退出啦&quot;)
</code></pre>
<p>执行一下看看。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./2.png" alt="" /></p>
<p>这三个函数的工作原理是 raise 一个 SystemExit 异常，那如果将其捕获了，程序是不是就不退出了，答案是肯定的。</p>
<pre><code class="language-Python">import sys

try:
    sys.exit(100)
except SystemExit:
    print(&quot;程序想要退出，但被捕获了&quot;)
print(&quot;正常打印&quot;)
</code></pre>
<p>执行一下，看看结果。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./3.png" alt="" /></p>
<p>结果确实如我们所料，将 sys.exit 引发的异常捕获掉之后，程序正常执行。所以最后状态码是 0，因为程序是正常结束的。那么问题来了，我们能不能手动抛一个 SystemExit 呢？</p>
<pre><code class="language-Python">print(&quot;我要抛异常了&quot;)
raise SystemExit(233)
print(&quot;此处不会执行&quot;)
</code></pre>
<p>SystemExit 里面也可以接收一个整数，会作为状态码返回；如果接收的不是整数，那么会将参数作为打印信息输出到 stderr 当中，并且状态码为 1。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./4.png" alt="" /></p>
<p>和 sys.exit 的表现是一样的，因为 sys.exit 本质上就是 raise 一个 SystemExit。并且我们看到在 raise SystemExit 的时候，并没有出现异常回溯栈，或者说没有看到 Traceback (most recent call last): 这样的字眼。所以说 SystemExit 是不像异常的异常，因为没有任何的错误信息出现。并且注意：SystemExit 继承自 BaseException，不是 Exception。</p>
<p>因此结论很清晰了，sys.exit 是通过引发 SystemExit 异常来退出程序的，我们可以捕获此异常做一些清理工作，甚至可以阻挠程序退出。当然，quit 和 exit 这两个内置函数也是同样的工作原理，只不过它们一般用在交互式环境中，但非交互式环境也能用。</p>
<pre><code class="language-python">try:
    exit(&quot;我想退出&quot;)
except SystemExit:
    print(&quot;exit，别做梦了&quot;)

try:
    quit(&quot;我想退出&quot;)
except SystemExit:
    print(&quot;quit，别做梦了&quot;)

exit(&quot;这下我真的退出了&quot;)
</code></pre>
<p>前面三个退出函数我们就说完了，再来看看最后一个，也就是 os._exit。它就比较厉害了，在底层会调用 C 语言的 exit 函数，相当于强制退出。</p>
<pre><code class="language-Python">import os

try:
    os._exit(233)
except Exception:
    print(&quot;会打印吗&quot;)
print(&quot;会打印吗&quot;)
</code></pre>
<p>下面的 print 会打印吗？执行一下看看。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./5.png" alt="" /></p>
<p>并没有执行，因此 os._exit 属于强制退出，无法被阻止。因此它一般用于子进程的退出，我们在主进程中退出的话一般使用 sys.exit。</p>
<p>最后 os._exit 还有一个不同的地方，就是它必须接收一个整数作为退出时的状态码，否则报错。</p>
<pre><code class="language-python">import os

try:
    os._exit(&quot;xx&quot;)
except TypeError as e:
    print(e)
print(&quot;正常执行&quot;)
&quot;&quot;&quot;
an integer is required (got type str)
正常执行
&quot;&quot;&quot;
</code></pre>
<p>此时程序是可以正常执行下去的，因为 os._exit 接收的参数类型不对，导致该函数并没有执行，而是直接抛出了 TypeError。</p>
<p>以上就是这几个退出函数之间的区别。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-3"><a class="header" href="#楔子-3">楔子</a></h2>
<p>文件处理是程序开发中经常会遇到的一个问题，比如文件是否存在，是否可读、可写、可执行，查看文件的状态，文件的读写操作等等。</p>
<p>本篇文章将会介绍一些最佳实践，让你在处理文件的时候更加得心应手。另外我们知道 Linux 一切皆文件，大致有以下七种。</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./1.png" alt="" /></p>
<p>而本篇文章所说的文件并不单单指普通文件，而是指所有类型的文件。</p>
<h2 id="文件是否存在是否可读可写可执行"><a class="header" href="#文件是否存在是否可读可写可执行">文件是否存在、是否可读可写可执行</a></h2>
<p>针对这个需求，我推荐使用 os.access 函数。使用该函数一般传递两个参数即可，参数一是文件路径，参数二是模式，而模式有以下四种：</p>
<ul>
<li>os.F_OK：判断文件是否存在；</li>
<li>os.R_OK：判断文件是否可读；</li>
<li>os.W_OK：判断文件是否可写；</li>
<li>os.X_OK：判断文件是否可执行；</li>
</ul>
<p>我们测试一下：</p>
<pre><code class="language-python">import os

# 文件是否存在
os.access(&quot;main.c&quot;, os.F_OK)
# 文件是否可读
os.access(&quot;main.c&quot;, os.R_OK)
# 文件是否可写
os.access(&quot;main.c&quot;, os.W_OK)
# 文件是否可执行
os.access(&quot;main.c&quot;, os.X_OK)

# 返回的都是布尔值
</code></pre>
<p>可读、可写、可执行在工作中遇到的不是很多，更多的还是判断是否存在。</p>
<h2 id="文件的状态"><a class="header" href="#文件的状态">文件的状态</a></h2>
<p>文件的状态一般包含以下几种：</p>
<ul>
<li>文件的类型，比如普通文件、目录文件等等；</li>
<li>文件的访问权限；</li>
<li>文件的最后访问时间、修改时间等等；</li>
<li>文件的大小（普通文件）；</li>
</ul>
<p>在 Python 里面要如何获取文件状态呢？实际上获取文件状态都是通过系统调用来完成的，而 os.stat 函数可以帮我们实现这一点。</p>
<pre><code class="language-Python">import os

# 接收一个路径，或者文件描述符
stat = os.stat(&quot;main.c&quot;)
# 返回一个 os.stat_result 对象
print(stat)
&quot;&quot;&quot;
os.stat_result(
st_mode=33206, st_ino=37999121855938744, 
st_dev=2993193685, st_nlink=1, st_uid=0, 
st_gid=0, st_size=3375, st_atime=1652539604, 
st_mtime=1652539604, st_ctime=1652537628)
&quot;&quot;&quot;
print(stat.st_mode)
print(stat.st_ino)
print(stat.st_dev)
print(stat.st_nlink)
print(stat.st_uid)
print(stat.st_gid)
print(stat.st_size)
print(stat.st_atime)
print(stat.st_mtime)
print(stat.st_ctime)
</code></pre>
<p>里面的字段包含了文件的全部信息，我们来介绍常用的。</p>
<h3 id="st_mode"><a class="header" href="#st_mode">st_mode</a></h3>
<p>我们先在 CentOS 上使用 ll 命令查看某个文件，观察它的输出信息：</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./2.png" alt="" /></p>
<p>注意红色框框里面的部分，总共十个字符，首先是第一个字符，表示文件类型。<strong>-</strong> 代表普通文件，<strong>d</strong> 代表目录文件，<strong>b</strong> 代表块设备文件，<strong>c</strong> 代表字符设备文件，<strong>p</strong> 代表管道文件，<strong>l</strong> 代表链接文件。显然这里是普通文件。</p>
<p>然后是剩余的九个字符，分为三组，分别代表 文件所有者、文件所属组、其它用户 的操作权限，顺序都是 rwx，即是否可读、可写、可执行。如果显示的是 <strong>-</strong>，那么代表不具备相应的权限；如果显示的是具体的字符，那么代表具备相应的权限。</p>
<p>比如 main.c 的文件所有者具备对 main.c 的可读可写权限，而其它用户则只有可读权限。好了，前置知识介绍完毕，下面看 st_mode。</p>
<pre><code class="language-Python">import os

stat = os.stat(&quot;main.c&quot;)
print(
    bin(stat.st_mode)
)  # 0b1000000110100100
</code></pre>
<p>需要转成二进制观察，我们先看后九位，110_100_100，分别对应 文件所有者、文件所属组、其它用户 的操作权限。每三位对应的都是 rwx，为 1 表示具有相关权限，为 0 表示不具有，所以它们都具有可读权限，没有可执行权限。</p>
<ul>
<li>100：具备可读权限，转成十进制（八进制）结果为 4；</li>
<li>010：具备可写权限，转成十进制（八进制）结果为 2；</li>
<li>001：具备可执行权限，转成十进制（八进制）结果为 1；</li>
<li>110：具备可读可写权限，转成十进制（八进制）结果为 6；</li>
<li>011：具备可写可执行权限，转成十进制（八进制）结果为 3；</li>
<li>101：具备可读可执行权限，转成十进制（八进制）结果为 5；</li>
<li>111：具备可读可写可执行权限，转成十进制（八进制）结果为 7；</li>
</ul>
<pre><code class="language-python">import os

stat = os.stat(&quot;main.c&quot;)
# 右移 6 位，然后和 0b111 做按位与
# 可以计算出文件所有者的权限
print(stat.st_mode &gt;&gt; 6 &amp; 0b111)  # 6
# 右移 3 位，然后和 0b111 做按位与
# 可以计算出文件所属组的权限
print(stat.st_mode &gt;&gt; 3 &amp; 0b111)  # 4
# 计算其它用户的权限
print(stat.st_mode &amp; 0b111)  # 4
</code></pre>
<p>当然了，这种情况更建议使用 os.access 进行判断，会更方便一些。</p>
<p>好，后九位我们看完了，它代表的是三个权限。而前面的位，也就是 st_mode 右移 9 位之后的结果，则代表文件的类型。</p>
<pre><code class="language-Python">import os
import stat

st_mode = os.stat(&quot;main.c&quot;).st_mode
# 是否是普通文件
# 如果是返回非 0，否则返回 0
print(st_mode &amp; stat.S_IFREG)  # 32768
# 不过上面的方式比较麻烦
# stat 模块已经帮我们封装好了相应的函数
print(stat.S_ISREG(st_mode))  # True
# 是否是目录文件
print(stat.S_ISDIR(st_mode))  # False
# 是否是块设备
print(stat.S_ISBLK(st_mode))  # False
# 是否是字符设备文件
print(stat.S_ISCHR(st_mode))  # False
# 是否是套接字文件
print(stat.S_ISSOCK(st_mode))  # False
# 是否是管道文件
print(stat.S_ISFIFO(st_mode))  # False
# 是否是链接文件
print(stat.S_ISLNK(st_mode))  # False
</code></pre>
<h3 id="st_uid-和-st_gid"><a class="header" href="#st_uid-和-st_gid">st_uid 和 st_gid</a></h3>
<p>文件所有者和所属组的 id，这个在 Windows 上一般都是 0，无需太关注。</p>
<h3 id="st_size"><a class="header" href="#st_size">st_size</a></h3>
<p>文件的大小，这个也是比较常用的。每个文件有多大，操作系统帮我们记录好了，直接获取即可。</p>
<pre><code class="language-Python">import os

stat = os.stat(r&quot;main.c&quot;)
print(stat.st_size)  # 35
</code></pre>
<h3 id="st_atimest_mtimest_ctime"><a class="header" href="#st_atimest_mtimest_ctime">st_atime、st_mtime、st_ctime</a></h3>
<p>分别表示访问时间、修改时间、创建时间，都是时间戳。</p>
<h2 id="如何设置文件的缓冲区"><a class="header" href="#如何设置文件的缓冲区">如何设置文件的缓冲区</a></h2>
<p>像磁盘、网卡之类的硬件设备只有操作系统的内核才有权限操作，我们开发的应用程序是没有权限的。于是操作系统把对磁盘、网卡之类的硬件相关的操作封装成了一个个的系统调用，应用程序通过这些系统调用便可借助内核来操作硬件设备。</p>
<p>而将内存中的数据写入到磁盘也不例外，它也会触发相应的系统调用，而系统调用的 I/O 是比较耗时的。还有磁盘，磁盘属于块设备，它写入数据时，不是以字节为单位、而是以块为单位写入的。假设一个块是 4096 个字节，那么写 1 个字节和写 4096 个字节耗时是一样的。</p>
<p>所以在写入数据的时候，不能来一个字节就触发一次系统调用，而是应该有一个缓冲区，这个缓冲区和块大小是一致的。当缓冲区满了，那么再一次性写入，这样能够提高效率。</p>
<p>在 Python 里面，缓冲区的大小是多大呢？又要如何设置呢？</p>
<pre><code class="language-Python"># 以二进制模式打开
f = open(&quot;main.c&quot;, &quot;wb&quot;)
</code></pre>
<p>首先解释器会从内核中读取磁盘的块大小，然后让缓冲区大小和磁盘的块大小保持一致。要是找不到磁盘的块大小（基本都能找到），则使用 io.DEFAULT_BUFFER_SIZE，这个值等于 8192。</p>
<p>一般来说，磁盘的块大小都是可以读出来的，大小为 4096。假设已经写了 4096 个字节，此时缓冲区已满，那么当写入第 4097 个字节时，缓冲区的 4096 个字节就会刷到磁盘上。然后写入的第 4097 个字节，就会成为缓冲区里面的第一个字节，这种模式也被称为<strong>全缓冲</strong>。</p>
<p>如果以二进制模式打开，缓冲区就是当前描述的这样，但如果是以文本模式打开呢？</p>
<pre><code class="language-Python">binary_write = open(&quot;main.c&quot;, &quot;wb&quot;)
print(binary_write)
&quot;&quot;&quot;
&lt;_io.BufferedWriter name='main.c'&gt;
&quot;&quot;&quot;

text_write = open(&quot;main.c&quot;, &quot;w&quot;)
print(text_write)
print(text_write.buffer)
&quot;&quot;&quot;
&lt;_io.TextIOWrapper name='main.c' mode='w' encoding='cp936'&gt;
&lt;_io.BufferedWriter name='main.c'&gt;
&quot;&quot;&quot;

binary_read = open(&quot;main.c&quot;, &quot;rb&quot;)
print(binary_read)
&quot;&quot;&quot;
&lt;_io.BufferedReader name='main.c'&gt;
&quot;&quot;&quot;

text_read = open(&quot;main.c&quot;, &quot;r&quot;)
print(text_read)
print(text_read.buffer)
&quot;&quot;&quot;
&lt;_io.TextIOWrapper name='main.c' mode='r' encoding='cp936'&gt;
&lt;_io.BufferedReader name='main.c'&gt;
&quot;&quot;&quot;
</code></pre>
<ul>
<li>如果以二进制模式写入（wb），那么文件句柄的类型为 BufferedWriter；以文本模式写入（w），那么文件句柄的类型为 TextIOWrapper；</li>
<li>如果以二进制模式读取（rb），那么文件句柄的类型为 BufferedReader；以文本模式读取（r），那么文件句柄的类型仍为 TextIOWrapper；</li>
</ul>
<p>但是需要注意 TextIOWrapper 有一个属性叫 buffer，对应的正是以二进制模式打开时的文件句柄。所以文本模式打开（包含读取和写入），实际上还是基于二进制打开进行的一层封装。</p>
<pre><code class="language-Python">f = open(&quot;main.c&quot;, &quot;w&quot;)
# 可以通过如下方式写入
f.write(&quot;abc&quot;)
# 也可以使用如下方式写入
f.buffer.write(b&quot;abc&quot;)
</code></pre>
<p>而 TextIOWrapper 这一层也是有缓冲区的，它的大小一般是 8192 个字节。如果缓冲区满了，再写入 BufferedWriter 的缓冲区，BufferWriter 的缓冲区满了，再写入到磁盘。所以从这个角度看，二进制模式打开比文本模式打开要更快一些，因为计算机存储的数据就是二进制格式的。</p>
<p>另外我们说 TextIOWrapper 是基于 BufferedWriter（读取的话是 BufferedReader，这里以写入为例）进行的封装，但其实 BufferedWriter 下面还有一层，叫 raw，而 raw 这一层是无缓冲的。</p>
<pre><code class="language-Python"># 以二进制模式打开，缓冲区为 4096
f = open(&quot;main.c&quot;, &quot;wb&quot;)
# 会立即写入磁盘，因为这一层没有缓冲区
# 它可以看做是调用操作系统提供的原生接口
f.raw.write(b&quot;abc&quot;)

# 缓冲区大小为 4096，刚好满
f.write(b&quot;a&quot; * 4096)
# 但是到这里为止，缓冲区的数据还没有进入磁盘
# 如果你在此处 sleep 一会，然后查看文件
# 你会发现文件里面只有 abc 这三个字符

# 好，此时又来一个字符，缓冲区容不下了
# 必须先将已有的 4096 个字节写入磁盘
# 而写入是通过调用 f.raw 写入的
f.write(b&quot;b&quot;)
</code></pre>
<p>文本模式也是同理，它是在二进制模式的基础之上又构建了一层。</p>
<pre><code class="language-python"># 以文本模式打开，缓冲区为 8192
f = open(&quot;main.c&quot;, &quot;w&quot;)
# TextIOWrapper -&gt; BufferedWriter -&gt; raw
# 此时缓冲区刚好满
f.write(&quot;a&quot; * 8192)
# 再写入一个字符
f.write(&quot;b&quot;)

# 缓冲区容不下了，于是会将已有的 8192 字节写入 f.buffer 的缓冲区
# f.buffer 是以二进制模式打开的文件句柄
# 因为文本模式打开是构建在二进制模式打开的基础之上的
# 然后再通过 f.buffer.raw 将数据写入磁盘
</code></pre>
<p>因此，如果你希望写入的内容立刻刷到磁盘上，除了使用 flush 之外，还可以这么做。</p>
<pre><code class="language-Python"># 以文本模式打开
f = open(&quot;main.c&quot;, &quot;w&quot;)

# TextIOWrapper 没有 raw，只有 buffer，因为它是构建在 BufferedWriter 之上的
# raw 这一层没有缓冲区，调用它的 write，会直接写入文件
f.buffer.raw.write(b&quot;abc&quot;)

# 或者还可以调用 flush 方法
f.write(&quot;abc&quot;)
# 该方法的本质也是强制调用 raw 的 write 操作，将内容写入磁盘
f.flush()
</code></pre>
<p>因此这三层的关系如下：</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./3.png" alt="" /></p>
<p>所以这就是三者之间的关系，最终实际负责写入数据的肯定还是 raw 这一层，只不过它没有缓冲区，只要有数据，就立刻写入。所以为了保证效率，在 raw 这一层之上又构建了带缓冲区的两层。</p>
<p>那么如何指定缓冲区的大小呢？</p>
<pre><code class="language-python">f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=1024)
</code></pre>
<p>通过 buffering 参数即可设置缓冲区大小，注意：不管是文本模式打开、还是二进制模式打开，这里的 buffering 参数设置的都是二进制这一层的缓冲区。在设置的时候 buffering 必须大于 1，如果等于 1，那么就不再是全缓冲了，而是行缓冲，意思就是遇到换行会立即写入磁盘。不过问题来了， 要是一直都没有写入换行呢？如果一直没有换行，那么缓冲区满了会写入磁盘，所以此时相当于全缓冲。</p>
<p>另外，行缓冲只支持文本模式。</p>
<pre><code class="language-python">import time

f = open(&quot;main.c&quot;, &quot;w&quot;)
f.write(&quot;abc\n&quot;)
time.sleep(30)
</code></pre>
<p>执行，然后查看文件，会发现里面啥也没有，因为数据都在缓冲区里面。默认是全缓冲，第一层的缓冲区大小是 8192，第二层的缓冲区大小是 4096，只有缓冲区满了，才会写入磁盘。</p>
<pre><code class="language-Python">import time

f = open(&quot;main.c&quot;, &quot;w&quot;, buffering=1)
f.write(&quot;abc\n&quot;)
time.sleep(30)
</code></pre>
<p>如果指定 buffering=1，那么就变成了行缓冲，在遇到换行的时候会直接写入磁盘，而不管缓冲区有没有满。如果一直没有换行，那么等价于全缓冲。</p>
<p>最后，还有一个无缓冲，也就是指定 buffering 为 0，但只支持二进制模式。</p>
<pre><code class="language-Python">f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=0)
# 立即写入缓冲区
f.write(b&quot;abc&quot;)
</code></pre>
<p>实际上，如果指定 buffering=0，那么会直接得到 raw 这一层的文件句柄。</p>
<pre><code class="language-Python">import time

f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=1024)
print(f)
print(f.raw)
&quot;&quot;&quot;
&lt;_io.BufferedWriter name='main.c'&gt;
&lt;_io.FileIO name='main.c' mode='wb' closefd=True&gt;
&quot;&quot;&quot;
# raw 这一层对应的文件句柄类型是 FileIO
# 它可以看做是调用操作系统的原生接口，这一层没有缓冲区

# 如果指定 buffering=0
f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=0)
# 我们看到直接返回第三层
print(f)
&quot;&quot;&quot;
&lt;_io.FileIO name='main.c' mode='wb' closefd=True&gt;
&quot;&quot;&quot;
# 所以 buffering=0 表示无缓冲
# 因为它返回的不是 BufferedWriter，而是 raw 这一层的句柄
</code></pre>
<p>我们总结一下，缓冲模式分为全缓冲、行缓冲、无缓冲。</p>
<ul>
<li>buffering 大于 1：全缓冲；</li>
<li>buffering 等于 1：行缓冲，只适用于文本模式；</li>
<li>buffering 等于 0：无缓冲，只适用于二进制模式，并且返回的句柄类型是 FileIO；</li>
</ul>
<h2 id="优雅地遍历一个目录"><a class="header" href="#优雅地遍历一个目录">优雅地遍历一个目录</a></h2>
<p>在工作中，有时我们需要读取一个目录，然后遍历里面所有的文件。我们可以使用 os.listdir 来实现，但是 Python 从 3.4 开始引入了一个 pathlib 模块，更加的方便。</p>
<pre><code class="language-python">from pathlib import Path

p = Path(r&quot;C:\python38\Lib\asyncio&quot;)

for file in p.glob(&quot;b*.py&quot;):
    print(file)
&quot;&quot;&quot;
C:\python38\Lib\asyncio\base_events.py
C:\python38\Lib\asyncio\base_futures.py
C:\python38\Lib\asyncio\base_subprocess.py
C:\python38\Lib\asyncio\base_tasks.py
&quot;&quot;&quot;
</code></pre>
<p>Path 接收一个文件路径，然后调用它的 glob 方法，即可遍历内部所有的文件。并且 glob 方法接收一个模式，在遍历的时候会选择名称和模式匹配的文件。</p>
<ul>
<li>?：匹配一个任意字符；</li>
<li>*：匹配任意个任意字符；</li>
<li>[sequence]：匹配出现在 sequence 里面的一个字符；</li>
<li>[!sequence]：匹配没有出现在 sequence 里面的一个字符；</li>
<li>[a-z]：匹配出现在 abcdef...z 中的一个字符；</li>
<li>[A-Z]：匹配出现在 ABCDEF...Z 中的一个字符；</li>
<li>[0-9]：匹配出现在 0123...9 中的一个字符；</li>
</ul>
<p>如果想匹配所有文件，那么直接 <strong>.glob(&quot;*&quot;)</strong> 即可，并且遍历得到的仍是一个 Path 对象。当然啦，如果只是 glob，那么可以用 os.listdir 代替。Path 对象还有一个方法叫 rglob，用法和 glob 一样，但是它可以递归遍历子目录，而 glob 只能遍历一层。</p>
<pre><code class="language-Python">from pathlib import Path

p = Path(r&quot;C:\python38\Lib\site-packages\numpy&quot;)

# 只能遍历一层
for file in p.glob(&quot;*.py&quot;):
    # 拿到文件名
    # 直接 p.glob(&quot;__init__.py&quot;) 也是可以的
    if file.name == &quot;__init__.py&quot;:
        print(file)
&quot;&quot;&quot;
C:\python38\Lib\site-packages\pnumpy\__init__.py
&quot;&quot;&quot;

# 递归遍历
for file in p.rglob(&quot;*.py&quot;):
    if file.name == &quot;__init__.py&quot;:
        print(file)
&quot;&quot;&quot;
C:\python38\Lib\site-packages\numpy\__init__.py
C:\python38\Lib\site-packages\numpy\compat\__init__.py
C:\python38\Lib\site-packages\numpy\compat\tests\__init__.py
C:\python38\Lib\site-packages\numpy\core\__init__.py
C:\python38\Lib\site-packages\numpy\core\tests\__init__.py
C:\python38\Lib\site-packages\numpy\distutils\__init__.py
......
......
&quot;&quot;&quot;
</code></pre>
<p>因此在遍历目录的时候，强烈推荐使用 pathlib 模块，非常的方便。其实不光是遍历目录，pathlib 还有其它的功能，这里也补充一下。</p>
<pre><code class="language-Python">from pathlib import Path

p = Path(__file__)
print(p)
&quot;&quot;&quot;
D:\satori\main.py
&quot;&quot;&quot;

# 如果想拿到它的上一级目录，该怎么做呢？
# 是不是比 os.path.dirname 要方便呢？
print(p.parent)  # D:\satori
# 上一级目录的上一级目录
print(p.parent.parent)  # D:\

# 目录的拼接，直接使用 / 即可
# 或者调用 joinpath
print(p.parent / &quot;koishi&quot; / &quot;main.py&quot;)
print(p.parent.joinpath(&quot;koishi&quot;, &quot;main.py&quot;))
&quot;&quot;&quot;
D:\satori\koishi\main.py
D:\satori\koishi\main.py
&quot;&quot;&quot;

# 所以 Path 在路径拼接上面也是一把好手
# 另外以上返回的都是 Path 对象
# 如果想当成字符串来用，需要调用 str 转化一下

# Path 还有一些其它方法
# 返回文件名，字符串格式
print(p.name)  # main.py

# 返回不带后缀的文件名
print(p.stem)  # main

# 文件重命名
p.rename(&quot;main2.py&quot;)
</code></pre>
<p>此外 Path 还有一些方法可以用来判断文件类型，比如是普通文件、目录文件等等。</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./4.png" alt="" /></p>
<p>这些方法内部在判断的时候也是基于 os 和 stat 模块实现的，我们上面已经介绍过了，先通过 os.stat 函数获取 st_mode，再使用 stat 模块里面函数判断类型。</p>
<p>总之在拼接路径和遍历目录的时候，首推 pathlib。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-osopen-打开文件"><a class="header" href="#使用-osopen-打开文件">使用 os.open 打开文件</a></h2>
<p>无论是读文件还是写文件，都要先打开文件。说到打开文件，估计首先想到的就是内置函数 open（即 io.open），那么它和 os.open 有什么关系呢？</p>
<p>内置函数 open 实际上是对 os.open 的封装，在 os.open 基础上增加了相关访问方法。因此为了操作方便，应该调用内置函数 open 进行文件操作，但如果对效率要求较高的话，则可以考虑使用 os.open。此外 open 函数返回的是一个文件对象，我们可以在此基础上进行任意操作；而 os.open 返回的是一个文件描述符，说白了就是一个整数，因为每一个文件对象都会对应一个文件描述符。</p>
<pre><code class="language-python">import os

f1 = open(&quot;main.c&quot;, &quot;r&quot;)
f2 = os.open(&quot;main.c&quot;, os.O_RDONLY)

print(f1.__class__)
print(f2.__class__)
&quot;&quot;&quot;
&lt;class '_io.TextIOWrapper'&gt;
&lt;class 'int'&gt;
&quot;&quot;&quot;
</code></pre>
<p>Python 的 open 函数实际上是封装了 C 的 fopen，C 的 fopen 又封装了系统调用提供的 open。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20os%20%E6%A8%A1%E5%9D%97%E6%9B%B4%E9%AB%98%E6%95%88%E5%9C%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/./1.png" alt="" /></p>
<p>操作系统提供了很多的系统调用，打开文件则是 open，我们看到它返回一个整数，这个整数就是对应的文件描述符。C 的 fopen 封装了系统调用的 open，返回的是一个文件指针。</p>
<p>所以内置函数 open 和 os.open 的区别就更加清晰了，内置函数 open 在底层会使用 C 的 fopen，得到的是一个封装好的文件对象，在此基础上可以直接操作。至于 os.open 在底层则不走 C 的 fopen，而是直接使用系统调用提供的 open，得到的是文件描述符。</p>
<blockquote>
<p>os 模块内部的函数基本上都是直接走的系统调用，所以模块名才叫 os。</p>
</blockquote>
<p>然后我们使用 os.open 一般需要传递两个参数，第一个参数是文件名，第二个参数是模式，举个栗子：</p>
<pre><code class="language-python">import os

# 以只读方式打开，要求文件必须存在
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_RDONLY)

# 以只写方式打开，要求文件必须存在
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_WRONLY)

# 以可读可写方式打开，要求文件必须存在
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_RDWR)

# 如果希望文件不存在时能够自动创建，那么可以使用 os.O_CREAT
os.open(&quot;main.c&quot;, os.O_RDONLY | os.O_CREAT)
os.open(&quot;main.c&quot;, os.O_WRONLY | os.O_CREAT)
os.open(&quot;main.c&quot;, os.O_RDWR | os.O_CREAT)

# 文件不存在时创建，存在时清空
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)
# 当然读取文件也是可以的
# 比如 os.O_RDONLY | os.O_CREAT | os.O_TRUNC
# 也是文件存在时清空内容，但是这没有任何意义
# 因为读取的时候将文件清空了，那还读什么？

# 文件不存在时创建，存在时追加
# 打开时光标处于文件的末尾
os.open(&quot;main.c&quot;, os.O_WRONLY | os.O_CREAT | os.O_APPEND)

# 所以
&quot;&quot;&quot;
open 里面的读模式等价于这里的 os.O_RDONLY
open 里面的写模式等价于这里的 os.O_WRONLY | os.O_CREATE | os.O_TRUNC
open 里面的追加模式等价于这里的 os.O_WRONLY | os.O_CREATE | os.O_APPEND
&quot;&quot;&quot;
</code></pre>
<p>好，打开方式介绍完了，那么怎么读取和写入呢？很简单，读取使用 os.read，写入使用 os.write。</p>
<h2 id="使用-osread-读取文件"><a class="header" href="#使用-osread-读取文件">使用 os.read 读取文件</a></h2>
<p>先来看读取，os.read 接收两个参数，第一个参数是文件描述符，第二个参数是要读取多少个字节。</p>
<pre><code class="language-Python">import os

fd = os.open(&quot;main.c&quot;, os.O_RDONLY)
# 使用 os.read 进行读取，这里读取 20 个字节
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'#include &lt;Python.h&gt;'
&quot;&quot;&quot;

# 再读取 20 个字节
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'\n#include &lt;ctype.h&gt;'
&quot;&quot;&quot;

# 继续读取
data = os.read(fd, 20)
# 由于只剩下一个字节，所以就读取了一个字节
# 显然此时文件已经读完了
print(data)
&quot;&quot;&quot;
b'\n'
&quot;&quot;&quot;

# 文件读取完毕之后
# 再读取的话会返回空字节串
print(os.read(fd, 20))  # b''
print(os.read(fd, 20))  # b''
print(os.read(fd, 20))  # b''
</code></pre>
<p>所以这就是文件的读取方式，还是很简单的。然后在读取的过程中，我们还可以移动光标，通过 os.lseek 函数。</p>
<ul>
<li>os.lseek(fd, m, 0)：将光标从文件的起始位置向后移动 m 个字节；</li>
<li>os.lseek(fd, m, 1)：将光标从当前所在的位置向后移动 m 个字节；</li>
<li>os.lseek(fd, m, 2)：将光标从文件的结束位置向后移动 m 个字节；</li>
</ul>
<p>如果 m 大于 0，表示向后移动，m 小于 0，表示向前移动。所以当第三个参数为 2 的时候，也就是结束位置，那么 m 一般为负数。因为相对于结束位置，肯定要向前移动，当然向后移动也可以，不过没啥意义；同理当第三个参数为 0 时，m 一般为正数，相对于起始位置，肯定要向后移动。</p>
<pre><code class="language-Python">import os

fd = os.open(&quot;main.c&quot;, os.O_RDONLY)
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'#include &lt;Python.h&gt;'
&quot;&quot;&quot;

# 从文件的起始位置向后移动 0 个字节
# 相当于将光标设置在文件的起始位置
os.lseek(fd, 0, 0)
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'#include &lt;Python.h&gt;'
&quot;&quot;&quot;

# 设置在结束位置
os.lseek(fd, 0, 2)
print(os.read(fd, 20))  # b''

# 此时就什么也读不出来了
</code></pre>
<p>然后我们提一下 stdin, stdout, stderr，含义应该不需要解释了，重点是它们对应的文件描述符分别为 0, 1, 2。</p>
<pre><code class="language-Python">import os

# 从标准输入里面读取 10 个字节
# 没错，此时作用类似于 input
while True:
    data = os.read(0, 10).strip()
    print(f&quot;你输入了:&quot;, data)
    if data == b&quot;exit&quot;:
        break
</code></pre>
<p>我们测试一下：</p>
<p><img src="%E4%BD%BF%E7%94%A8%20os%20%E6%A8%A1%E5%9D%97%E6%9B%B4%E9%AB%98%E6%95%88%E5%9C%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/./2.png" alt="" /></p>
<p>os.read 可以实现 input 的效果，并且效率更高。另外当按下回车时，换行符也会被读进去，所以需要 strip 一下。然后我们这里读的是 10 个字节，如果一次读不完，那么会分多次读取。在读取文件的时候，也是同理。</p>
<pre><code class="language-Python">from io import BytesIO
import os

fd = os.open(&quot;main.c&quot;, os.O_RDONLY)
buf = BytesIO()

while True:
    data = os.read(fd, 10)
    if data != b&quot;&quot;:
        buf.write(data)
    else:
        break
print(buf.getvalue().decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
#include &lt;Python.h&gt;
#include &lt;ctype.h&gt;

&quot;&quot;&quot;
</code></pre>
<p>然后 os.read 还可以和内置函数 open 结合，举个栗子：</p>
<pre><code class="language-Python">import os
import io

f = open(&quot;main.c&quot;, &quot;r&quot;)
# 通过 f.fileno() 即可拿到对应的文件描述符
# 虽然这里是以文本模式打开的文件，但只要拿到文件描述符，都可以交给 os.read
print(os.read(f.fileno(), 10))  # b'#include &lt;'

# 查看光标位置
print(f.tell())  # 10

# 移动光标位置，从文件开头向后移动 5 字节
f.seek(5, 0)
print(f.tell())  # 5
# os.lseek 也可以实现
os.lseek(f.fileno(), 3, 0)
print(f.tell())  # 3
# 此时会从第 4 个字节开始读取
print(f.read())
&quot;&quot;&quot;
clude &lt;Python.h&gt;
#include &lt;ctype.h&gt;

&quot;&quot;&quot;

# os.lseek 比 f.seek 要强大一些
# 移动到文件末尾，此时没问题
f.seek(0, 2)
print(f.tell())  # 41

try:
    f.seek(-1, 2)
except io.UnsupportedOperation as e:
    print(e)
&quot;&quot;&quot;
can't do nonzero end-relative seeks
&quot;&quot;&quot;
# 但如果要相对文件末尾移动具体的字节数
# 那么 f.seek 不支持，而 os.lseek 是可以的
print(f.tell())  # 41
os.lseek(f.fileno(), -1, 2)
print(f.tell())  # 40
# 最后只剩下一个换行符
print(os.read(f.fileno(), 10))  # b'\n'
</code></pre>
<p>是不是很好玩呢？</p>
<h2 id="使用-oswrite-写入文件"><a class="header" href="#使用-oswrite-写入文件">使用 os.write 写入文件</a></h2>
<p>然后是写入文件，调用 os.write 即可写入。</p>
<pre><code class="language-Python">import os

# 此时可读可写，文件不存在时自动创建，存在则清空
fd = os.open(&quot;1.txt&quot;, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
# 写入内容，接收两个参数
# 参数一：文件描述符；参数二：bytes 对象
os.write(fd, b&quot;hello, &quot;)
os.write(fd, &quot;古明地觉&quot;.encode(&quot;utf-8&quot;))
# 读取内容
data = os.read(fd, 1024)
print(data)  # b''
# 问题来了，为啥读取不到内容呢？
# 很简单，因为光标会伴随着数据的写入而不断后移，这样的话，数据才能不断地写入
# 因此，现在的光标位于文件的结尾处，想要查看写入的内容需要移动到开头
os.lseek(fd, 0, 0)
print(os.read(fd, 1024).decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
hello, 古明地觉
&quot;&quot;&quot;
# 从后往前移动 3 字节
os.lseek(fd, -3, 2)
print(os.read(fd, 1024).decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
觉
&quot;&quot;&quot;
</code></pre>
<p>以上就是文件的写入，当然它也可以和内置函数 open 结合，通过 <strong>os.write(f.fileno(), b&quot;xxx&quot;)</strong> 进行写入。但是不建议 os.open 和 open 混用，其实工作中使用 open 就足够了。</p>
<p>然后是 stdout 和 stderr，和 os.write 结合可以实现 print 的效果。</p>
<pre><code class="language-Python">import os

os.write(1, &quot;往 stdout 里面写入\n&quot;.encode(&quot;utf-8&quot;))
os.write(2, &quot;往 stderr 里面写入\n&quot;.encode(&quot;utf-8&quot;))
</code></pre>
<p>以上就是 os.write 的用法。</p>
<h2 id="使用-osclose-关闭文件"><a class="header" href="#使用-osclose-关闭文件">使用 os.close 关闭文件</a></h2>
<p>最后是关闭文件，使用 os.close 即可。</p>
<pre><code class="language-Python">import os
import io

fd = os.open(&quot;1.txt&quot;, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
# 关闭文件
os.close(fd)

# 文件对象也是可以的
f = open(r&quot;1.txt&quot;, &quot;r&quot;)
os.close(f.fileno())
try:
    f.read()
except OSError as e:
    print(e)
&quot;&quot;&quot;
[Errno 9] Bad file descriptor
&quot;&quot;&quot;
</code></pre>
<p>如果是调用 f.close() 关闭文件，再进行读取的话，会抛出一个 ValueError，提示 I/O operation on closed file。这个报错信息比较明显，不应该在关闭的文件上执行 IO 操作，因为文件对象知道文件已经关闭了，毕竟调用的是自己的 close 方法，所以这个报错是解释器给出的。当然啦，调用 f.close 也会触发 os.close，因为关闭文件最终还是要交给操作系统负责的。</p>
<p>但如果是直接关闭底层的文件描述符，文件对象是不知道的，再使用 f.read() 依旧会触发系统调用，也就是 os.read。而操作系统发现文件已经关闭了，所以会报错：文件描述符有问题，此时就是一个 OSError，报错信息是操作系统给出的。</p>
<pre><code class="language-Python">import os

f = open(r&quot;1.txt&quot;, &quot;r&quot;)
# 文件是否关闭
print(f.closed)  # False
os.close(f.fileno())
print(f.closed)  # False

# 所以调用 os.close，文件对象 f 并不知道
# f.read 依旧会触发系统调用
</code></pre>
<p>如果是使用 f.close()。</p>
<pre><code class="language-Python">f = open(r&quot;1.txt&quot;, &quot;r&quot;)
f.close()
print(f.closed)  # True
</code></pre>
<p>后续执行 IO 操作，就不会再走系统调用了，而是直接抛出 ValueError，原因是文件对象知道文件已经关闭了。</p>
<p>除了 os.close 之外，还有一个 os.closerange，可以关闭多个文件描述符对应的文件。</p>
<pre><code class="language-Python">import os

# 关闭文件描述符为 1、2、3、4 的文件 
os.closerange(1, 5)
</code></pre>
<p>该方法不是很常用，了解一下即可。</p>
<p>以上就是使用 os 模块操作文件，它是直接使用操作系统提供的系统调用，所以效率上会比内置函数 open 要高一些。但是工作中还是不太建议使用 os 模块操作文件，使用内置函数 open 就好。</p>
<div style="break-before: page; page-break-before: always;"></div><p>为了安全，操作系统将虚拟内存划分为用户态和内核态，两者是相互隔离的，即使用户的应用程序崩溃了，也不会影响系统的运行。</p>
<p><img src="%E5%B0%86%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E5%83%8F%E6%95%B0%E7%BB%84%E4%B8%80%E6%A0%B7%E8%AE%BF%E9%97%AE/./1.png" alt="" /></p>
<p>而磁盘、网卡等硬件设备，只有内核才有权限操作，如果应用程序想读取文件，那么必然涉及用户态和内核态之间的切换。假设应用程序想要读取数据，那么会经历以下过程：</p>
<ul>
<li>1）调用 read 方法，然后触发系统调用，向内核发送 IO 请求，此时程序进入阻塞状态；</li>
<li>2）内核收到 IO 请求后，进一步将请求发送给 DMA，这里解释一下什么是 DMA。早期搬运数据都是由 CPU 来做的，但 CPU 是非常宝贵的，让它搬运数据简直是一种浪费，于是便有了 Direct Memory Access（直接内存访问）技术，简称  DMA。和磁盘等设备之间进行数据交互的时候，数据搬运的工作全部交给 DMA 控制器，让 CPU 去做别的事情；</li>
<li>3）DMA 将 IO 请求进一步发送给磁盘，表示：磁盘兄弟，你快给我准备数据；</li>
<li>4）磁盘收到 DMA 的 IO 请求，会把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li>5）DMA 收到磁盘的中断信号，会将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时仍然不占用 CPU，CPU 可以执行其他任务；</li>
<li>6）当 DMA 将数据准备好后，就会向 CPU 发送中断信号，表示你可以将数据搬到用户空间了；</li>
<li>7）CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间、或者说用户缓冲区，然后系统调用返回，read 方法结束；</li>
</ul>
<p>以上就是读取文件的整个过程，这里再解释一下 DMA。在早期搬运数据都是由 CPU 来做的，磁盘控制器的缓冲区满了之后， 由 CPU 搬到内核缓冲区。但搬数据这种简单的工作让 CPU 去做太大材小用了，如果数据量非常大的话，那 CPU 还怎么做其它事情？</p>
<p>于是有了 DMA，因为磁盘（硬件）存储的数据肯定要先到内核缓冲区，然后才能到用户空间。同理，用户空间想要往磁盘存储数据，也要先将数据拷贝到内核缓冲区，然后才能落盘。而为了保证 CPU 效率，内核缓冲区和磁盘之间的数据交互就可以交给 DMA 来做，CPU 不用亲自参与了。CPU 只需要告诉 DMA 传输的数据内容、以及将数据传输到哪里即可，剩下的交给 DMA 去做，DMA 做完了再告知 CPU。</p>
<p>早期的 DMA 只存在于主板上，而现在 IO 设备越来越多，不同的 IO 设备对数据传输的要求也不相同，所以每个设备都有自己的 DMA 控制器。总之 DMA 的作用非常单纯，就是为了减少 CPU 的工作量，帮助 CPU 完成内核缓冲区和磁盘等硬件之间的数据搬运。</p>
<p>但是 DMA 只负责内核缓冲区和磁盘之间的数据搬运，而内核空间和用户空间之间的数据搬运，必须由 CPU 来做。因为 DMA 位于硬件设备之上，只有内核才能操作硬件设备，所以 DMA 只能把数据搬到内核空间，不可能把内核空间的数据再搬到用户空间。换句话说，只要涉及到用户态，那么数据搬运只能由 CPU 来做。</p>
<p>整个过程示意图如下：</p>
<p><img src="%E5%B0%86%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E5%83%8F%E6%95%B0%E7%BB%84%E4%B8%80%E6%A0%B7%E8%AE%BF%E9%97%AE/./2.png" alt="" /></p>
<p>好了，说了这么多，接下来就要进入主题了。</p>
<p>以上过程发生了两次数据拷贝，第一次拷贝是 DMA 做的，将数据从磁盘搬到内核缓冲区；但第二次拷贝是 CPU 做的，将数据从内核缓冲区搬到用户缓冲区，因为用户进程只能操作用户空间里的数据。</p>
<p>但显然数据的拷贝是比较耗时的，于是 Linux 提供了一个系统调用函数 mmap，可以直接将文件映射到指定的用户进程（对应的虚拟内存）。进程通过对内存的读取和修改，实现对文件的读取和修改，从而避免了内核空间和用户空间的数据拷贝。</p>
<p>另外，如果多个进程映射同一个文件，还可以实现进程通信的目的。因为映射的是同一个文件，一个进程修改了，另一个进程也能看到。</p>
<p>前置知识介绍完了，而我们的主题是和 Python 相关的，那么接下来就要通过 Python 实现 mmap。而实现方式也很简单，Python 有一个内置库叫 mmap，调用它的 mmap 类即可实现。函数的原型如下：</p>
<pre><code class="language-Python"># Windows
mmap(fileno, length[, tagname[, access[, offset]]])
# UNIX
mmap(fileno, length[, flags[, prot[, access[, offset]]]])
</code></pre>
<p>解释一下里面的参数，这里只看 UNIX：</p>
<ul>
<li>fileno：文件描述符，通过 os.open 获取即可。或者使用内置函数 open 打开，然后通过文件对象的 fileno 方法获取；</li>
<li>length：映射的长度，比如文件有 1G，但我们可能只映射 1024 字节。如果指定为 0，则全部映射；</li>
<li>offset：映射默认是从头开始的，如果不想从头开始，还可以指定偏移量。但这个偏移量必须是页对齐的，一个页大小默认是 4096，可以通过 mmap.PAGESIZE 查看。换句话说，offset 必须是 mmap.PAGESIZE 的整数倍；</li>
<li>prot：映射之后的内存段权限，有以下几种：
<ul>
<li>mmap.PROT_READ：内存段可读；</li>
<li>mmap.PROT_WRITE：内存段可写；</li>
<li>mmap.PROT_EXEC：内存段可执行；</li>
<li>mmap.PROT_NONE：内存段不能被访问；</li>
</ul>
</li>
<li>flags：进程修改内存段之后，文件的表现，有以下几种：
<ul>
<li>mmap.MAP_SHARED：对内存的修改，会体现在文件中；</li>
<li>mmap.MAP_PRIVATE：对内存的修改，不会体现在文件中；</li>
<li>mmap.ANNOYMOUS：如果内存不是基于映射文件得到的，那么内容全部被初始化为 0；</li>
</ul>
</li>
</ul>
<p>prot 和 flags 参数我们一般不需要太关注，默认值就是我们想要的，多个进程可以共享文件，并且对内存的修改也会体现在文件中。所以我们只需要关注 fileno, length, offset 这三个参数即可，下面来测试一下，看看 mmap 的用法。</p>
<pre><code class="language-Python">import mmap
import os

# 1.txt 里面的内容是 a-z 总共 26 个小写的英文字母
m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
# 打印的结果是一个 mmap 对象
print(m)
&quot;&quot;&quot;
&lt;mmap.mmap object at 0x0000011D7FD5A930&gt;
&quot;&quot;&quot;

# 查看长度
print(len(m))
print(m.size())
&quot;&quot;&quot;
26
26
&quot;&quot;&quot;

# 获取元素，支持索引和切片
print(m[0], chr(m[0]))
&quot;&quot;&quot;
97 a
&quot;&quot;&quot;
print(m[-1], chr(m[-1]))
&quot;&quot;&quot;
122 z
&quot;&quot;&quot;

print(m[1: 3])
print(m[-3:])
print(m[:])
&quot;&quot;&quot;
b'bc'
b'xyz'
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

# 还提供了 find 和 rfind 方法
print(m.find(b&quot;bcd&quot;))  # 1
print(m.find(b&quot;z&quot;))  # 25
print(m.rfind(b&quot;z&quot;))  # 25
</code></pre>
<p>是不是很方便呢？就跟操作数组一样。当然啦，mmap 还支持文件操作。</p>
<pre><code class="language-python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)

# 返回文件光标
print(m.tell())
&quot;&quot;&quot;
0
&quot;&quot;&quot;
# 读取文件内容，可以指定读取多少字节
# 不指定，则从当前光标位置读到结尾
print(m.read())
&quot;&quot;&quot;
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;
# 此时光标处于文件结尾
print(m.tell())
&quot;&quot;&quot;
26
&quot;&quot;&quot;
# 移动光标
# 从结尾向前移动 5 字节
m.seek(-5, 2)
print(m.tell())
&quot;&quot;&quot;
21
&quot;&quot;&quot;
# 读取内容
print(m.read())
&quot;&quot;&quot;
b'vwxyz'
&quot;&quot;&quot;
# 继续读取的话，会读到空字节串
print(m.read(3), m.read())
&quot;&quot;&quot;
b'' b''
&quot;&quot;&quot;

# 无论光标在什么位置
# 都不影响索引或切片访问
print(m[10: 20])
&quot;&quot;&quot;
b'klmnopqrst'
&quot;&quot;&quot;
</code></pre>
<p>除此之外，mmap 还支持 for 循环：</p>
<pre><code class="language-python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)

# 既然支持索引访问，证明实现了 __getitem__
# 那么支持 for 循环也是意料之中的
for index, char in enumerate(m):
    if index == 5:
        break
    print(char)
&quot;&quot;&quot;
b'a'
b'b'
b'c'
b'd'
b'e'
&quot;&quot;&quot;
# 注意：for 循环这种方式，不会影响光标

# 所以 mmap 对象还提供了一个 read_byte 方法
# read_byte 也是每次读取一个字节，但是会影响光标
print(m.read_byte())  # 97
print(m.read_byte())  # 98
print(m.read_byte())  # 99
# 返回的是整数，read_byte() 就相当于 read(1)[0]

# 最后 mmap 还提供了 readline 方法，一次读取一行
print(m.tell())  # 3
print(m.readline())
&quot;&quot;&quot;
b'defghijklmnopqrstuvwxyz'
&quot;&quot;&quot;
m.seek(0, 0)
print(m.readline())
&quot;&quot;&quot;
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;
# 当前文件只有一行
# 所以再读的话就没有内容了
print(m.readline())  # b''
</code></pre>
<p>以上都是读取数据，然后我们来写入数据。</p>
<pre><code class="language-Python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)

# 通过索引赋值，赋的值必须是整数
m[0] = ord(&quot;A&quot;)
# 注意长度要匹配
m[1: 3] = b&quot;BC&quot;
# 查看文件的话，会发现文件也被修改了
print(m[:])
&quot;&quot;&quot;
ABCdefghijklmnopqrstuvwxyz
&quot;&quot;&quot;
m[-2:] = b&quot;YZ&quot;
print(m[:])
&quot;&quot;&quot;
ABCdefghijklmnopqrstuvwxYZ
&quot;&quot;&quot;

# 注意：在通过索引或切片操作的时候，不要越界
# 文件总共 26 个字符，都是 ASCII
# 因此最大索引是 25
try:
    m[26] = 33
except IndexError as e:
    print(e)
&quot;&quot;&quot;
mmap index out of range
&quot;&quot;&quot;

try:
    # 依旧越界    
    m[26: 27] = b&quot;~&quot;
except IndexError as e:
    print(e)
&quot;&quot;&quot;
mmap slice assignment is wrong size
&quot;&quot;&quot;

# 最大索引是 25，所以 m[24:] 等价于 m[24: 26]
# 此时只剩下两个字节，而我们赋的值是 3 个字节
try:
    m[24:] = b&quot;~~~&quot;
except IndexError as e:
    print(e)
&quot;&quot;&quot;
mmap slice assignment is wrong size
&quot;&quot;&quot;
# 此时是没问题的
m[23:] = b&quot;~~~&quot;
print(m[:])
&quot;&quot;&quot;
b'ABCdefghijklmnopqrstuvw~~~'
&quot;&quot;&quot;
</code></pre>
<p>像这种通过索引或切片赋值的方式，不仅修改内存中的数据，还会将修改后的数据映射到磁盘文件里面。如果你在 Windows 上操作之后，发现文件内容没有变化，那么不妨先关闭，然后再用 notepad++ 打开。Linux 的话，直接 cat 命令即可。</p>
<p>注意：此时进程对内存的操作会直接体现在文件里，而不需要经过内核空间的 read、write 等系统调用。换句话说，此时操作内存等价于操作文件，因为两者已经建立好了映射关系，因此这种做法非常高效。</p>
<blockquote>
<p>通常在加载共享库的时候，也是通过 mmap 的方式加载的。另外，在映射的时候，不能映射一个空文件，里面必须有内容。</p>
</blockquote>
<p>mmap 也提供了类似文件的写入方法，我们来看一看，不过在这之前我先把文件恢复原样。</p>
<pre><code class="language-Python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
print(m[:])
&quot;&quot;&quot;
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

# 会伴随光标移动
m.write(b&quot;ABC&quot;)
print(m[:])
&quot;&quot;&quot;
b'ABCdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

m.write(b&quot;DEF&quot;)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

# 移动到文件末尾的前 1 个字节
m.seek(-1, 2)
print(m.tell())  # 25
# 此时最多写入一个字节
try:
    m.write(b&quot;ZZ&quot;)
except ValueError as e:
    print(e)
&quot;&quot;&quot;
data out of range
&quot;&quot;&quot;
m.write(b&quot;Z&quot;)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwxyZ'
&quot;&quot;&quot;
# 除了 write 方法之外，还有一个 write_byte
# 但 write_byte 每次只能写入一个字节，并且接收的必须是 0 ~ 255 之间的整数
</code></pre>
<p>用记事本打开 1.txt 文件，如果已经打开，那么就先关闭再打开，会发现内容被修改。</p>
<p>然后 mmap 还有一个 resize 方法，它可以改变内存段的大小。</p>
<pre><code class="language-Python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwxyZ'
&quot;&quot;&quot;
# 打开文件会发现结尾的 yZ 已经没了
m.resize(24)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwx'
&quot;&quot;&quot;
# 如果扩大 size 的话，会用 \x00 填充
m.resize(26)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwx\x00\x00'
&quot;&quot;&quot;
</code></pre>
<p>打开文件，查看内容：</p>
<p><img src="%E5%B0%86%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E5%83%8F%E6%95%B0%E7%BB%84%E4%B8%80%E6%A0%B7%E8%AE%BF%E9%97%AE/./3.png" alt="" /></p>
<p>\x00 显示的就是这种乱七八糟的样子，总之 resize 的话，如果 size 减少，相当于删除；size 增加，用 \x00 填充。</p>
<p>以上就是通过 mmap 来读写文件，它的效率很高，并且还支持通过索引和切片的方式读写，建议使用此方式。对了，还有关闭，如果不需要使用了，可以调用 m.close() 关闭 mmap 对象（但是文件不会关闭）。</p>
<p>最后，再来聊一聊 offset，它表示偏移量，这个偏移量必须是页对齐的。</p>
<pre><code class="language-Python">import mmap
import os

with open(&quot;1.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
    f.write(&quot;a&quot; * 4096 + &quot;abc&quot;)

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
print(len(m))  # 4099

try:
    m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0, offset=100)
except OSError as e:
    print(e)
&quot;&quot;&quot;
[WinError 1132] 指定的基址或文件偏移量没有适当对齐。
&quot;&quot;&quot;

# 偏移量必须是 mmap.PAGESIZE 的整数倍
# 一个页的大小一般是 4096
m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0, offset=mmap.PAGESIZE)
# 显然此时只能读出 b&quot;abc&quot;
print(m[:])
&quot;&quot;&quot;
b'abc'
&quot;&quot;&quot;
# 补充一下，即便 offset 是 PAGESIZE 的整数倍
# 在 Windows 上依然会报出上面的错误，但在 Linux 上面是没有问题的
</code></pre>
<p>以上就是 offset 的作用，它表示偏移量，但是这个偏移量必须是页对齐的。并且，offset 不可以超过文件的长度，否则会报错：ValueError: mmap offset is greater than file size。</p>
<p>关于 mmap 的部分我们就说到这里。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-4"><a class="header" href="#楔子-4">楔子</a></h2>
<p>Python 有一个第三方模块叫 psutil，专门用来获取操作系统以及硬件相关的信息，比如：CPU、磁盘、网络、内存等等。下面来看一下它的用法，不过在使用之前需要先安装，直接 pip install psutil 即可。</p>
<h2 id="cpu-相关"><a class="header" href="#cpu-相关">CPU 相关</a></h2>
<p><strong><font color="darkblue">获取 CPU 的逻辑核心数量</font></strong></p>
<pre><code class="language-Python">import psutil
print(psutil.cpu_count())  # 12

# 或者使用 multiprocessing
import multiprocessing
print(multiprocessing.cpu_count())  # 12
</code></pre>
<p><strong><font color="darkblue">获取 CPU 的物理核心数量</font></strong></p>
<pre><code class="language-Python">import psutil
print(psutil.cpu_count(logical=False))  # 6
</code></pre>
<p>结果为 6，说明是 6 核超线程；如果 CPU 的物理核心数和逻辑核心数相等，也为 12，则说明是 12 核非超线程。</p>
<p><strong><font color="darkblue">统计 CPU 的用户／系统／空闲时间</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.cpu_times())
&quot;&quot;&quot;
scputimes(user=84732.10937499999, 
          system=37132.85937500023, 
          idle=2003964.1249999998, 
          interrupt=3500.765625, 
          dpc=1089.6875)
&quot;&quot;&quot;

# 还有一个 psutil.cpu_times_percent() 
# 功能与之类似, 只不过返回的是比例
</code></pre>
<p>该函数返回的是一个 namedtuple，后面凡是结构长的和这里类似的，都是 namedtuple。补充一下，如果你的程序中需要创建大量的对象，并且该对象的属性固定不变，那么不妨使用 namedtuple，相比使用字典，能节省大量空间。</p>
<p><strong><font color="darkblue">查看 CPU 的使用率</font></strong></p>
<pre><code class="language-Python">import psutil

for x in range(3):
    # interval：表示每隔 0.5s 刷新一次
    # percpu：为 True 表示查看所有的 cpu 使用率
    print(psutil.cpu_percent(interval=0.5, percpu=True))
&quot;&quot;&quot;
[9.1, 3.1, 12.5, 3.1, 15.6, 0.0, 6.2, 0.0, 12.5, 50.0, 9.4, 3.1]
[9.1, 6.2, 12.5, 6.2, 3.1, 0.0, 0.0, 3.1, 0.0, 15.6, 3.1, 0.0]
[0.0, 0.0, 15.6, 0.0, 6.2, 0.0, 6.2, 25.0, 3.1, 9.4, 6.2, 0.0]
&quot;&quot;&quot;
# 我这里 cpu 的逻辑数量是 12
# 所以每个列表里面有 12 个元素
</code></pre>
<p><strong><font color="darkblue">查看 CPU 的统计信息</font></strong></p>
<p>包括上下文切换、中断、软中断，以及系统调用次数等等。</p>
<pre><code class="language-Python">import psutil

print(psutil.cpu_stats())
&quot;&quot;&quot;
scpustats(ctx_switches=3346512902, 
          interrupts=2288572793, 
          soft_interrupts=0, 
          syscalls=3324041552)
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看 CPU 的频率</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.cpu_freq())
&quot;&quot;&quot;
scpufreq(current=2208.0, min=0.0, max=2208.0)
&quot;&quot;&quot;
</code></pre>
<h2 id="内存相关"><a class="header" href="#内存相关">内存相关</a></h2>
<p><strong><font color="darkblue">查看内存使用情况</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.virtual_memory())
&quot;&quot;&quot;
svmem(total=17029259264, 
      available=7698505728, 
      percent=54.8, 
      used=9330753536, 
      free=7698505728)
&quot;&quot;&quot;
</code></pre>
<p>total 表示总内存，available 表示可用内存，percent 表示内存使用率，used 表示已使用的内存，free 表示可用内存。</p>
<p>所以 available 加上 used 等于 total，used 除以 total 再乘以 100 等于 percent。</p>
<p><strong><font color="darkblue">查看交换内存信息</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.swap_memory())
&quot;&quot;&quot;
sswap(total=3087007744, 
      used=4509839360, 
      free=-1422831616, 
      percent=146.1, 
      sin=0, 
      sout=0)
&quot;&quot;&quot;
</code></pre>
<p>说到内存，有物理内存、交换内存、虚拟内存，这三者有什么区别呢？用大白话解释就是：</p>
<p>1）物理内存是实际的内存条提供的临时数据存储空间，在 Windows 上右键点击计算机，再点击属性时，上面显示的安装内存（RAM）就是电脑的物理内存。这些内存是实际存在的，在你不给机器增加内存条的时候是不会改变的。</p>
<p>2）交换内存通常在页面调度和交换进程数据时使用，相当于在进行内存整理的时候，会先把部分数据放在硬盘的某块区域。类似我们整理衣柜，衣服一多直接整理会很麻烦，因此会先把部分衣服拿出来放在其它地方，等衣柜里的衣服整理完了，再把放在其它地方的衣服拿回来。</p>
<p>这个<strong>其它地方</strong>在计算机中则代表硬盘的某块区域，也就是我们所说的交换区。通常使用交换内存是因为物理内存不足导致的，正所谓衣柜，如果足够大的话就没必要拿出部分衣服放在其它地方， 直接在衣柜里就能解决了。</p>
<p>3）最后是虚拟内存，当操作文件，可执行程序等等，那么首先要把它们从磁盘读取到内存中，因此 CPU 除了自己那一部分小小的空间外，要想操作数据，只能操作内存里的数据。</p>
<p>但是当内存不够了，那么会在硬盘上开辟一份虚拟内存，将物理内存里的部分数据放在虚拟内存当中。硬盘的空间很大，即使普通电脑安装的固态硬盘也有一百个 G，因此可以拿出一部分充当虚拟内存。不过虚拟内存虽说是内存，但毕竟在硬盘上，速度和 CPU 直接从物理内存里读取数据相差甚远。这也是为什么要将经常被访问的热点数据放在 Redis 缓存里，而不是放在硬盘或者数据库上。</p>
<h2 id="磁盘相关"><a class="header" href="#磁盘相关">磁盘相关</a></h2>
<p><strong><font color="darkblue">查看磁盘分区、磁盘使用率和磁盘 IO 信息</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.disk_partitions())
&quot;&quot;&quot;
[sdiskpart(device='C:\\', mountpoint='C:\\', fstype='NTFS', opts='rw,fixed', maxfile=255, maxpath=260),
 sdiskpart(device='D:\\', mountpoint='D:\\', fstype='NTFS', opts='rw,fixed', maxfile=255, maxpath=260),
 sdiskpart(device='E:\\', mountpoint='E:\\', fstype='NTFS', opts='rw,fixed', maxfile=255, maxpath=260)]
&quot;&quot;&quot;
</code></pre>
<p>可以看到一共有三个盘符，fstype 表示文件系统类型，这里是 NTFS；opts 中的 rw 表示可读写。</p>
<p>该函数还可以接收一个参数 all，默认为 False。如果指定为 True，在 Linux 上返回的内容还会包含 /proc 等特殊文件系统的挂载信息。由于我这里是 Windows，所以两者没区别。</p>
<p><strong><font color="darkblue">查看某个磁盘使用情况</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.disk_usage(&quot;C:\\&quot;))
&quot;&quot;&quot;
sdiskusage(total=267117391872, 
           used=96894304256, 
           free=170223087616, 
           percent=36.3)
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看磁盘 IO 统计信息</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.disk_io_counters())
&quot;&quot;&quot;
sdiskio(read_count=1172461, 
        write_count=2153031, 
        read_bytes=36854982144, 
        write_bytes=52718300160, 
        read_time=551, 
        write_time=1437)
&quot;&quot;&quot;
</code></pre>
<ul>
<li>read_count ：<strong>读次数</strong></li>
<li>write_count：<strong>写次数</strong></li>
<li>read_bytes：<strong>读的字节数</strong></li>
<li>write_bytes：<strong>写的字节数</strong></li>
<li>read_time：<strong>读时间</strong></li>
<li>write_time：<strong>写时间</strong></li>
</ul>
<p>以上返回的是所有磁盘加起来的统计信息，我们可以指定 perdisk=True，分别列出每一个分区的统计信息。</p>
<h2 id="网络相关"><a class="header" href="#网络相关">网络相关</a></h2>
<p><strong><font color="darkblue">查看网卡的网络 IO 统计信息</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.net_io_counters())
&quot;&quot;&quot;
snetio(bytes_sent=175995567, 
       bytes_recv=2849015622, 
       packets_sent=1052206, 
       packets_recv=3050302, 
       errin=0, 
       errout=0, 
       dropin=3491, 
       dropout=0)
&quot;&quot;&quot;
# bytes_sent: 发送的字节数
# bytes_recv: 接收的字节数
# packets_sent: 发送的包数据量
# packets_recv: 接收的包数据量
# errin: 接收包时, 出错的次数
# errout: 发送包时, 出错的次数
# dropin: 接收包时, 丢弃的次数
# dropout: 发送包时, 丢弃的次数

# 里面还有一个 pernic 参数
# 如果为 True, 则列出所有网卡的信息
print(psutil.net_io_counters(pernic=True))
&quot;&quot;&quot;
{'以太网': snetio(bytes_sent=178716616, 
                 bytes_recv=2866823348, 
                 packets_sent=1058190, 
                 packets_recv=3102852, 
                 errin=0, errout=0, 
                 dropin=3491, dropout=0), 
'WLAN': snetio(bytes_sent=0, bytes_recv=0, 
               packets_sent=0, packets_recv=0, 
               errin=0, errout=0, 
               dropin=0, dropout=0), 
'本地连接* 3': snetio(bytes_sent=0, bytes_recv=0, 
                    packets_sent=0, packets_recv=0, 
                    errin=0, errout=0, 
                    dropin=0, dropout=0), 
'本地连接* 4': snetio(bytes_sent=0, bytes_recv=0, 
                     packets_sent=0, packets_recv=0,
                     errin=0, errout=0, 
                     dropin=0, dropout=0), 
'蓝牙网络连接': snetio(bytes_sent=0, bytes_recv=0, 
                    packets_sent=0, packets_recv=0,
                    errin=0, errout=0, 
                    dropin=0, dropout=0), 
'Loopback Pseudo-Interface 1': snetio(bytes_sent=0, 
                                      bytes_recv=0, 
                                      packets_sent=0, 
                                      packets_recv=0, 
                                      errin=0, errout=0, 
                                      dropin=0, dropout=0)}
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看网络接口信息</font></strong></p>
<pre><code class="language-python">import psutil

# 以字典的形式返回网卡的配置信息
# 包括 IP 地址、Mac地址、子网掩码、广播地址等等
print(psutil.net_if_addrs())
&quot;&quot;&quot;
{'以太网': [
    snicaddr(family=&lt;AddressFamily.AF_LINK: -1&gt;, 
             address='9C-7B-EF-15-FC-2F', netmask=None, 
             broadcast=None, ptp=None), 
    snicaddr(family=&lt;AddressFamily.AF_INET: 2&gt;, 
             address='192.168.4.150', netmask='255.255.240.0', 
             broadcast=None, ptp=None), 
    snicaddr(family=&lt;AddressFamily.AF_INET6: 23&gt;, 
             address='fe80::4826:a6a6:b5f4:3647', 
             netmask=None, broadcast=None, ptp=None)], 

'WLAN': [...], 
'本地连接* 3': [...], 
'本地连接* 4': [...], 
'蓝牙网络连接': [...], 
'Loopback Pseudo-Interface 1': [...]}
&quot;&quot;&quot;

# 返回网卡的详细信息, 包括是否启动、通信类型、传输速度、mtu
print(psutil.net_if_stats())
&quot;&quot;&quot;
{'以太网': snicstats(isup=True, 
                    duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                    speed=1000, mtu=1500), 
'蓝牙网络连接': snicstats(isup=False, 
                        duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                        speed=3, mtu=1500), 
'Loopback Pseudo-Interface 1': snicstats(isup=True, 
                                         duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                                         speed=1073, mtu=1500), 
'WLAN': snicstats(isup=False, 
                  duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                  speed=0, mtu=1500), 
'本地连接* 3': snicstats(isup=False, 
                        duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                        speed=0, mtu=1500), 
'本地连接* 4': snicstats(isup=False, 
                        duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                        speed=0, mtu=1500)}
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看当前机器的网络连接</font></strong></p>
<pre><code class="language-python">import psutil

# 以列表的形式返回每个网络连接的详细信息
# 里面接受一个参数, 默认是 &quot;inet&quot;
# 当然我们也可以指定为其它, 比如 &quot;tcp&quot;
print(psutil.net_connections())
&quot;&quot;&quot;
[sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_DGRAM: 2&gt;, 
       laddr=addr(ip='192.168.4.150', port=137), 
       raddr=(), status='NONE', pid=4),
 sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_DGRAM: 2&gt;, 
       laddr=addr(ip='127.0.0.1', port=54872), 
       raddr=(), status='NONE', pid=11652),
 sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_STREAM: 1&gt;, 
       laddr=addr(ip='192.168.4.150', port=11253), 
       raddr=addr(ip='117.50.19.136', port=80), 
       status='CLOSE_WAIT', pid=11568),
 ....
 ....
 ....
]
&quot;&quot;&quot;
</code></pre>
<p>是不是很方便呢？在 Linux 中有两个命令可以做到这一点，分别是 netstat 和 ss。另外该函数会返回所有的连接信息，所以当连接数很多的时候，会占用较高的内存。</p>
<p><strong><font color="darkblue">查看当前登录的用户信息</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.users())
&quot;&quot;&quot;
[suser(name='satori', terminal=None, host='0.0.0.0', 
       started=1609841661.0, pid=None)]
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看系统的启动时间</font></strong></p>
<pre><code class="language-Python">import psutil
from datetime import datetime

print(psutil.boot_time())  # 1654012221.2945454
print(
    datetime.fromtimestamp(psutil.boot_time())
)  # 2022-05-31 23:50:21.294545
</code></pre>
<h2 id="进程管理"><a class="header" href="#进程管理">进程管理</a></h2>
<p>psutil 还提供了很多和进程管理相关的功能函数，非常的丰富，我们来看一下。</p>
<p><strong><font color="darkblue">查看当前存在的所有进程的 pid</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.pids())
&quot;&quot;&quot;
[0, 4, 148, 532, 668, 796, 904, 912, 976, ...]
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看某个进程是否存在</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.pid_exists(22333))  # False
print(psutil.pid_exists(532))  # True
</code></pre>
<p><strong><font color="darkblue">返回所有进程（Process）对象组成的迭代器</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.process_iter())
&quot;&quot;&quot;
&lt;generator object process_iter at 0x000...&gt;
&quot;&quot;&quot;

# 遍历的话，会得到每一个进程对象
# 进程对象在 psutil 里面的类型是 Process
</code></pre>
<p><strong><font color="darkblue">根据 pid 获取一个进程对应的 Process 对象</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.Process(14124))
&quot;&quot;&quot;
psutil.Process(pid=14124, name='WeChat.exe', 
               status='running', started='10:54:43')
&quot;&quot;&quot;
# 进程名称是 WeChat.exe，状态为运行中
# 启动时间是早上 10 点 54 分
</code></pre>
<h2 id="进程管理-1"><a class="header" href="#进程管理-1">进程管理</a></h2>
<p>我们说根据 pid 可以获取一个进程对应的 Process 对象，而这个对象里面包含了该进程的全部信息。</p>
<pre><code class="language-Python">import psutil

p = psutil.Process(14124)

# 进程名称
print(p.name())
&quot;&quot;&quot;
WeChat.exe
&quot;&quot;&quot;

# 进程的exe路径
print(p.exe())
&quot;&quot;&quot;
D:\WeChat\WeChat.exe
&quot;&quot;&quot;

# 进程的工作目录
print(p.cwd())
&quot;&quot;&quot;
D:\WeChat
&quot;&quot;&quot;

# 进程启动的命令行
print(p.cmdline())
&quot;&quot;&quot;
['D:\\WeChat\\WeChat.exe']
&quot;&quot;&quot;

# 当前进程id
print(p.pid)
&quot;&quot;&quot;
14124
&quot;&quot;&quot;

# 父进程id
print(p.ppid())
&quot;&quot;&quot;
8860
&quot;&quot;&quot;

# 父进程
print(p.parent())
&quot;&quot;&quot;
psutil.Process(pid=8860, name='explorer.exe', 
               status='running', started='10:53:58')
&quot;&quot;&quot;

# 子进程列表
print(p.children())
&quot;&quot;&quot;
[psutil.Process(pid=6852, name='WechatBrowser.exe', 
                status='running', started='10:54:59'), 
 psutil.Process(pid=1960, name='WeChatPlayer.exe',
                status='running', started='10:54:59'), 
 psutil.Process(pid=10432, name='WeChatApp.exe', 
                status='running', started='10:55:33')]
&quot;&quot;&quot;

# 进程状态
print(p.status())
&quot;&quot;&quot;
running
&quot;&quot;&quot;

# 进程用户名
print(p.username())
&quot;&quot;&quot;
LAPTOP-264ORES3\satori
&quot;&quot;&quot;

# 进程创建时间,返回时间戳
print(p.create_time())
&quot;&quot;&quot;
1654570483.2370846
&quot;&quot;&quot;

# 进程终端
# 在windows上无法使用
try:
    print(p.terminal())
except Exception as e:
    print(e)
&quot;&quot;&quot;
'Process' object has no attribute 'terminal'
&quot;&quot;&quot;

# 进程使用的cpu时间
print(p.cpu_times())
&quot;&quot;&quot;
pcputimes(user=27.8125, system=13.484375,
          children_user=0.0, children_system=0.0)
&quot;&quot;&quot;

# 进程所使用的的内存
print(p.memory_info())
&quot;&quot;&quot;
pmem(rss=110141440, vms=116899840, 
     num_page_faults=661356, peak_wset=221048832, 
     wset=110141440, peak_paged_pool=834824, 
     paged_pool=806216, peak_nonpaged_pool=144584, 
     nonpaged_pool=78560, pagefile=116899840, 
     peak_pagefile=197505024, private=116899840)
&quot;&quot;&quot;

# 进程打开的文件
print(p.open_files())

# 进程相关的网络连接
print(p.connections())
&quot;&quot;&quot;
[pconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_STREAM: 1&gt;, 
       laddr=addr(ip='192.168.4.150', port=7693), 
       raddr=addr(ip='58.251.111.106', port=8080), 
       status='ESTABLISHED'), 
 pconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_STREAM: 1&gt;, 
       laddr=addr(ip='127.0.0.1', port=8680), 
       raddr=(), status='LISTEN')]
&quot;&quot;&quot;

# 进程内的线程数量，这个进程开启了多少个线程
print(p.num_threads())  # 58

# 这个进程内的所有线程信息
print(p.threads())
&quot;&quot;&quot;
[pthread(id=14128, user_time=11.3125, system_time=7.578125), 
 pthread(id=13428, user_time=0.0, system_time=0.0), 
 pthread(id=13616, user_time=0.0, system_time=0.0), 
 pthread(id=13600, user_time=0.015625, system_time=0.328125),
 pthread(id=7364, user_time=0.078125, system_time=0.015625),
 ... 
 ]
&quot;&quot;&quot;

# 进程的环境变量
print(p.environ())

# 结束进程
# 执行之后微信就会被强制关闭, 这里就不试了
# p.terminal()
</code></pre>
<p>我们还可以调用 psutil.test 来模拟 ps 命令。</p>
<pre><code class="language-Python">import psutil

psutil.test()
</code></pre>
<p>可以自己看一下输出，和 Linux 的 ps 命令的输出是类似的。那么它是怎么做的呢？还记得我们之前说的 process_iter 吗？会返回所有进程的 Process 对象，直接依次输出里面的信息即可。同理，我们也可以通过 process_iter 找到某一个进程对应的进程 id。</p>
<pre><code class="language-Python">import psutil

for prcs in psutil.process_iter():
    if prcs.name().lower() == &quot;wechat.exe&quot;:
        print(prcs)
&quot;&quot;&quot;
psutil.Process(pid=14124, name='WeChat.exe', 
               status='running', started='10:54:43')
&quot;&quot;&quot;
</code></pre>
<p>有了这个操作之后，我们便可以找到对应的进程，然后借助操作系统的 kernal 修改进程内部的数据。</p>
<h2 id="小结-3"><a class="header" href="#小结-3">小结</a></h2>
<p>以上就是 psutil 模块相关的用法，总的来说，这个模块提供的功能还是蛮丰富的。在做运维的时候，少不了这个模块。</p>
<div style="break-before: page; page-break-before: always;"></div><p>假设有一个 WebSocket 接口，会源源不断地产生数据，我们需要将其保存下来，然后进行处理。但由于数据量比较大，无法一次性加载到内存，最好的办法就是保存到文件里。如果数据处理完毕，不再需要相关文件的话，那么我们可以使用临时文件。临时文件的最大好处就是，不用命名、并且关闭时会自动删除，而无需我们手动删。</p>
<p>下面我们来看看如何使用临时文件。</p>
<pre><code class="language-python">import tempfile

# 第一个参数是 mode，表示打开模式
# 默认是 &quot;wb+&quot;，二进制可读可写
f = tempfile.NamedTemporaryFile()
# 假设我们写 1G 的数据
f.write(b&quot;+&quot; * 1024 * 1024 * 1024)
# 此时文件指针会移动到末尾
# 想要读取的话，需要移动到开头
f.seek(0, 0)
print(len(f.read()))
&quot;&quot;&quot;
1073741824
&quot;&quot;&quot;
print(1073741824 == 1024 * 1024 * 1024)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<p>临时文件和真实文件的操作方法是一样的，因为临时文件本质上也属于文件，它的数据也存储在系统上，只不过我们不知道罢了。当调用 f.close()，临时文件就会被自动删除，占用的磁盘空间也会被释放。我们来验证一下：</p>
<pre><code class="language-Python">import psutil
import tempfile

GB_UNIT = 1024 * 1024 * 1024

# 临时文件默认存储在 C 盘，我们查看已经使用的空间
print(
    psutil.disk_usage(&quot;C:\\&quot;).used / GB_UNIT
)  # 89.93075561523438

f = tempfile.NamedTemporaryFile()
# 写 1G 的数据
f.write(b&quot;+&quot; * 1024 * 1024 * 1024)

# 不出意外的话，应该增加 1G
print(
    psutil.disk_usage(&quot;C:\\&quot;).used / GB_UNIT
)  # 90.93075561523438

# 关闭临时文件，然后释放磁盘空间
f.close()
# 所以又会减少 1G
print(
    psutil.disk_usage(&quot;C:\\&quot;).used / GB_UNIT
)  # 89.93075561523438
</code></pre>
<p>输出一切正常，所以结论如下：</p>
<ul>
<li>临时文件本质上也是文件，它在存储数据的时候，也是存储在磁盘上，和真实文件并无二致；</li>
<li>临时文件的调用属于操作系统级别的，所以它的创建、读写数据，最终都会走操作系统提供的系统调用；</li>
<li>临时文件在被关闭时，操作系统会自动删除；</li>
</ul>
<p>然后我们还可以指定临时文件的存储位置，虽然临时文件关闭时会自动删除，但我们还是希望它能存储在指定的位置上。</p>
<pre><code class="language-Python">import tempfile
import time

# 让临时文件保存在当前目录
f = tempfile.NamedTemporaryFile(dir=r&quot;.&quot;)
time.sleep(30)
</code></pre>
<p>为了观察到现象，这里 sleep 了 30 秒。执行时，打开目录，会发现文件创建了，并且操作系统帮我们起了个随机的名字。</p>
<p><img src="%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE/./1.png" alt="" /></p>
<p>等 30 秒过后，文件又被自动删除了。</p>
<p>然后 NamedTemporaryFile 里面还接收其它参数，我们来看一下：</p>
<p><img src="%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE/./2.png" alt="" /></p>
<p>大部分参数和内置函数 open 类似，需要注意里面的 delete 参数，它表示当临时文件关闭时是否自动删除，默认为 True。然后还有一个 prefix 和 suffix 参数，因为临时文件也是文件，也要存储在磁盘上，只不过关闭之后会自动删除。所以它也要有一个名字，默认名字的前缀是 &quot;tmp&quot;，没有后缀，而我们可以指定前缀和后缀。</p>
<pre><code class="language-python">import tempfile
import time

f = tempfile.NamedTemporaryFile(dir=r&quot;.&quot;, prefix=&quot;你好呀&quot;, suffix=&quot;我不好&quot;)
time.sleep(30)
</code></pre>
<p>执行一下看看：</p>
<p><img src="%E4%BD%BF%E7%94%A8%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE/./3.png" alt="" /></p>
<p>此时文件的前缀和后缀就被我们改掉了，不过说实话这个前缀和后缀没太大卵用，既然是临时文件，用完就删除了，名字没太大关注的必要。</p>
<p>那么问题来了，如果不指定 dir 参数，我们就不知道文件存在哪了吗？显然不是的，默认存在什么地方，tempfile 已经提前告诉我们了。</p>
<pre><code class="language-Python"># Linux 系统是 /tmp
# MacOS 系统是 /var/folders/bl/vlsr5c_95z33j3_wdqvdm8800000gn/T
print(
    tempfile.gettempdir()
)  # C:\Users\satori\AppData\Local\Temp

# 返回二进制结果
print(
    tempfile.gettempdirb()
)  # b'C:\\Users\\satori\\AppData\\Local\\Temp'

# 获取前缀
print(tempfile.gettempprefix())  # tmp
print(tempfile.gettempprefixb())  # b'tmp'
</code></pre>
<p>最后想说的是，临时文件也可以使用 mmap 进行映射。</p>
<pre><code class="language-Python">import tempfile
import mmap

f = tempfile.NamedTemporaryFile()
f.write(b&quot;hello, world&quot;)
# 映射之前需要移动一下光标
f.seek(0, 0)
# mmap 映射，这里就映射 5 字节
m = mmap.mmap(f.fileno(), 5)
m[:] = b&quot;HELLO&quot;

# 再次打印
print(f.read())
&quot;&quot;&quot;
b'HELLO, world'
&quot;&quot;&quot;
</code></pre>
<p>以上就是临时文件的用法，当然 tempfile 还提供了其它的操作，有兴趣可以了解一下，但使用最普遍的还是 NamedTemporaryFile。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-5"><a class="header" href="#楔子-5">楔子</a></h2>
<p>shutil 是一个 Python 内置模块，该模块对文件的复制、删除和压缩等操作都提供了非常方便的支持。</p>
<p>下面来详细介绍一下该模块的用法。</p>
<h2 id="chown更改指定路径的所有者用户组"><a class="header" href="#chown更改指定路径的所有者用户组">chown：更改指定路径的所有者用户（组）</a></h2>
<p>函数原型：<code>shutil.chown(path, user=None, group=None)</code></p>
<ul>
<li>path：指定要操作的路径；</li>
<li>user：指定所有者，可以是系统用户名或者 UID，如果用户不存在则报错 &quot;没有此用户&quot;；</li>
<li>group：表示组</li>
</ul>
<p>该方法只适用于 Unix 系统，下面演示一下。</p>
<pre><code class="language-Python">&gt;&gt;&gt; import shutil
&gt;&gt;&gt; import pwd  # Unix
&gt;&gt;&gt; import os
&gt;&gt;&gt; 
&gt;&gt;&gt; uid = os.stat(&quot;/home/lighthouse&quot;).st_uid
&gt;&gt;&gt; pwd.getpwuid(uid)
pwd.struct_passwd(pw_name='lighthouse', 
                  pw_passwd='x', 
                  pw_uid=1000, 
                  pw_gid=1000, 
                  pw_gecos='', 
                  pw_dir='/home/lighthouse', 
                  pw_shell='/bin/bash')

# 将所有者改成 root
&gt;&gt;&gt; shutil.chown(&quot;/home/lighthouse&quot;, user=&quot;root&quot;)
# 再次查看，发现所有者已经被修改了
&gt;&gt;&gt; uid = os.stat(&quot;/home/lighthouse&quot;).st_uid
&gt;&gt;&gt; pwd.getpwuid(uid)
pwd.struct_passwd(pw_name='root', 
                  pw_passwd='x', 
                  pw_uid=0, 
                  pw_gid=0, 
                  pw_gecos='root', 
                  pw_dir='/root', 
                  pw_shell='/bin/bash')
</code></pre>
<h2 id="copy复制文件"><a class="header" href="#copy复制文件">copy：复制文件</a></h2>
<p>copy 函数可以将一个文件复制为另一个文件。</p>
<p>函数原型：<code>shutil.copy(src, dst, *, follow_symlinks=True)</code></p>
<ul>
<li>src：文件的路径，注意：必须是文件，如果是目录则报出权限错误；</li>
<li>dst：文件或目录的路径，如果是一个已经存在的目录，那么会将 src 拷贝到该目录中；否则会创建相应的文件；</li>
<li>follow_symlinks：表示是否遵循符号链接，默认为 True。如果为 True 则复制文件，为 False、并且 src 为软连接，则创建一个新的软连接；</li>
</ul>
<p>该函数会返回目标路径，即新创建的文件的路径。</p>
<pre><code class="language-python">import shutil

shutil.copy(&quot;1.txt&quot;, &quot;test&quot;)
</code></pre>
<p>如果 test 存在并且是目录，那么将 1.txt 拷贝到 test 目录中；如果 test 不存在，那么创建一个名为 test 的文件，内容和 1.txt 一致；如果 test 存在并且不是目录，那么会把已存在的 test 文件覆盖掉，此时需要具备对 test 的写权限，否则会报出权限错误：PermissionError。</p>
<p>另外使用 copy 复制文件时，文件的元信息（创建时间、修改时间）不会被保留，相当于创建了新文件。如果要保留文件的元信息，需要使用 copy2 函数（和 copy 函数用法一致，区别就是前者不保留文件元信息、后者会保留）。</p>
<h2 id="copyfile复制文件"><a class="header" href="#copyfile复制文件">copyfile：复制文件</a></h2>
<p>参数和 copy、copy2 完全一致，只不过 copyflle 的 dst 如果已存在，那么必须是文件。</p>
<pre><code class="language-python"># 如果 test 存在并且是目录，会报错
# PermissionError: [Errno 13] Permission denied: 'test'
shutil.copyfile(&quot;1.txt&quot;, &quot;test&quot;)

# 如果 test 不存在
# 那么会创建一个名为 test 的文件，内容和 1.txt 一致
# 如果 test 存在并且不是目录，那么会把原来的文件覆盖掉
shutil.copyfile(&quot;1.txt&quot;, &quot;test&quot;)
</code></pre>
<p>比较简单，可以自己试一下，所以 copy 要比 copyfile 更高级一些。copyfile 要求 dst 存在时必须是文件，而 copy 则允许 dst 是目录，会自动将文件拷贝到目录中。使用 copyfile 同样需要写权限，并且 src 和 dst 不能是同一个文件，否则会报错：SameFileError。</p>
<p>除了 copyfile 之外，还有一个更加低级的 copyfileobj。copyfileobj 也是拷贝，接收三个参数：fsrc、fdst、length，前两个参数和 copy 类似，只不过 fsrc 和 fdst 都必须是打开的文件对象，从名字上也能看出。至于第三个参数 length 表示缓冲区，默认是 16 * 1024 字节，如果为负数代表不走缓冲区，而是直接复制。</p>
<pre><code class="language-python">import shutil
from io import StringIO

buf1 = StringIO()
buf2 = StringIO()

# buf1 里面写入一些内容
buf1.write(&quot;古明地觉&quot;)
# 调整指针，移到开头，否则读取不到内容
buf1.seek(0)
# 将 buf1 的内容拷贝到 buf2 中
shutil.copyfileobj(buf1, buf2)
# 查看 buf2 的内容
print(buf2.getvalue())  # 古明地觉
</code></pre>
<p>虽然 copyfileobj 比较低级，但是它的速度也更快。当复制大文件时，采用 copyfileobj 会更有效率，复制小文件则使用 copyfile 会更方便一些。</p>
<h2 id="copymode复制权限位"><a class="header" href="#copymode复制权限位">copymode：复制权限位</a></h2>
<p>参数和 copy 函数也完全相同，只不过它是将一个文件的权限复制给另一个文件。比如 A 文件是只读，那么复制给 B 之后 B 也是只读，但是 A 的内容不会复制给 B，因为 copymode 只是复制权限。</p>
<p>除了 copymode 还有一个 copystat，参数也是一样的，只不过它除了复制权限之外还复制最后访问时间、最后修改时间等元信息，可以自己试一下这两个函数。</p>
<h2 id="copytree递归复制整个目录树"><a class="header" href="#copytree递归复制整个目录树">copytree：递归复制整个目录树</a></h2>
<p>copytree 方法可以递归复制整个目录，并返回目标目录的路径，函数原型如下：</p>
<pre><code class="language-Python">def copytree(src, dst, symlinks=False, 
             ignore=None, copy_function=copy2,
             ignore_dangling_symlinks=False, 
             dirs_exist_ok=False):
    ...
</code></pre>
<p>参数含义如下：</p>
<ul>
<li>src：表示路径的字符串，必须是一个已存在的目录，不能是文件;</li>
<li>dst：表示路径的字符串，必须是一个不存在的目录，否则报错：FileExistsError;</li>
<li>symlinks：是否遵循符号链接，默认为 True。如果为 True，表示复制文件，如果为 False，那么当 src 为软连接时，则创建一个新的软连接;</li>
<li>ignore：在复制的时候，用于过滤某些文件;</li>
<li>copy_function：从默认值可以看出，表示拷贝函数，这里采用的是 copy2，会将文件的元信息也一块拷过去;</li>
<li>ignore_dangling_symlinks：是否忽略 symlinks，如果值为 True 则忽略，值为 False，那么当文件不存在时则产生异常。对于不支持 os.symlink() 的平台，此参数无任何影响;</li>
</ul>
<p>举个例子：</p>
<pre><code class="language-Python">import shutil

# 将 dir1 拷贝为 dir2
shutil.copytree(&quot;dir1&quot;, &quot;dir2&quot;)

# 将 dir1 拷贝为 dir3，同时忽略掉 .txt 结尾的文件
shutil.copytree(&quot;dir1&quot;, &quot;dir3&quot;, ignore=shutil.ignore_patterns(&quot;*.txt&quot;))
</code></pre>
<h2 id="disk_usage获取磁盘的使用情况"><a class="header" href="#disk_usage获取磁盘的使用情况">disk_usage：获取磁盘的使用情况</a></h2>
<p>该函数接收一个参数 path，会自动获取该路径所在磁盘的使用情况：总空间、已使用空间和空闲空间，以字节为单位。</p>
<pre><code class="language-python">import shutil

disk = shutil.disk_usage(&quot;/&quot;)
print(disk)
&quot;&quot;&quot;
usage(total=494384795648, used=71737876480, free=422646919168)
&quot;&quot;&quot;
print(disk.total / 1024 / 1024 / 1024)
print(disk.used / 1024 / 1024 / 1024)
print(disk.free / 1024 / 1024 / 1024)
&quot;&quot;&quot;
460.4317207336426
66.81110382080078
393.6206169128418
&quot;&quot;&quot;
</code></pre>
<p>关于获取磁盘信息，之前还介绍过一个模块叫 psutil。</p>
<h2 id="get_archive_formats获取支持的压缩格式"><a class="header" href="#get_archive_formats获取支持的压缩格式">get_archive_formats：获取支持的压缩格式</a></h2>
<p>一会要介绍文件压缩，所以先来看看都支持哪些压缩格式。</p>
<pre><code class="language-Python">import shutil
from pprint import pprint

pprint(shutil.get_archive_formats())
&quot;&quot;&quot;
[('bztar', &quot;bzip2'ed tar-file&quot;),
 ('gztar', &quot;gzip'ed tar-file&quot;),
 ('tar', 'uncompressed tar file'),
 ('xztar', &quot;xz'ed tar-file&quot;),
 ('zip', 'ZIP file')]
&quot;&quot;&quot;
</code></pre>
<p>既然有压缩，那么就有解压缩，get_unpack_formats 函数可以返回当前系统支持的解压缩格式列表：</p>
<pre><code class="language-Python">import shutil
from pprint import pprint

pprint(shutil.get_unpack_formats())
&quot;&quot;&quot;
[('bztar', ['.tar.bz2', '.tbz2'], &quot;bzip2'ed tar-file&quot;),
 ('gztar', ['.tar.gz', '.tgz'], &quot;gzip'ed tar-file&quot;),
 ('tar', ['.tar'], 'uncompressed tar file'),
 ('xztar', ['.tar.xz', '.txz'], &quot;xz'ed tar-file&quot;),
 ('zip', ['.zip'], 'ZIP file')]
&quot;&quot;&quot;
</code></pre>
<h2 id="get_terminal_size获取终端窗口的大小"><a class="header" href="#get_terminal_size获取终端窗口的大小">get_terminal_size：获取终端窗口的大小</a></h2>
<p>get_terminal_size 函数可以获取终端窗口的大小。</p>
<pre><code class="language-Python">import shutil

print(shutil.get_terminal_size())
&quot;&quot;&quot;
os.terminal_size(columns=80, lines=24)
&quot;&quot;&quot;
</code></pre>
<p>系统如果不支持查询，或者未连接到终端，那么默认返回 80, 24。</p>
<h2 id="make_archive创建压缩文件"><a class="header" href="#make_archive创建压缩文件">make_archive：创建压缩文件</a></h2>
<p>通过 make_archive 可以创建压缩文件，函数原型如下：</p>
<pre><code class="language-Python">def make_archive(base_name, format, root_dir=None, 
                 base_dir=None, verbose=0, dry_run=0, 
                 owner=None, group=None, logger=None):
    ...
</code></pre>
<p>参数含义如下：</p>
<ul>
<li>base_name：表示生成的压缩文件的名称（不包含扩展名），也可以是完整路径。如果只写文件名则保存到当前目录，否则保存到指定路径；</li>
<li>format：表示压缩包格式，如 zip、tar、bztar、gztar 等，会根据 format 生成扩展名并拼接到 base_name 后面；</li>
<li>root_dir：表示要压缩的目录路径，默认是当前目录；</li>
<li>base_dir：表示要压缩的目录路径，默认为当前目录；那么问题来了，它和 root_dir 之间有什么区别呢？假设我们要对 dir1 目录进行压缩，压缩后的文件名是 xx.zip。如果指定的是 root_dir=&quot;dir1&quot;，那么 xx.zip 解压之后得到的目录的名字为 xx；如果指定的是 base_dir=&quot;dir1&quot;，那么 xx.zip 解压之后得到的目录的名字仍是 dir1。当然不管目录名是 xx 还是 dir1，里面存储的内容不变，这两个参数我们指定一个即可；</li>
<li>verbose：已弃用；</li>
<li>dry_run：表示是否创建存档，如果 dry_run 为 True，则不会创建存档，但会将执行的操作记录到 logger；</li>
<li>owner：可选参数，用于指定用户，默认为当前用户；</li>
<li>group：可选参数，用于指定组，默认为当前组；</li>
<li>logger：用于记录日志，通常为 logging.Logger 对象；</li>
</ul>
<p>make_archive 函数依赖于 zipfile 和 tarfile 模块。</p>
<pre><code class="language-Python">import shutil

shutil.make_archive(&quot;xx&quot;, &quot;zip&quot;, root_dir=&quot;dir1&quot;)
</code></pre>
<p>之后会在当前目录中出现一个 xx.zip，目录 &quot;dir1&quot; 里面的所有内容都会被压缩到里面。</p>
<p>有压缩，那么自然有解压缩：</p>
<pre><code class="language-Python">shutil.unpack_archive(filename, extract_dir=None, format=None)
&quot;&quot;&quot;
filename: 解压缩文件的路径
extract_dir: 解压到哪个目录，未指定则解压到当前目录
format: 压缩文件的格式，如：zip、bztar、gztar 等等
        如果没有提供，那么根据压缩文件的扩展名进行推断
&quot;&quot;&quot;
</code></pre>
<p>该方法同样依赖于 zipfile 和 tarfile 两个模块。</p>
<h2 id="move移动文件和目录"><a class="header" href="#move移动文件和目录">move：移动文件和目录</a></h2>
<p>move 函数用于将文件或目录移动到目标目录，如果移动到了不同的文件系统中，那么移动将会变成复制。这里我们考虑同一个文件系统即可，想拷贝的话，建议使用 copy 函数。下面看一下 move 函数的用法：</p>
<pre><code class="language-Python">import shutil

&quot;&quot;&quot;
src: 源文件或目录
dst: 路径不存在相当于重命名，存在则进行移动
copy_function：默认是 copy2
&quot;&quot;&quot;
# dir22 不存在，所以相当于将 dir2 重命名为 dir22
shutil.move(&quot;dir2&quot;, &quot;dir22&quot;)

# dir3 存在，所以会将 dir22 移动到 dir3 中
shutil.move(&quot;dir22&quot;, &quot;dir3&quot;)
</code></pre>
<p>当 dst 不存在时，无论 src 是文件还是目录，都相当于重命名。如果 dst 存在并且是目录，那么 src 无论是文件还是目录，都会被移动到 dst 里面去。如果 dst 存在并且是文件，那么 src 必须也是一个文件，此时相当于覆盖，可以理解为先删除 dst、再将 src 重命名为 dst。</p>
<h2 id="rmtree删除整个目录树"><a class="header" href="#rmtree删除整个目录树">rmtree：删除整个目录树</a></h2>
<p>rmtree 函数用于删除整个目录树，参数如下：</p>
<ul>
<li>path：表示路径的字符串，必须是一个目录，不能是文件；</li>
<li>ignore_errors：默认为 False，表示是否忽略删除中出现的错误。如果为 True 表示忽略、为 False 表示不忽略；</li>
<li>onerror：一个错误处理函数，出现异常时自动调用，并且会往里面传递三个参数：os.lstat、path（路径）、excinfo（返回的异常信息）。如果 onerror 被省略，那么当发生错误时会给出提示；</li>
</ul>
<pre><code class="language-Python">import os
import shutil

print(os.access(&quot;dir3&quot;, os.F_OK))  # True
shutil.rmtree(&quot;dir3&quot;)
print(os.access(&quot;dir3&quot;, os.F_OK))  # False
</code></pre>
<h2 id="which获取可执行文件的路径"><a class="header" href="#which获取可执行文件的路径">which：获取可执行文件的路径</a></h2>
<p>我们在终端中输入 python 的时候会自动进入交互式解释器，这是因为在环境变量中配置了 python 解释器的路径，而通过 which 函数可以获取相应的路径。该函数接收的参数如下：</p>
<ul>
<li>cmd：相关命令；</li>
<li>mode：用于指定需要传递的权限掩码，默认为 os.F_OK | os.X_OK，表示测试路径是否存在、并且是否可执行；</li>
<li>path：默认为 None，表示查找 cmd 命令的路径。如果不指定则在环境变量中查找，指定了则在指定的路径参数中查找。但是注意：不管该参数有没有指定，当前目录始终会被添加到搜索路径中；</li>
</ul>
<p>为了方便，这里直接在 Linux 上测试：</p>
<pre><code class="language-Python">import shutil

print(shutil.which(&quot;python&quot;))  # /usr/bin/python
print(shutil.which(&quot;gcc&quot;))  # /usr/bin/gcc
print(shutil.which(&quot;xxxxx&quot;))  # None
</code></pre>
<p>还是很强大的，如果找不到命令的话，返回 None。</p>
<h2 id="小结-4"><a class="header" href="#小结-4">小结</a></h2>
<p>以上就是 shutil 的一些用法，在工作中不妨多使用一下。尤其是涉及文件拷贝的时候，真的非常方便。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-6"><a class="header" href="#楔子-6">楔子</a></h2>
<p>Python 在 3.7 的时候引入了一个模块：contextvars，从名字上很容易看出它指的是上下文变量（Context Variables），所以在介绍 contextvars 之前我们需要先了解一下什么是上下文（Context）。</p>
<p>Context 是一个包含了相关信息内容的对象，举个例子：&quot;比如一部 13 集的动漫，你直接点进第八集，看到女主角在男主角面前流泪了&quot;。相信此时你是不知道为什么女主角会流泪的，因为你没有看前面几集的内容，缺失了相关的上下文信息。</p>
<p>所以 Context 并不是什么神奇的东西，它的作用就是携带一些指定的信息。</p>
<h2 id="web-框架中的-request"><a class="header" href="#web-框架中的-request">web 框架中的 request</a></h2>
<p>我们以 fastapi 和 sanic 为例，看看当一个请求过来的时候，它们是如何解析的。</p>
<pre><code class="language-Python"># fastapi
from fastapi import FastAPI, Request
import uvicorn

app = FastAPI()


@app.get(&quot;/index&quot;)
async def index(request: Request):
    name = request.query_params.get(&quot;name&quot;)
    return {&quot;name&quot;: name}


uvicorn.run(&quot;__main__:app&quot;, host=&quot;127.0.0.1&quot;, port=5555)

# -------------------------------------------------------

# sanic
from sanic import Sanic
from sanic.request import Request
from sanic import response

app = Sanic(&quot;sanic&quot;)


@app.get(&quot;/index&quot;)
async def index(request: Request):
    name = request.args.get(&quot;name&quot;)
    return response.json({&quot;name&quot;: name})


app.run(host=&quot;127.0.0.1&quot;, port=6666) 
</code></pre>
<p>发请求测试一下，会看到请求都是成功的，并且对于 fastapi 和 sanic 而言，其 request 和 视图函数是绑定在一起的。也就是在请求到来的时候，会被封装成一个 Request 对象、然后传递到视图函数中。</p>
<p>但对于 flask 而言则不是这样子的，我们看一下 flask 是如何接收请求参数的。</p>
<pre><code class="language-Python">from flask import Flask, request

app = Flask(&quot;flask&quot;)


@app.route(&quot;/index&quot;)
def index():
    name = request.args.get(&quot;name&quot;)
    return {&quot;name&quot;: name}


app.run(host=&quot;127.0.0.1&quot;, port=7777)
</code></pre>
<p>我们看到对于 flask 而言则是通过 import request 的方式，如果不需要的话就不用 import，当然我这里并不是在比较哪种方式好，主要是为了引出我们今天的主题。首先对于 flask 而言，如果我再定义一个视图函数的话，那么获取请求参数依旧是相同的方式，但是这样问题就来了，不同的视图函数内部使用同一个 request，难道不会发生冲突吗？</p>
<p>显然根据我们使用 flask 的经验来说，答案是不会的，至于原因就是 ThreadLocal。</p>
<h2 id="threadlocal"><a class="header" href="#threadlocal">ThreadLocal</a></h2>
<p>ThreadLocal，从名字上看可以得出它肯定是和线程相关的。没错，它专门用来创建局部变量，并且创建的局部变量是和线程绑定的。</p>
<pre><code class="language-python">import threading

# 创建一个 local 对象
local = threading.local()

def get():
    name = threading.current_thread().name
    # 获取绑定在 local 上的 value
    value = local.value
    print(f&quot;线程: {name}, value: {value}&quot;)

def set_():
    name = threading.current_thread().name
    # 为不同的线程设置不同的值
    if name == &quot;one&quot;:
        local.value = &quot;ONE&quot;
    elif name == &quot;two&quot;:
        local.value = &quot;TWO&quot;
    # 执行 get 函数
    get()

t1 = threading.Thread(target=set_, name=&quot;one&quot;)
t2 = threading.Thread(target=set_, name=&quot;two&quot;)
t1.start()
t2.start()
&quot;&quot;&quot;
线程 one, value: ONE
线程 two, value: TWO
&quot;&quot;&quot;
</code></pre>
<p>可以看到两个线程之间是互不影响的，因为每个线程都有自己唯一的 id，在绑定值的时候会绑定在当前的线程中，获取也会从当前的线程中获取。可以把 ThreadLocal 想象成一个字典：</p>
<pre><code class="language-python">{
    &quot;one&quot;: {&quot;value&quot;: &quot;ONE&quot;},
    &quot;two&quot;: {&quot;value&quot;: &quot;TWO&quot;}
}
</code></pre>
<p>更准确的说 key 应该是线程的 id，为了直观我们就用线程的 name 代替了，但总之在获取的时候只会获取绑定在该线程上的变量的值。</p>
<p>而 flask 内部也是这么设计的，只不过它没有直接用 threading.local，而是自己实现了一个 Local 类，除了支持线程之外还支持 greenlet 协程，那么它是怎么实现的呢？首先我们知道 flask 内部存在 &quot;请求 context&quot; 和 &quot;应用 context&quot;，它们都是通过栈来维护的（两个不同的栈）。</p>
<pre><code class="language-python"># flask/globals.py
_request_ctx_stack = LocalStack()
_app_ctx_stack = LocalStack()
current_app = LocalProxy(_find_app)
request = LocalProxy(partial(_lookup_req_object, &quot;request&quot;))
session = LocalProxy(partial(_lookup_req_object, &quot;session&quot;))
</code></pre>
<p>每个请求都会绑定在当前的 Context 中，等到请求结束之后再销毁，这个过程由框架完成，开发者只需要直接使用 request 即可。所以请求的具体细节流程可以点进源码中查看，这里我们重点关注一个对象：werkzeug.local.Local，也就是上面说的 Local 类，它是变量的设置和获取的关键。直接看部分源码：</p>
<pre><code class="language-python"># werkzeug/local.py

class Local(object):
    __slots__ = (&quot;__storage__&quot;, &quot;__ident_func__&quot;)

    def __init__(self):
        # 内部有两个成员：__storage__ 是一个字典，值就存在这里面
        # __ident_func__ 只需要知道它是用来获取线程 id 的即可
        object.__setattr__(self, &quot;__storage__&quot;, {})
        object.__setattr__(self, &quot;__ident_func__&quot;, get_ident)

    def __call__(self, proxy):
        &quot;&quot;&quot;Create a proxy for a name.&quot;&quot;&quot;
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)

    def __getattr__(self, name):
        try:
            # 根据线程 id 得到 value（一个字典）
            # 然后再根据 name 获取对应的值
            # 所以只会获取绑定在当前线程上的值
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        ident = self.__ident_func__()
        storage = self.__storage__
        try:
            # 将线程 id 作为 key，然后将值设置在对应的字典中
            # 所以只会将值设置在当前的线程中
            storage[ident][name] = value
        except KeyError:
            storage[ident] = {name: value}

    def __delattr__(self, name):
        # 删除逻辑也很简单
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)
</code></pre>
<p>所以我们看到 flask 内部的逻辑其实很简单，通过 ThreadLocal 实现了线程之间的隔离。每个请求都会绑定在各自的 Context 中，获取值的时候也会从各自的 Context 中获取，因为它就是用来保存相关信息的（重要的是同时也实现了隔离）。</p>
<p>相应此刻你已经理解了上下文，但是问题来了，不管是 threading.local 也好、还是类似于 flask 自己实现的 Local 也罢，它们都是针对线程的。如果是使用 async def 定义的协程该怎么办呢？如何实现每个协程的上下文隔离呢？所以终于引出了我们的主角：contextvars。</p>
<h2 id="contextvars"><a class="header" href="#contextvars">contextvars</a></h2>
<p>该模块提供了一组接口，可用于在协程中管理、设置、访问局部 Context 的状态。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get():
    # 获取值
    return c.get() + &quot;~~~&quot;

async def set_(val):
    # 设置值
    c.set(val)
    print(await get())

async def main():
    coro1 = set_(&quot;协程1&quot;)
    coro2 = set_(&quot;协程2&quot;)
    await asyncio.gather(coro1, coro2)


asyncio.run(main())
&quot;&quot;&quot;
协程1~~~
协程2~~~
&quot;&quot;&quot;
</code></pre>
<p>ContextVar 提供了两个方法，分别是 get 和 set，用于获取值和设置值。我们看到效果和 ThreadingLocal 类似，数据在协程之间是隔离的，不会受到彼此的影响。</p>
<p>但我们再仔细观察一下，我们是在 set_ 函数中设置的值，然后在 get 函数中获取值。可 await get() 相当于是开启了一个新的协程，那么意味着设置值和获取值不是在同一个协程当中。但即便如此，我们依旧可以获取到希望的结果。因为 Python 的协程是无栈协程，通过 await 可以实现级联调用。</p>
<p>我们不妨再套一层：</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get1():
    return await get2()

async def get2():
    return c.get() + &quot;~~~&quot;

async def set_(val):
    # 设置值
    c.set(val)
    print(await get1())
    print(await get2())

async def main():
    coro1 = set_(&quot;协程1&quot;)
    coro2 = set_(&quot;协程2&quot;)
    await asyncio.gather(coro1, coro2)


asyncio.run(main())
&quot;&quot;&quot;
协程1~~~
协程1~~~
协程2~~~
协程2~~~
&quot;&quot;&quot;
</code></pre>
<p>我们看到不管是 await get1() 还是 await get2()，得到的都是 set_ 中设置的结果，说明它是可以嵌套的。</p>
<p>并且在这个过程当中，可以重新设置值。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get1():
    c.set(&quot;重新设置&quot;)
    return await get2()

async def get2():
    return c.get() + &quot;~~~&quot;

async def set_(val):
    # 设置值
    c.set(val)
    print(&quot;------------&quot;)
    print(await get2())
    print(await get1())
    print(await get2())
    print(&quot;------------&quot;)

async def main():
    coro1 = set_(&quot;协程1&quot;)
    coro2 = set_(&quot;协程2&quot;)
    await asyncio.gather(coro1, coro2)


asyncio.run(main())
&quot;&quot;&quot;
------------
协程1~~~
重新设置~~~
重新设置~~~
------------
------------
协程2~~~
重新设置~~~
重新设置~~~
------------
&quot;&quot;&quot;
</code></pre>
<p>先 await get2() 得到的就是 set_ 函数中设置的值，这是符合预期的。但是我们在 get1 中将值重新设置了，那么之后不管是 await get1() 还是直接 await get2()，得到的都是新设置的值。</p>
<p>这也说明了，一个协程内部 await 另一个协程，另一个协程内部 await 另另一个协程，不管套娃（await）多少次，它们获取的值都是一样的。并且在任意一个协程内部都可以重新设置值，然后获取会得到最后一次设置的值。再举个栗子：</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;)

async def get1():
    return await get2()

async def get2():
    val = c.get() + &quot;~~~&quot;
    c.set(&quot;重新设置啦&quot;)
    return val

async def set_(val):
    # 设置值
    c.set(val)
    print(await get1())
    print(c.get())

async def main():
    coro = set_(&quot;古明地觉&quot;)
    await coro

asyncio.run(main())
&quot;&quot;&quot;
古明地觉~~~
重新设置啦
&quot;&quot;&quot;
</code></pre>
<p>await get1() 的时候会执行 await get2()，然后在里面拿到 c.set 设置的值，打印 &quot;古明地觉~~~&quot;。但是在 get2 里面，又将值重新设置了，所以第二个 print 打印的就是新设置的值。</p>
<p>如果在 get 之前没有先 set，那么会抛出一个 LookupError，所以 ContextVar 支持默认值。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;, default=&quot;哼哼&quot;)

async def set_(val):
    print(c.get())
    c.set(val)
    print(c.get())

async def main():
    coro = set_(&quot;古明地觉&quot;)
    await coro

asyncio.run(main())
&quot;&quot;&quot;
哼哼
古明地觉
&quot;&quot;&quot;
</code></pre>
<p>除了在 ContextVar 中指定默认值之外，也可以在 get 中指定。</p>
<pre><code class="language-python">import asyncio
import contextvars

c = contextvars.ContextVar(&quot;只是一个标识, 用于调试&quot;, default=&quot;哼哼&quot;)

async def set_(val):
    print(c.get(&quot;古明地恋&quot;))
    c.set(val)
    print(c.get())

async def main():
    coro = set_(&quot;古明地觉&quot;)
    await coro

asyncio.run(main())
&quot;&quot;&quot;
古明地恋
古明地觉
&quot;&quot;&quot;
</code></pre>
<p>所以结论如下，如果在 c.set 之前使用 c.get：</p>
<ul>
<li>当 ContextVar 和 get 中都没有指定默认值，会抛出 LookupError；</li>
<li>只要有一方设置了，那么会得到默认值；</li>
<li>如果都设置了，那么以 get 为准；</li>
</ul>
<p>如果 c.get 之前执行了 c.set，那么无论 ContextVar 和 get 有没有指定默认值，获取到的都是 c.set 设置的值。</p>
<p>所以总的来说还是比较好理解的，并且 ContextVar 除了可以作用在协程上面，它也可以用在线程上面。没错，它可以替代 threading.local，我们来试一下：</p>
<pre><code class="language-python">import threading
import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)

def get():
    name = threading.current_thread().name
    value = c.get()
    print(f&quot;线程 {name}, value: {value}&quot;)

def set_():
    name = threading.current_thread().name
    if name == &quot;one&quot;:
        c.set(&quot;ONE&quot;)
    elif name == &quot;two&quot;:
        c.set(&quot;TWO&quot;)
    get()

t1 = threading.Thread(target=set_, name=&quot;one&quot;)
t2 = threading.Thread(target=set_, name=&quot;two&quot;)
t1.start()
t2.start()
&quot;&quot;&quot;
线程 one, value: ONE
线程 two, value: TWO
&quot;&quot;&quot;
</code></pre>
<p>和 threading.local 的表现是一样的，但是更建议使用 ContextVars。不过前者可以绑定任意多个值，而后者只能绑定一个值（可以通过传递字典的方式解决这一点）。</p>
<h3 id="ctoken"><a class="header" href="#ctoken">c.Token</a></h3>
<p>当我们调用 c.set 的时候，其实会返回一个 Token 对象：</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)
print(token)
&quot;&quot;&quot;
&lt;Token var=&lt;ContextVar name='context_var' at 0x00..&gt; at 0x00...&gt;
&quot;&quot;&quot;
</code></pre>
<p>Token 对象有一个 var 属性，它是只读的，会返回指向此 token 的 ContextVar 对象。</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)

print(token.var is c)  # True
print(token.var.get())  # val

print(
    token.var.set(&quot;val2&quot;).var.set(&quot;val3&quot;).var is c
)  # True
print(c.get())  # val3
</code></pre>
<p>Token 对象还有一个 old_value 属性，它会返回上一次 set 设置的值，如果是第一次 set，那么会返回一个 &lt;Token.MISSING&gt;。</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)

# 该 token 是第一次 c.set 所返回的
# 在此之前没有 set，所以 old_value 是 &lt;Token.MISSING&gt;
print(token.old_value)  # &lt;Token.MISSING&gt;

token = c.set(&quot;val2&quot;)
print(c.get())  # val2
# 返回上一次 set 的值
print(token.old_value)  # val
</code></pre>
<p>那么这个 Token 对象有什么作用呢？从目前来看貌似没太大用处啊，其实它最大的用处就是和 reset 搭配使用，可以对状态进行重置。</p>
<pre><code class="language-python">import contextvars

c = contextvars.ContextVar(&quot;context_var&quot;)
token = c.set(&quot;val&quot;)
# 显然是可以获取的
print(c.get())  # val

# 将其重置为 token 之前的状态
# 但这个 token 是第一次 set 返回的
# 那么之前就相当于没有 set 了
c.reset(token)
try:
    c.get()  # 此时就会报错
except LookupError:
    print(&quot;报错啦&quot;)  # 报错啦

# 但是我们可以指定默认值
print(c.get(&quot;默认值&quot;))  # 默认值
</code></pre>
<h3 id="contextvarscontext"><a class="header" href="#contextvarscontext">contextvars.Context</a></h3>
<p>它负责保存 ContextVars 对象和设置的值之间的映射，但是我们不会直接通过 contextvars.Context 来创建，而是通过 contentvars.copy_context 函数来创建。</p>
<pre><code class="language-Python">import contextvars

c1 = contextvars.ContextVar(&quot;context_var1&quot;)
c1.set(&quot;val1&quot;)
c2 = contextvars.ContextVar(&quot;context_var2&quot;)
c2.set(&quot;val2&quot;)

# 此时得到的是所有 ContextVar 对象和设置的值之间的映射
# 它实现了 collections.abc.Mapping 接口
# 因此我们可以像操作字典一样操作它
context = contextvars.copy_context()
# key 就是对应的 ContextVar 对象，value 就是设置的值
print(context[c1])  # val1
print(context[c2])  # val2
for ctx, value in context.items():
    print(ctx.get(), ctx.name, value)
    &quot;&quot;&quot;
    val1 context_var1 val1
    val2 context_var2 val2
    &quot;&quot;&quot;

print(len(context))  # 2
</code></pre>
<p>除此之外，context 还有一个 run 方法：</p>
<pre><code class="language-python">import contextvars

c1 = contextvars.ContextVar(&quot;context_var1&quot;)
c1.set(&quot;val1&quot;)
c2 = contextvars.ContextVar(&quot;context_var2&quot;)
c2.set(&quot;val2&quot;)

context = contextvars.copy_context()

def change(val1, val2):
    c1.set(val1)
    c2.set(val2)
    print(c1.get(), context[c1])
    print(c2.get(), context[c2])

# 在 change 函数内部，重新设置值
# 然后里面打印的也是新设置的值
context.run(change, &quot;VAL1&quot;, &quot;VAL2&quot;)
&quot;&quot;&quot;
VAL1 VAL1
VAL2 VAL2
&quot;&quot;&quot;

print(c1.get(), context[c1])
print(c2.get(), context[c2])
&quot;&quot;&quot;
val1 VAL1
val2 VAL2
&quot;&quot;&quot;
</code></pre>
<p>我们看到 run 方法接收一个 callable，如果在里面修改了 ContextVar 实例设置的值，那么对于 ContextVar 而言只会在函数内部生效，一旦出了函数，那么还是原来的值。但是对于 Context 而言，它是会受到影响的，即便出了函数，也是新设置的值，因为它直接把内部的字典给修改了。</p>
<h2 id="小结-5"><a class="header" href="#小结-5">小结</a></h2>
<p>以上就是 contextvars 模块的用法，在多个协程之间传递数据是非常方便的，并且也是并发安全的。如果你用过 Go 的话，你应该会发现和 Go 在 1.7 版本引入的 context 模块比较相似，当然 Go 的 context 模块功能要更强大一些，除了可以传递数据之外，对多个 goroutine 的级联管理也提供了非常清蒸的解决方案。</p>
<p>然后需要强调一点，Python 的 context 是协程隔离的，我们只需要创建一个全局的 context 即可。比如协程 A 不断嵌套调用，最终调用了协程 F，但协程 F 需要使用协程 A 中的某个数据，那么这时候就可以在协程 A 中通过 context 设置数据，在协程 F 中通过 context 获取数据。</p>
<p>整个过程只需要一个 context 即可，并且也不需要手动传递 context（不然的话，还不如直接传个字典）。然后 context 是并发安全的，我们只需要一个全局的 context，需要用的时候直接导入即可。</p>
<p>当然啦，对于 contextvars 而言，它传递的数据应该是多个协程之间需要共享的数据，像 cookie, session, token 之类的，比如上游接收了一个 token，然后不断地向下透传。但是不要把本应该作为函数参数的数据，也通过 contextvars 来传递，这样就有点本末倒置了。</p>
<div style="break-before: page; page-break-before: always;"></div><p>当我们的程序报错时，解释器会将整个异常的堆栈信息全部输出出来，举个例子：</p>
<pre><code class="language-python">def foo():
    raise RuntimeError(&quot;抛一个异常&quot;)

def bar():
    foo()

def main():
    bar()

main()
</code></pre>
<p>如果执行这段代码，会得到以下报错信息：</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/./1.png" alt="" /></p>
<p>解释器会将异常产生的整个调用链都给打印出来，那么问题来了，我们能不能自定义这些报错信息呢？答案是可以的，我们只要拿到这些报错信息，然后再进行修改即可。那么如何才能拿到呢？显然需要借助于 traceback 对象。</p>
<pre><code class="language-python">import sys

def foo():
    raise RuntimeError(&quot;抛一个异常&quot;)

def bar():
    foo()

def main():
    bar()

try:
    main()
except Exception:
    # sys.exc_info() 返回一个元组，里面有三个元素
    # 分别是：异常类型、异常值、异常的堆栈信息
    exc_type, exc_val, exc_tb = sys.exc_info()

    print(exc_type)
    print(exc_val, type(exc_val))
    print(exc_tb)
    &quot;&quot;&quot;
    &lt;class 'RuntimeError'&gt;
    抛一个异常 &lt;class 'RuntimeError'&gt;
    &lt;traceback object at 0x7fe35811de40&gt;
    &quot;&quot;&quot;
</code></pre>
<p>每一个函数在运行时都会创建一个栈帧，栈帧在 CPython 里面由 PyFrameObject 结构体表示。同时每个栈帧都会对应一个 PyTracebackObject，也就是异常堆栈，即代码中的 exc_tb。</p>
<p>上面的代码在执行函数 foo 的时候出现了异常，那么解释器会创建对应的 traceback 对象，由于 foo 内部没有异常捕获，因此会回退到上一级栈帧，继续寻找异常捕获逻辑。而 foo 的上一级栈帧是 bar 的栈帧，因此解释器同样会基于 bar 的栈帧创建 traceback 对象，并且 bar 的 traceback 对象的 tb_next 指向 foo 的 traceback 对象。</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/./2.png" alt="" /></p>
<p>就这样栈帧一层层的回退，整个过程我们称之为栈帧展开。在栈帧展开的过程中，解释器不断地创建与各个栈帧对应的 traceback，并将其链接成链表。如果回退到最外层（模块）也没有找到异常捕获逻辑，那么解释器就要输出异常信息了，从模块对应的 traceback 开始不断遍历，将每一层信息都输出出来，就是我们看到的样子。</p>
<p>而我们也可以在拿到 traceback 之后，手动输出出来。</p>
<pre><code class="language-python">import sys
import traceback

def foo():
    raise RuntimeError(&quot;抛一个异常&quot;)

def bar():
    foo()

def main():
    bar()

try:
    main()
except Exception:
    exc_type, exc_val, exc_tb = sys.exc_info()
    error_msg = &quot;&quot;.join(
        traceback.format_exception(exc_type, exc_val, exc_tb)
    )
    print(error_msg)
&quot;&quot;&quot;
Traceback (most recent call last):
  File &quot;/Users/satori/Documents/testing_project/main.py&quot;, line 14, in &lt;module&gt;
    main()
  File &quot;/Users/satori/Documents/testing_project/main.py&quot;, line 11, in main
    bar()
  File &quot;/Users/satori/Documents/testing_project/main.py&quot;, line 8, in bar
    foo()
  File &quot;/Users/satori/Documents/testing_project/main.py&quot;, line 5, in foo
    raise RuntimeError(&quot;抛一个异常&quot;)
RuntimeError: 抛一个异常
&quot;&quot;&quot;    
</code></pre>
<p>Python 有一个标准模块也叫 traceback，使用它的 format_exception 函数，我们可以拿到格式化后的异常堆栈信息，而该函数接收的参数正是 exc_type, exc_val, exc_tb。</p>
<p>虽然目前拿到了异常的堆栈信息，但是还不够，因为这里是通过手动捕获异常的方式。而在生产上，很多时候我们并不知道哪里会抛出异常，所以我们需要在不使用异常捕获逻辑的前提下，自动捕获异常。是不是有点绕了呢？我们举个例子。</p>
<pre><code class="language-python">import sys

def catch(exc_type, exc_val, exc_tb):
    &quot;&quot;&quot;
    光看名字，就应该知道这三个参数的含义了
    &quot;&quot;&quot;
    print(&quot;报错啦&quot;)
    print(exc_val)

# 之后当出现异常的时候，如果没有异常捕获逻辑
# 就会执行 catch 函数
sys.excepthook = catch

raise ZeroDivisionError(&quot;除零错误&quot;)
&quot;&quot;&quot;
报错啦
除零错误
&quot;&quot;&quot;
</code></pre>
<p>代码中 raise 了一个异常，默认情况下解释器应该将异常输出到 stderr 当中，然后中止运行。但是我们替换了 sys.excepthook，那么在出现异常的时候，解释器会去执行我们这里替换之后的 catch 函数，并自动将 exc_type, exc_val, exc_tb 作为参数传进去。而一旦 cache 函数执行完毕，程序就结束了。</p>
<p>那么接下来我们就可以对异常输出进行改造了，至于怎么改，完全由你来决定，这里给个示例。</p>
<pre><code class="language-python">import sys
from io import StringIO
import re
import traceback
from rich import print

def catch(exc_type, exc_val, exc_tb):
    buf = StringIO()
    # 得到一个列表
    errors = traceback.format_exception(exc_type, exc_val, exc_tb)
    buf.write(f&quot;[blue]程序出现异常啦, 客官请看下面:\n\n&quot;)
    # 遍历
    i = 1
    while i &lt; len(errors):
        match = re.search(r'File &quot;(.+?)&quot;, line (\d+), in (.+)\s*(.*)', errors[i].strip())
        if match is not None:
            file_path, lineno, where, reason = match.groups()
            buf.write(
                f&quot;在文件 [red bold]{file_path}[/red bold] &quot;
                f&quot;[green bold]{where}[/green bold] 的&quot;
                f&quot;第 [yellow bold]{lineno}[/yellow bold] 行\n&quot;
            )
            buf.write(f&quot;执行了 {reason.strip()}\n\n&quot;)
        i += 1
    buf.write(f&quot;[cyan bold]{errors[-1].strip()}&quot;)
    print(buf.getvalue())

sys.excepthook = catch

def foo():
    # raise a exception
    {} + ()

def bar():
    foo()

def main():
    bar()

main()
</code></pre>
<p>我们执行这段代码，看看它的错误输出是什么样子。</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF/./3.png" alt="" /></p>
<p>怎么样，是不是很好玩呢？只要把 sys.excepthook = cache 这段逻辑加载到程序中，我们就可以自定义异常显示信息了。</p>
<p>当然啦，根据异常的不同，解释器可能输出更复杂的信息，所以我们上面的代码并不完善，但你可以根据实际情况进行修改。只要知道如何获取解释器输出的异常信息，以及 sys.excepthook 的用法就足够了。</p>
<p>最后再强调一下，解释器在发现异常的时候，会立即调用 sys.excepthook。而一旦调用结束，整个程序就结束了。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-7"><a class="header" href="#楔子-7">楔子</a></h2>
<p>我们用 MySQL 客户端查询数据的时候，会以表格的形式进行展示。而 Python 有一个第三方模块叫 prettytable，专门用来将数据以这种格式输出，我们来看一下用法。</p>
<h2 id="添加表头添加行添加列"><a class="header" href="#添加表头添加行添加列">添加表头、添加行、添加列</a></h2>
<p>类似于数据库中的表，由表头（或者说字段名），以及每一行的内容组成。</p>
<pre><code class="language-python">from prettytable import PrettyTable

# 传入的 name、age、country 相当于表头
tb = PrettyTable([&quot;name&quot;, &quot;age&quot;, &quot;country&quot;])
# 调用 add_row 添加行记录
tb.add_row([&quot;Jack Morrison&quot;, 49, &quot;America&quot;])
tb.add_row([&quot;Shimada Genji&quot;, 35, &quot;Japan&quot;])
tb.add_row([&quot;Shimada Hanzo&quot;, 38, &quot;Japan&quot;])
tb.add_row([&quot;Angela Ziegler&quot;, 37, &quot;Switzerland&quot;])

print(tb)
&quot;&quot;&quot;
+----------------+-----+-------------+
|      name      | age |   country   |
+----------------+-----+-------------+
| Jack Morrison  |  49 |   America   |
| Shimada Genji  |  35 |    Japan    |
| Shimada Hanzo  |  38 |    Japan    |
| Angela Ziegler |  37 | Switzerland |
+----------------+-----+-------------+
&quot;&quot;&quot;
</code></pre>
<p>如果在编写的过程中，我们需要临时添加一列，prettytable 也是支持的。</p>
<pre><code class="language-python">from prettytable import PrettyTable

tb = PrettyTable([&quot;name&quot;, &quot;age&quot;, &quot;country&quot;])
tb.add_row([&quot;Jack Morrison&quot;, 49, &quot;America&quot;])
tb.add_row([&quot;Shimada Genji&quot;, 35, &quot;Japan&quot;])
tb.add_row([&quot;Shimada Hanzo&quot;, 38, &quot;Japan&quot;])
tb.add_row([&quot;Angela Ziegler&quot;, 37, &quot;Switzerland&quot;])

# 调用 add_column 添加一列
tb.add_column(&quot;gender&quot;, [&quot;male&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;])
print(tb)
&quot;&quot;&quot;
+----------------+-----+-------------+--------+
|      name      | age |   country   | gender |
+----------------+-----+-------------+--------+
| Jack Morrison  |  49 |   America   |  male  |
| Shimada Genji  |  35 |    Japan    |  male  |
| Shimada Hanzo  |  38 |    Japan    |  male  |
| Angela Ziegler |  37 | Switzerland | female |
+----------------+-----+-------------+--------+
&quot;&quot;&quot;
</code></pre>
<p>输出内容是不是和 MySQL数据库类似呢。</p>
<p>此外 prettytable 还支持从 csv、数据库、html 等数据源中导入数据，但说实话，从数据源读取数据我们一般使用 pandas，并且还会伴随着数据处理。而使用 prettytable 只是为了让程序中产生的信息，能够以结构化的形式打印，很少会从文件或数据库里面读数据。</p>
<h2 id="输出指定行指定列"><a class="header" href="#输出指定行指定列">输出指定行、指定列</a></h2>
<p>我们也可以输出 table 的指定行、指定列。</p>
<pre><code class="language-python">from prettytable import PrettyTable

tb = PrettyTable([&quot;name&quot;, &quot;age&quot;, &quot;country&quot;, &quot;gender&quot;])
tb.add_row([&quot;Jack Morrison&quot;, 49, &quot;America&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Genji&quot;, 35, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Hanzo&quot;, 38, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Angela Ziegler&quot;, 37, &quot;Switzerland&quot;, &quot;female&quot;])
# 只输出 name 和 age 两列
# start 和 end 表示开始和结束的行数（从 0 开始）
print(tb.get_string(fields=[&quot;name&quot;, &quot;age&quot;], start=1, end=3))
&quot;&quot;&quot;
+---------------+-----+
|      name     | age |
+---------------+-----+
| Shimada Genji |  35 |
| Shimada Hanzo |  38 |
+---------------+-----+
&quot;&quot;&quot;

# 此外可以用来进行排序
print(tb.get_string(sortby=&quot;age&quot;, reversesort=True))
&quot;&quot;&quot;
+----------------+-----+-------------+--------+
|      name      | age |   country   | gender |
+----------------+-----+-------------+--------+
| Jack Morrison  |  49 |   America   |  male  |
| Shimada Hanzo  |  38 |    Japan    |  male  |
| Angela Ziegler |  37 | Switzerland | female |
| Shimada Genji  |  35 |    Japan    |  male  |
+----------------+-----+-------------+--------+
&quot;&quot;&quot;
</code></pre>
<h2 id="设置表格样式"><a class="header" href="#设置表格样式">设置表格样式</a></h2>
<p>表格也支持几种不同的样式，供我们选择。</p>
<pre><code class="language-python">from prettytable import *

tb = PrettyTable([&quot;name&quot;, &quot;age&quot;, &quot;country&quot;, &quot;gender&quot;])
tb.add_row([&quot;Jack Morrison&quot;, 49, &quot;America&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Genji&quot;, 35, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Hanzo&quot;, 38, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Angela Ziegler&quot;, 37, &quot;Switzerland&quot;, &quot;female&quot;])

# 样式支持以下几种：
# DEFAULT、MSWORD_FRIENDLY、PLAIN_COLUMNS、RANDOM
# 之前的样式就是 DEFAULT
tb.set_style(MSWORD_FRIENDLY)
print(tb)
&quot;&quot;&quot;
|      name      | age |   country   | gender |
| Jack Morrison  |  49 |   America   |  male  |
| Shimada Genji  |  35 |    Japan    |  male  |
| Shimada Hanzo  |  38 |    Japan    |  male  |
| Angela Ziegler |  37 | Switzerland | female |
&quot;&quot;&quot;

tb.set_style(PLAIN_COLUMNS)
print(tb)
&quot;&quot;&quot;
     name             age          country          gender        
Jack Morrison          49          America           male         
Shimada Genji          35           Japan            male         
Shimada Hanzo          38           Japan            male         
Angela Ziegler         37        Switzerland        female     
&quot;&quot;&quot;

tb.set_style(RANDOM)
print(tb)
&quot;&quot;&quot;
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++;
.        name              age           country           gender     .
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++;
.   Jack Morrison           49           America            male      .
.   Shimada Genji           35            Japan             male      .
.   Shimada Hanzo           38            Japan             male      .
.   Angela Ziegler          37         Switzerland         female     .
;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++;
&quot;&quot;&quot;
</code></pre>
<p>说实话，还是默认的 DEFAULT 样式最好看。</p>
<h2 id="设置对齐方式"><a class="header" href="#设置对齐方式">设置对齐方式</a></h2>
<pre><code class="language-python">from prettytable import *

tb = PrettyTable([&quot;name&quot;, &quot;age&quot;, &quot;country&quot;, &quot;gender&quot;])
tb.add_row([&quot;Jack Morrison&quot;, 49, &quot;America&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Genji&quot;, 35, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Hanzo&quot;, 38, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Angela Ziegler&quot;, 37, &quot;Switzerland&quot;, &quot;female&quot;])

# l 代表左对齐，c 代表居中，r 代表右对齐
# 默认居中
tb.align[&quot;name&quot;] = &quot;l&quot;
tb.align[&quot;age&quot;] = &quot;c&quot;
tb.align[&quot;country&quot;] = &quot;r&quot;
print(tb)
&quot;&quot;&quot;
+----------------+-----+-------------+--------+
| name           | age |     country | gender |
+----------------+-----+-------------+--------+
| Jack Morrison  |  49 |     America |  male  |
| Shimada Genji  |  35 |       Japan |  male  |
| Shimada Hanzo  |  38 |       Japan |  male  |
| Angela Ziegler |  37 | Switzerland | female |
+----------------+-----+-------------+--------+
&quot;&quot;&quot;
</code></pre>
<h2 id="设置边框样式"><a class="header" href="#设置边框样式">设置边框样式</a></h2>
<p>在 PrettyTable 中，边框由三个部分组成：横边框，竖边框，和边框连接符，我们都可以修改。</p>
<pre><code class="language-python">from prettytable import *

tb = PrettyTable([&quot;name&quot;, &quot;age&quot;, &quot;country&quot;, &quot;gender&quot;])
tb.add_row([&quot;Jack Morrison&quot;, 49, &quot;America&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Genji&quot;, 35, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Shimada Hanzo&quot;, 38, &quot;Japan&quot;, &quot;male&quot;])
tb.add_row([&quot;Angela Ziegler&quot;, 37, &quot;Switzerland&quot;, &quot;female&quot;])

# 是否显示边框，默认为True
tb.border = True
# 横边框
tb.horizontal_char = '^'
# 竖边框
tb.vertical_char = '&gt;'
# 边框连接符
tb.junction_char='~'

print(tb)
&quot;&quot;&quot;
~^^^^^^^^^^^^^^^^~^^^^^~^^^^^^^^^^^^^~^^^^^^^^~
&gt;      name      &gt; age &gt;   country   &gt; gender &gt;
~^^^^^^^^^^^^^^^^~^^^^^~^^^^^^^^^^^^^~^^^^^^^^~
&gt; Jack Morrison  &gt;  49 &gt;   America   &gt;  male  &gt;
&gt; Shimada Genji  &gt;  35 &gt;    Japan    &gt;  male  &gt;
&gt; Shimada Hanzo  &gt;  38 &gt;    Japan    &gt;  male  &gt;
&gt; Angela Ziegler &gt;  37 &gt; Switzerland &gt; female &gt;
~^^^^^^^^^^^^^^^^~^^^^^~^^^^^^^^^^^^^~^^^^^^^^~
&quot;&quot;&quot;
</code></pre>
<h2 id="小结-6"><a class="header" href="#小结-6">小结</a></h2>
<p>以上就是 PrettyTable 相关的内容，大部分情况下我们使用默认的样式即可。</p>
<div style="break-before: page; page-break-before: always;"></div><p>几年前在 B 站上看到了一个宝藏 up 主，名叫 &quot;Jannchie见齐&quot;，专门做动态条形图样式的数据可视化。</p>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./1.png" alt="" /></p>
<p>做出的效果还是很不错的，但工具使用的是 JS，不是 Python。于是尝试搜索了一下，看看 Python 有没有相关的库，也能轻松做出动态条形图的效果。幸运的是还真有相关的库，叫 bar_chart_race，那么下面就来看看它的用法。</p>
<p>老规矩，使用之前先安装，直接 pip install bar-chart-race 即可。</p>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

# 如果出现SSL错误, 则全局取消证书验证
&quot;&quot;&quot;
import ssl
ssl._create_default_https_context = \
  ssl._create_unverified_context
&quot;&quot;&quot;  

# 获取数据
df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
# 生成 GIF 图像
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;)
</code></pre>
<p>我们看到代码非常简单，就是将数据转成 pandas 的 DataFrame，然后调用 bar_chart_race 即可生成 GIF 图像。</p>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./2.gif" alt="" /></p>
<p>整体还是不错的，然后重点来看一下数据：</p>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./3.png" alt="" /></p>
<p>其中表头就是 GIF 图表中 Y 轴的部分，但要注意的是，我们的图表是随时间不断变化的，所以在生成 DataFrame 的时候必须将 date 字段设置为索引。然后数据随着时间不断变化，条形图之间会根据数据的大小进行排序。</p>
<p>当然了，以上只是默认生成的，bar_chart_race 里面还有很多的参数，我们来看一下。</p>
<h3 id="动态条形图变动态柱状图"><a class="header" href="#动态条形图变动态柱状图">动态条形图变动态柱状图</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, orientation='v')
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./4.gif" alt="" /></p>
<p>我们看到为了避免文字发生重叠，自动倾斜了，所以还是比较人性化的。</p>
<h3 id="指定排序方式"><a class="header" href="#指定排序方式">指定排序方式</a></h3>
<p>排序方式默认为降序，也可以指定为升序。</p>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, sort=&quot;asc&quot;)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./5.gif" alt="" /></p>
<h3 id="限制条目数"><a class="header" href="#限制条目数">限制条目数</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, n_bars=6)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./6.gif" alt="" /></p>
<h3 id="设置固定条目"><a class="header" href="#设置固定条目">设置固定条目</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
# 选取如下 5 个国家的数据
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, 
                   fixed_order=[&quot;Iran&quot;, &quot;USA&quot;, &quot;Italy&quot;, &quot;Spain&quot;, &quot;Belgium&quot;])
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./7.gif" alt="" /></p>
<h3 id="固定数值轴使其不发生动态变化"><a class="header" href="#固定数值轴使其不发生动态变化">固定数值轴，使其不发生动态变化</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
# 设置数值的最大值，固定数值轴
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, fixed_max=True)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./8.gif" alt="" /></p>
<h3 id="设置图像帧数默认-10-帧"><a class="header" href="#设置图像帧数默认-10-帧">设置图像帧数，默认 10 帧</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
# 设置数值的最大值，固定数值轴
# 图像帧数：数值越小，越不流畅；越大，越流畅
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, steps_per_period=3)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./9.gif" alt="" /></p>
<p>可以看到，动图变得不流畅了。</p>
<h3 id="设置帧率单位时间默认为-500ms"><a class="header" href="#设置帧率单位时间默认为-500ms">设置帧率，单位时间默认为 500ms</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
# 设置帧率为 200ms，总共 20 帧
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;,  steps_per_period=20, period_length=200)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./10.gif" alt="" /></p>
<h3 id="设置每帧增加的标签时间默认为-false"><a class="header" href="#设置每帧增加的标签时间默认为-false">设置每帧增加的标签时间，默认为 False</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;,  interpolate_period=True)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./11.gif" alt="" /></p>
<h3 id="图形样式设置"><a class="header" href="#图形样式设置">图形样式设置</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
&quot;&quot;&quot;
figsize: 设置画布大小，默认 (6, 3.5)
dpi: 图像分辨率，默认 144
label_bars: 显示柱状图的数值信息，默认为 True；
            指定为 False 则不显示；指定为字典，则自定义显示属性
period_label: 显示时间标签信息，默认为 True；
              指定为 False 则不显示；指定为字典，则自定义显示属性
period_fmt: 设置日期格式
title: 图表标题
title_size: 标题字体大小
shared_fontdict: 全局字体属性，例如 
                 {'family': 'Helvetica', 'weight': 'bold', 
                  'color': 'rebeccapurple'}
&quot;&quot;&quot;
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, figsize=(5, 3), 
                   dpi=100, label_bars=False,
                   period_label={&quot;x&quot;: .99, &quot;y&quot;: .1,
                                 &quot;ha&quot;: &quot;right&quot;, &quot;color&quot;: &quot;red&quot;},
                   title='COVID-19 Deaths by Country')
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./12.gif" alt="" /></p>
<h3 id="条形图属性可以设置透明度边框等"><a class="header" href="#条形图属性可以设置透明度边框等">条形图属性，可以设置透明度，边框等</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])
# bar_kwargs：条形图属性
bcr.bar_chart_race(df, &quot;covid19_horiz.gif&quot;, 
                   bar_kwargs={&quot;alpha&quot;: .2, &quot;ec&quot;: &quot;black&quot;, &quot;lw&quot;: 3})
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./13.gif" alt="" /></p>
<h3 id="添加动态文本"><a class="header" href="#添加动态文本">添加动态文本</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr
import matplotlib.pyplot as plt

# 设置字体，否则无法显示中文
# plt.rcParams['font.sans-serif'] = ['SimHei']  # Windows
plt.rcParams['font.sans-serif'] = ['Hiragino Sans GB'] # Mac
plt.rcParams['axes.unicode_minus'] = False

df = pd.read_csv(&quot;covid19_tutorial.csv&quot;, index_col=[&quot;date&quot;])

def summary(values, ranks):
    # 动态文本的内容
    &quot;&quot;&quot;
    values 为 df 的每一行（Series），例如
        Belgium            1143.0
        China              3326.0
        France             6520.0
        Germany            1275.0
        Iran               3294.0
        Italy             14681.0
        Netherlands        1490.0
        Spain             11198.0
        USA                7418.0
        United Kingdom     3611.0
        Name: 2020-04-03, dtype: float64

    ranks 则是针对 values 的值进行了排名，例如
        Belgium            1.0
        China              5.0
        France             7.0
        Germany            2.0
        Iran               4.0
        Italy             10.0
        Netherlands        3.0
        Spain              9.0
        USA                8.0
        United Kingdom     6.0
        Name: 2020-04-03, dtype: float64
    &quot;&quot;&quot;
    all_people = int(values.sum())
    ranks_country = ranks.sort_values().index
    s = (f'总死亡人数：{all_people}，'
         f'死亡人数最多的国家：{ranks_country[-1]}，'
         f'死亡人数最少的国家：{ranks_country[0]}')
    # 设置文本位置、数值、大小、颜色等
    return {'x': .99, 'y': .05, 's': s,
            'ha': 'right', 'size': 8}

# 添加文本
bcr.bar_chart_race(df, 'covid19_horiz.gif', period_summary_func=summary)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./14.gif" alt="" /></p>
<h3 id="添加垂直条"><a class="header" href="#添加垂直条">添加垂直条</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv('covid19_tutorial.csv', index_col=[&quot;date&quot;])
# 设置垂直条数值，分位数
def func(values, ranks):
    return values.quantile(.9)
# 添加垂直条
bcr.bar_chart_race(df, 'covid19_horiz.gif', perpendicular_bar_func=func)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./15.gif" alt="" /></p>
<h3 id="设置柱状图颜色"><a class="header" href="#设置柱状图颜色">设置柱状图颜色</a></h3>
<pre><code class="language-python">import pandas as pd
import bar_chart_race as bcr

df = pd.read_csv('covid19_tutorial.csv', index_col=[&quot;date&quot;])
&quot;&quot;&quot;
# 具体有哪些颜色，可以通过如下方式查看
from bar_chart_race._colormaps import colormaps
print(list(colormaps.keys()))
&quot;&quot;&quot;
bcr.bar_chart_race(df, 'covid19_horiz.gif', cmap=&quot;plotly3&quot;)
</code></pre>
<p><img src="%E8%BD%BB%E6%9D%BE%E7%BB%98%E5%88%B6%E5%8A%A8%E6%80%81%E6%9D%A1%E5%BD%A2%E5%9B%BE/./16.gif" alt="" /></p>
<p>以上就是绝大部分配置，当然源码中注释写的也比较详细，可以点进去看一下。</p>
<div style="break-before: page; page-break-before: always;"></div><p>相信大家都用过 jupyter，也用过里面的魔法命令，这些魔法命令都以 % 或者 %% 开头，我们举个例子。</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./1.png" alt="" /></p>
<p>用法还是比较简单的，但是我们能不能自定义魔法命令呢？毫无疑问是可以的，因为上面的 %%cython 就是 Cython 模块自定义的。</p>
<p>所以命令可以是 jupyter 内置的，比如 %time，直接拿来就能用；还可以是第三方模块里面的，在 jupyter 通过 %load_ext 加载之后，再嵌入进来。下面就来看看如何自定义魔法命令。</p>
<pre><code class="language-python">from IPython.core.magic import (
    magics_class,
    Magics,
    line_magic,
    cell_magic
)


@magics_class
class MagicOrder(Magics):
    &quot;&quot;&quot;
    自定义一个类，类名叫什么无所谓
    但要继承 Magics，并且要被 magics_class 装饰
    &quot;&quot;&quot;

    @line_magic
    def hello(self, line):
        &quot;&quot;&quot;
        在 jupyter 中就可以使用如下命令，比如：
        %hello &lt;Your Code&gt;，然后就会调用这个 hello 方法
        参数 line 就是 %hello 后面的代码
        &quot;&quot;&quot;
        print(f&quot;line: {line}&quot;)

    @cell_magic
    def world(self, line, cell):
        &quot;&quot;&quot;
        在 jupyter 中就可以使用如下命令，比如：
        %%world
        &lt;Your Code&gt;
        &lt;Your Code&gt;
        ...

        然后就会调用这个 world 方法
        参数 cell 就是 %%world 下面整个单元格的代码

        然后还有一个参数 line，它表示 %%world 所在行后面的代码
        但对于 %% 开头的命令来说，我们一般都会新起一行，然后写代码
        所以 line 这个参数暂时用不到
        &quot;&quot;&quot;
        print(f&quot;line: \n{line}&quot;)
        print(&quot;-----------------&quot;)
        print(f&quot;cell: \n{cell}&quot;)


# 必须定义 load_ipython_extension 函数
# %load_ext 本质上也是加载一个模块，但它会自动调用该函数
def load_ipython_extension(ip):
    # 在函数内部，我们将类 MagicOrder 注册进去
    # 然后就可以使用它内部的魔法命令了
    ip.register_magics(MagicOrder)

# 如果不定义此函数，那么使用 %load_ext 加载时会报错
# The xxx module is not an IPython extension.
</code></pre>
<p>当前模块叫 main.py，我们来测试一下：</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./2.png" alt="" /></p>
<p>结果没有问题，但说实话对于 %% 开头的命令来说，我们很少会在它后面写代码，基本都是新起一行，就像下面这个样子。</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./3.png" alt="" /></p>
<p>自定义命令我们已经实现了，并且也知道怎么获取输入的代码了，下面要做的就是执行它。而将字符串当成代码执行，我们可以使用内置函数 exec。</p>
<pre><code class="language-python">@magics_class
class MagicOrder(Magics):

    @line_magic
    def hello(self, line):
        exec(line)

    @cell_magic
    def world(self, line, cell):
        exec(cell)
</code></pre>
<p>代码的其它部分不变，然后你觉得接下来调用魔法命令会执行成功吗？我们测试一下。注意：要重启内核。</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./4.png" alt="" /></p>
<p>神奇的地方出现了，虽然命令执行成功了，但执行完之后，告诉我们变量未定义。其实原因很好想，我们调用 exec 的时候没有指定名字空间，那么默认会影响 exec 函数所在的名字空间，即 hello 和 world 函数的名字空间。</p>
<p>当打开一个 jupyter 的时候，内部相当于启动了一个 shell，所以在调用 exec 的时候，应该将整个 shell 的名字空间传进去。</p>
<pre><code class="language-python">from IPython.core.magic import (
    magics_class,
    Magics,
    line_magic,
    cell_magic,
    needs_local_scope
)


@magics_class
class MagicOrder(Magics):

    @line_magic
    def hello(self, line):
        # 通过 self.shell.user_ns，可以拿到当前 shell 的名字空间
        # 注意：包含所有的单元格
        local_ns = self.shell.user_ns
        # 在 local_ns 当中执行代码
        exec(line, local_ns, local_ns)

    @needs_local_scope
    @cell_magic
    def world(self, line, cell, local_ns):
        # 或者通过 needs_local_scope 装饰器
        # 这样在调用函数的时候，会额外传递一个 local_ns 参数
        # 该参数和 self.shell.user_ns 等价
        exec(cell, local_ns, local_ns)

def load_ipython_extension(ip):
    ip.register_magics(MagicOrder)
</code></pre>
<p>然后再来测试一下：</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./5.png" alt="" /></p>
<p>此时就没有任何问题了。</p>
<p>下面我们模仿 jupyter 的 %time 命令，实现一个 %my_time，来加深一遍印象。</p>
<pre><code class="language-python">@magics_class
class MagicOrder(Magics):

    @needs_local_scope
    @line_magic
    def my_time(self, line, local_ns):
        start = time.perf_counter()
        exec(line, local_ns, local_ns)
        end = time.perf_counter()
        print(f&quot;总耗时: {round(end - start, 3)}&quot;)
</code></pre>
<p>测试一下：</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./6.png" alt="" /></p>
<p>结果没有问题，是我们想要的结果。</p>
<p>最后再来看看如何设置可选参数，举一个 Cython 的例子：</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./7.png" alt="" /></p>
<p>我们说对于以 %% 开头的命令，应该新起一行，在它的下面写代码。而之所以新起一行，是因为命令所在的行，要用于设置可选参数。那么问题来了，如何设置指定的可选参数呢？</p>
<pre><code class="language-python">from IPython.core.magic import (
    magics_class,
    Magics,
    cell_magic,
    needs_local_scope
)
from IPython.core import magic_arguments


@magics_class
class MagicOrder(Magics):
    @magic_arguments.magic_arguments()
    # 在 jupyter 中可以通过 -n=xxx 或者 --name=xxx
    # 然后是 dest=&quot;name&quot;，用于指定参数的名字
    # 后续便可以通过 name 字段来获取该参数的值
    @magic_arguments.argument(
        &quot;-n&quot;, &quot;--name&quot;, dest=&quot;name&quot;, default=&quot;satori&quot;
    )
    # &quot;-&quot; 和 &quot;--&quot; 可以只出现一个，并且默认解析得到的是字符串
    # 而 age 我们希望是整数，所以指定 type 为 int
    # 解析完参数之后，会自动调用 int 进行转化
    # 如果不指定该参数，则使用 default
    # 而这里没有 default，那么结果就是 None
    @magic_arguments.argument(
        &quot;--age&quot;, dest=&quot;age&quot;, type=int
    )
    @magic_arguments.argument(
        &quot;-h&quot;, &quot;--hobby&quot;, dest=&quot;hobby&quot;, default=[],
        action=&quot;append&quot;
    )
    @needs_local_scope
    @cell_magic
    def order(self, line, cell, local_ns):
        # 显然 line 就是可选参数，cell 就是代码块
        exec(cell, local_ns, local_ns)
        # 解析参数
        args = magic_arguments.parse_argstring(self.order, line)
        # 打印
        print(args)


def load_ipython_extension(ip):
    ip.register_magics(MagicOrder)
</code></pre>
<p>我们测试一下：</p>
<p><img src="%E8%87%AA%E5%AE%9A%E4%B9%89%20jupyter%20%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/./8.png" alt="" /></p>
<p>还是很简单的，而且这里的参数解析和 argparse 模块非常类似，可以自己看一下。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-8"><a class="header" href="#楔子-8">楔子</a></h2>
<p>在开发过程中，配置文件是少不了的，只不过我们有时会将 py 文件作为配置文件（config.py），然后在其它的模块中直接导入。这样做是一个好主意，不过配置文件是有专门的格式的，比如：ini, yaml, toml 等等。</p>
<p>而对于 Python 而言，也都有相应的库来解析相应格式的文件，下面来看一看。</p>
<h2 id="ini-文件"><a class="header" href="#ini-文件">ini 文件</a></h2>
<p>先来了解一下 ini 文件的格式：</p>
<pre><code class="language-ini">[satori]
name = 古明地觉
age = 16
where = 东方地灵殿

[koishi]
name = 古明地恋
age = 15
where = 东方地灵殿

[marisa]
name = 雾雨魔理沙
age = 17
where = 魔法森林

; 以分号或井号开头表示注释，不影响
</code></pre>
<p>ini 文件总分可以分为三块，分别是：</p>
<ul>
<li>section：就是写在 [] 里面的内容，可以把它理解为一个段；</li>
<li>parameter：以 key = value 的形式出现，比如 age = 16，那么 age 就是 key、16 就是 value，注意：每个 section 都有自己的 parameter；</li>
<li>注释：以分号开头，无影响，会被忽略掉。</li>
</ul>
<p>可以看到结构还是比较清晰的，那么 Python 要如何解析呢？Python 解析 ini 文件需要使用一个名叫 configparser 的库，这个库是自带的，我们可以直接用。</p>
<pre><code class="language-python">import configparser

# 实例化一个 ConfigParser 实例
config = configparser.ConfigParser()
# 打开 ini 文件
config.read(&quot;cfg.ini&quot;, encoding=&quot;utf-8&quot;)

# 获取所有的 section
print(config.sections())
&quot;&quot;&quot;
['satori', 'koishi', 'marisa']
&quot;&quot;&quot;

# 获取某一个 section 的所有 parameter
print(config[&quot;satori&quot;])
&quot;&quot;&quot;
&lt;Section: satori&gt;
&quot;&quot;&quot;

# 我们可以像操作字典一样操作 parameter
print(list(config[&quot;satori&quot;]))
&quot;&quot;&quot;
['name', 'age', 'where']
&quot;&quot;&quot;
print(list(config[&quot;satori&quot;].values()))
&quot;&quot;&quot;
['古明地觉', '16', '东方地灵殿']
&quot;&quot;&quot;
print(list(config[&quot;satori&quot;].items()))
&quot;&quot;&quot;
[('name', '古明地觉'), ('age', '16'), ('where', '东方地灵殿')]
&quot;&quot;&quot;
# 获取某个 key 对应的 value
# 如果 key 不存在则抛出 KeyError
print(config[&quot;marisa&quot;][&quot;where&quot;])
&quot;&quot;&quot;
魔法森林
&quot;&quot;&quot;
# 也可以调用 get 方法
# 在 key 不存在时，指定一个默认值
print(config[&quot;marisa&quot;].get(&quot;age&quot;))
&quot;&quot;&quot;
17
&quot;&quot;&quot;
# 我们发现 age 居然是一个字符串
# 因为默认解析得到的都是字符串
print(config[&quot;marisa&quot;][&quot;age&quot;].__class__)
&quot;&quot;&quot;
&lt;class 'str'&gt;
&quot;&quot;&quot;

# 可以通过 getint 获取
# 会将 value 转成整型，但转化失败的话会报错
# 除了 getint 之外，还有 getfloat、getboolean
print(config[&quot;marisa&quot;].getint(&quot;age&quot;) == 17)
&quot;&quot;&quot;
True
&quot;&quot;&quot;

# 最后也可以直接转成字典
print(dict(config[&quot;koishi&quot;]))
&quot;&quot;&quot;
{'name': '古明地恋', 'age': '15', 'where': '东方地灵殿'}
&quot;&quot;&quot;
print(dict(config))
&quot;&quot;&quot;
{'DEFAULT': &lt;Section: DEFAULT&gt;, 
 'satori': &lt;Section: satori&gt;, 
 'koishi': &lt;Section: koishi&gt;, 
 'marisa': &lt;Section: marisa&gt;}
&quot;&quot;&quot;
print({k: dict(v) for k, v in config.items()})
&quot;&quot;&quot;
{'DEFAULT': {}, 
 'satori': {'name': '古明地觉', 
            'age': '16', 
            'where': '东方地灵殿'}, 
 'koishi': {'name': '古明地恋', 
            'age': '15', 
            'where': '东方地灵殿'}, 
 'marisa': {'name': '雾雨魔理沙', 
            'age': '17', 
            'where': '魔法森林'}}
&quot;&quot;&quot;
</code></pre>
<p>可以看到还是比较容易的，因为 ini 这种文件格式本身就很简单。除了读取文件，我们还可以进行写入。</p>
<pre><code class="language-python">import configparser

# 实例化一个 ConfigParser 类的实例
config = configparser.ConfigParser()
config[&quot;basic&quot;] = {&quot;Host&quot;: &quot;127.0.0.1&quot;,
                   &quot;Port&quot;: &quot;8888&quot;,
                   &quot;Username&quot;: &quot;satori&quot;}

config[&quot;thread&quot;] = {}
config[&quot;thread&quot;][&quot;name&quot;] = &quot;my_thread&quot;
config[&quot;thread&quot;][&quot;num&quot;] = &quot;3&quot;

with open(&quot;cfg.ini&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
    config.write(f)
</code></pre>
<p><img src="%E8%A7%A3%E6%9E%90%20ini%E3%80%81yaml%E3%80%81toml%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/./1.png" alt="" /></p>
<p>虽然成功写入了，但是我们看到结果变成了小写。是的，对于 parameter 来说，无论是大写还是小写，写入文件的时候都会变成小写。然后读取也是，无论 ini 文件中是大写还是小写，读取之后都会变成小写。</p>
<blockquote>
<p>注意：大小写不敏感只是针对于 parameter，对于 section 来说还是区分大小写的。</p>
</blockquote>
<h3 id="特殊格式"><a class="header" href="#特殊格式">特殊格式</a></h3>
<p>我们上面配置的 parameter 中的 key, value 都是一个普通的单词，但其实还可以配置的更加复杂一些。</p>
<p><img src="%E8%A7%A3%E6%9E%90%20ini%E3%80%81yaml%E3%80%81toml%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/./2.png" alt="" /></p>
<p>我们操作一波，看看能否正常解析。</p>
<pre><code class="language-python">import configparser

# 实例化一个 ConfigParser 实例
config = configparser.ConfigParser()
# 打开 ini 文件
config.read(&quot;cfg.ini&quot;, encoding=&quot;utf-8&quot;)

print(dict(config[&quot;简单值&quot;]))
&quot;&quot;&quot;
{'键': '值', 
 '键 里面 有空格': '合法', 
 '值 里面 有空格': '也 合 法', 
 '等号 周围 有 空格': '仍然合法', 
 '你也使用': '代替等号'}
&quot;&quot;&quot;

print(dict(config[&quot;所有值都是字符串&quot;]))
&quot;&quot;&quot;
{'这是字符串': '123', 
 '这也是字符串': '3.14', 
 '整数、浮点数、布尔值都是字符串': 'true'}
&quot;&quot;&quot;
# true True yes 都可以转成布尔值 True
# false False no 都可以转成布尔值 False
print(config[&quot;所有值都是字符串&quot;].getboolean(
    '整数、浮点数、布尔值都是字符串'))
&quot;&quot;&quot;
True
&quot;&quot;&quot;

print(dict(config[&quot;值占多行&quot;]))
&quot;&quot;&quot;
{'洪世贤': '你怎么穿品如的衣服啊\n还用人东西'}
&quot;&quot;&quot;

print(dict(config[&quot;值为空字符串&quot;]))
&quot;&quot;&quot;
{'key1': '', 'key2': ''}
&quot;&quot;&quot;
</code></pre>
<p>结果是正常的，但是很明显上面这种做法有点闲的没事了，以后就统一写成 key = value 的形式即可。另外如果 ini 文件中只有 key 没有 value 的话，默认是报错的，但可以通过一个参数改变这一点：</p>
<pre><code class="language-python">import configparser

# &quot;key =&quot; 这种形式不叫没有值，它是有值的，值为空字符串
# &quot;key&quot; 这种形式才是没有值，解析的时候默认会报错
# 可以通过一个参数改变这一点
config = configparser.ConfigParser(allow_no_value=True)
config.read_string(
    &quot;&quot;&quot;
[mysqld]
user = mysql
skip-bdb
&quot;&quot;&quot;)
print(dict(config[&quot;mysqld&quot;]))
&quot;&quot;&quot;
{'user': 'mysql', 'skip-bdb': None}
&quot;&quot;&quot;
</code></pre>
<p>除此之外，key 之间还可以发生引用。</p>
<pre><code class="language-python">import configparser

config = configparser.ConfigParser()

# 可以通过 %(key)s 的方式对同一个 section 中的其它 key 进行引用
# 所以如果想表示一个 % 的话，需要写两个 %，因为涉及到转义
config.read_string(&quot;&quot;&quot;
[section1]
user = 古明地觉
age = 16
info = %(user)s--%(age)s 
percent = 80%% 
&quot;&quot;&quot;)

print(dict(config[&quot;section1&quot;]))
&quot;&quot;&quot;
{'user': '古明地觉', 'age': '16', 
 'info': '古明地觉--16', 'percent': '80%'}
&quot;&quot;&quot;
</code></pre>
<p>还是很简单的，如果想引用其它的 section 中的 key 要怎么做呢？</p>
<pre><code class="language-python">import configparser

# 指定该参数之后，我们就不能通过 %(age)s 的方式引用了
# 需要使用 ${age} 这种格式，显然更方便了
config = configparser.ConfigParser(
    interpolation=configparser.ExtendedInterpolation()
)

config.read_string(&quot;&quot;&quot;
[DEFAULT]
默认的 = 自动加入到每一个 section 中

[section1]
user = 古明地觉
age = 16
info = ${user} -- ${age} 

[section2]
info = ${section1:user}, ${section1:age}
&quot;&quot;&quot;)

print(dict(config[&quot;section1&quot;]))
&quot;&quot;&quot;
{'user': '古明地觉', 
 'age': '16', 
 'info': '古明地觉 -- 16', 
 '默认的': '自动加入到每一个 section 中'}
&quot;&quot;&quot;
print(dict(config[&quot;section2&quot;]))
&quot;&quot;&quot;
{'info': '古明地觉, 16', 
 '默认的': '自动加入到每一个 section 中'}
&quot;&quot;&quot;
</code></pre>
<p>以上就是 ini 文件的一些简单用法，以后我们在写配置的时候，不妨使用一些专门用来表示配置的文件格式，不一定非要写在 py 文件里面。</p>
<p>而且使用 ini 等配置文件的一个好处就是，即便不懂 Python 的人也能看懂；或者这个配置文件不一定是要由你来写，可能是别人写，而那个人不用 Python，但是通过 ini 文件的话就省去了沟通的成本。</p>
<h2 id="yaml-文件"><a class="header" href="#yaml-文件">yaml 文件</a></h2>
<p>yaml 的表达能力比 ini 更加强大，该文件以 .yml 结尾，在介绍它的语法结构之前我们先来看看 yaml 的一些基本规则。</p>
<ul>
<li>大小写敏感；</li>
<li>使用缩进表示层级关系，并且缩进只能用空格、不可以使用 tab 键。缩进的空格数目不重要，只要相同层级的元素左侧对齐即可；</li>
<li># 表示注释，# 到行尾的所有字符都会被忽略；</li>
</ul>
<p>yaml 支持的数据结构有以下三种：</p>
<ul>
<li>字典：键值对的集合；</li>
<li>数组：多个元素组成的集合；</li>
<li>标量：单个、不可分割的值；</li>
</ul>
<p>Python 解析 yaml 则是通过一个名为 pyyaml 的库，直接 pip install pyyaml 即可。</p>
<p>下面我们来介绍一下 yaml 的数据结构。</p>
<h3 id="字典"><a class="header" href="#字典">字典</a></h3>
<p>类似于 Python 的字典，使用键值对表示：</p>
<pre><code class="language-yaml">name: satori
# 或者写成下面的形式
{name: satori}
</code></pre>
<p>Python 解析之后会是什么结果呢？</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
name: satori
&quot;&quot;&quot;

# yaml.safe_load：只解析自己信任的输入
# yaml.unsafe_load：不检测输入的安全性
print(yaml.safe_load(config))
&quot;&quot;&quot;
{'name': 'satori'}
&quot;&quot;&quot;

config = &quot;&quot;&quot;
{name: satori}
&quot;&quot;&quot;
print(yaml.safe_load(config))
&quot;&quot;&quot;
{'name': 'satori'}
&quot;&quot;&quot;
</code></pre>
<p>在 yaml 里面，字典的 value 也可以是一个字典：</p>
<pre><code class="language-yaml">info: {name: satori, address: 东方地灵殿}
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
info: {name: satori, address: 东方地灵殿}
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
  'info': {'name': 'satori', 'address': '东方地灵殿'}
}
&quot;&quot;&quot;
</code></pre>
<p>还是很简单的。</p>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p>一组连字符开头的行，构成一个数组。</p>
<pre><code class="language-yaml">- 古明地觉
- 古明地恋
- 雾雨魔理沙
# - 后面要有空格，或者写成下面的形式
[古明地觉, 古明地恋, 雾雨魔理沙]
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
- 古明地觉
- 古明地恋
- 雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
['古明地觉', '古明地恋', '雾雨魔理沙']
&quot;&quot;&quot;

config = &quot;&quot;&quot;
[古明地觉, 古明地恋, 雾雨魔理沙]
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
['古明地觉', '古明地恋', '雾雨魔理沙']
&quot;&quot;&quot;
</code></pre>
<p>并且数组的子成员也可以是一个数组：</p>
<pre><code class="language-yaml">-
 - 古明地觉
 - 古明地恋
 - 雾雨魔理沙
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
-
  - 古明地觉
  - 古明地恋
  - 雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
[['古明地觉', '古明地恋', '雾雨魔理沙']]
&quot;&quot;&quot;

# 更简洁的写法
config = &quot;&quot;&quot;
- [古明地觉, 古明地恋, 雾雨魔理沙]
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
[['古明地觉', '古明地恋', '雾雨魔理沙']]
&quot;&quot;&quot;
</code></pre>
<p>显然数组也可以放在字典中：</p>
<pre><code class="language-yaml"># 缩进对应的空格数没有要求，但是必须一样
# 对于当前这个键值对而言也可以没有缩进
girl:
    -古明地觉
    -古明地恋
    -雾雨魔理沙
# 或者下面这种形式
girl:[古明地觉,古明地恋,雾雨魔理沙]
# 或者下面这种形式
{girl:[古明地觉,古明地恋, 雾雨魔理沙]}
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
girl:
  - 古明地觉
  - 古明地恋
  - 雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{'girl': ['古明地觉', '古明地恋', '雾雨魔理沙']}
&quot;&quot;&quot;

# 注意：上面的 girl 对应的是数组，因为每个元素前面都有 -
# 但如果没有的话会发生什么？
config = &quot;&quot;&quot;
girl:
    古明地觉
    古明地恋
    雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{'girl': '古明地觉 古明地恋 雾雨魔理沙'}
&quot;&quot;&quot;
# 我们看到整体相当于是一个字符串，类似于 html，之间用一个空格代替
# 因此如果内容比较长，我们可以写成多行，但是注意：每一行前面必须有空格
</code></pre>
<p>然后是一个稍微复杂的例子：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
girl:
    # 会对应一个数组
    - 古明地觉
    - 古明地恋
    - 雾雨魔理沙
    
place1:
    # 虽然不是数组，但是内部是字典的形式
    # 所以会对应一个含有三个键值对的字典
    古明地觉: 东方地灵殿
    古明地恋: 东方地灵殿
    雾雨魔理沙: 魔法森林

place2:
  # 是数组，数组里面每个元素是一个字典
  - 古明地觉: 东方地灵殿
  - 古明地恋: 东方地灵殿
  - 雾雨魔理沙: 魔法森林
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
    'girl': ['古明地觉', '古明地恋', '雾雨魔理沙'],
    'place1': {'古明地觉': '东方地灵殿', 
               '古明地恋': '东方地灵殿', 
               '雾雨魔理沙': '魔法森林'},
    'place2': [{'古明地觉': '东方地灵殿'}, 
               {'古明地恋': '东方地灵殿'}, 
               {'雾雨魔理沙': '魔法森林'}]
}
&quot;&quot;&quot;
</code></pre>
<p>place1 对应的是一个字典，place2 对应的是一个数组。</p>
<h3 id="标量"><a class="header" href="#标量">标量</a></h3>
<p>标量属于最基本的、不可再分的值，比较简单，我们就全部都说了吧。</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
int: 123
float: 3.14
bool:
    - true 
    - false
# 波浪号表示空    
NoneType: ~  
datetime: 2020-11-11 12:12:13

# 使用两个 ! 可以进行类型强转
# 不过几乎用不到 
cast:
    - !!str 123
    - !!str true  
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
    'int': 123, 'float': 3.14,
    'bool': [True, False], 'NoneType': None,
    'datetime': datetime.datetime(2020, 11, 11, 12, 12, 13), 
    'cast': ['123', 'true']
}
&quot;&quot;&quot;
</code></pre>
<p>这里可能有人已经发现了，就是字符串不需要加引号，但如果里面有特殊字符怎么办？所以 yaml 是支持使用引号括起来的。</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
name1: 古明地觉      a x   $ #  !!        
name2: &quot;古明地觉      a x   $ #  !!&quot;        
name3: '古明地觉      a x   $ #  !!'   
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{'name1': '古明地觉      a x   $', 
 'name2': '古明地觉      a x   $ #  !!', 
 'name3': '古明地觉      a x   $ #  !!'}
&quot;&quot;&quot;
</code></pre>
<p>对于 yaml 而言，字符串默认是从第一个不是空格的字符、匹配到最后一个不是空格的字符（如果遇到 # 直接停止）。因此如果 value 的前面或后面有空格的话，那么这些空格是不会显示的，或者当中有 #，那么 # 后面的内容也不会显示。</p>
<p>解决办法是使用单引号或双引号括起来，如果内部还有引号，那么需要输入两遍进行转义（如果内部的引号和外面括起来的引号相同的话）。</p>
<h3 id="引用"><a class="header" href="#引用">引用</a></h3>
<p>对于 yaml 而言，还支持我们采用 &amp; 和 * 进行引用，举个例子：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
# 多了一个 &amp;db_info_ref
# 相当于起了个名字，叫 db_info_ref
db_info: &amp;db_info_ref  
    host: 127.0.0.1
    port: 5432
    user: postgres
    password: 123456

deploy:
    os: Linux
    # 将内容直接扔到里面来  
    &lt;&lt;: *db_info_ref  
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
    'db_info': {'host': '127.0.0.1',
                'port': 5432,
                'user': 'postgres',
                'password': 123456},
    'deploy': {'host': '127.0.0.1',
               'port': 5432,
               'user': 'postgres',
               'password': 123456,
               'os': 'Linux'}
}
&quot;&quot;&quot;
</code></pre>
<p>&amp; 用来建立锚点，&lt;&lt; 表示合并当前数据，* 表示用来引用锚点。还可以作用在数组中：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
- &amp;name 古明地觉 
- 古明地恋
- 雾雨魔理沙
- *name
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
['古明地觉', '古明地恋', 
 '雾雨魔理沙', '古明地觉']
&quot;&quot;&quot;
</code></pre>
<h3 id="生成-yaml-文件"><a class="header" href="#生成-yaml-文件">生成 yaml 文件</a></h3>
<p>既然能够读取 yaml 文件，那么自然也能生成 yaml 文件。</p>
<pre><code class="language-python">import yaml

data = {
    &quot;girl&quot;: [
        {&quot;name&quot;: &quot;古明地觉&quot;, &quot;age&quot;: 17, &quot;place&quot;: &quot;东方地灵殿&quot;},
        {&quot;name&quot;: &quot;古明地恋&quot;, &quot;age&quot;: 16, &quot;place&quot;: &quot;东方地灵殿&quot;},
        {&quot;name&quot;: &quot;雾雨魔理沙&quot;, &quot;age&quot;: 16, &quot;place&quot;: &quot;魔法森林&quot;}
    ],
    &quot;other&quot;: {
        &quot;古明地觉&quot;: {&quot;nickname&quot;: [&quot;小五&quot;, &quot;少女觉&quot;, &quot;觉大人&quot;, &quot;小五萝莉&quot;], &quot;length&quot;: 155},
        &quot;古明地恋&quot;: {&quot;nickname&quot;: [&quot;恋恋&quot;], &quot;length&quot;: 155},
        &quot;雾雨魔理沙&quot;: {&quot;nickname&quot;: [&quot;摸你傻&quot;], &quot;length&quot;: 155}
    }
}

with open(&quot;cfg.yml&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
    yaml.dump(data, f, allow_unicode=True, indent=2)
</code></pre>
<p>然后我们看看生成的 yml 文件长什么样子。</p>
<p><img src="%E8%A7%A3%E6%9E%90%20ini%E3%80%81yaml%E3%80%81toml%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/./3.png" alt="" /></p>
<p>我们来看 yml 文件，然后反推出相应的数据结构。首先整体是一个字典，里面有 girl 和 other 两个 key。其中 girl 对应一个数组，数组里面每个元素都是字典，这是符合预期的。</p>
<p>然后 other 对应一个字典，而且这个字典内部有三个键值对，key 分别是：古明地觉、古明地恋、雾雨魔理沙，各自对应的 value 又是一个字典（内部有 length、nickname 两个 key，其中 length 对应整型、nickname 对应列表）。</p>
<p>最后再看一个本人之前项目中的 yml 文件，可以猜猜看解析出来长什么样子。</p>
<p><img src="%E8%A7%A3%E6%9E%90%20ini%E3%80%81yaml%E3%80%81toml%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/./4.png" alt="" /></p>
<p>解析一下看看和你想的是不是一样的。</p>
<pre><code class="language-python">import yaml

with open(&quot;.gitlab-ci.yml&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
    data = f.read()

data = yaml.safe_load(data)
print(data)
&quot;&quot;&quot;
{
    'stages': ['test'], 
    'cache': {'key': '${CI_COMMIT_REF_SLUG}', 
              'paths': ['.cache/pip']},
    'variables': {'PIP_CACHE_DIR': '$CI_PROJECT_DIR/.cache/pip'},
    'test': {'stage': 'test', 
             'image': 'xxxxxxx/python:3.8.1-thanosclient-buster', 
             'only': ['branches', 'tags'],
             'services': ['mysql:5.7'],
             'variables': {'PROJECT': 'XXXXXX', 
                           'PIP_CACHE_DIR': '$CI_PROJECT_DIR/.cache/pip',
                           'MARKETING_CONFIG': 'config/room/ci.cn-gz.toml',
                           'MYSQL_DATABASE': 'activity', 
                           'MYSQL_ROOT_PASSWORD': 'password',
                           'MYSQL_INITDB_SKIP_TZINFO': '1'}
             }
}
&quot;&quot;&quot;
</code></pre>
<p>结果应该不难想，毕竟 yaml 文件不是很复杂。</p>
<h2 id="toml-文件"><a class="header" href="#toml-文件">toml 文件</a></h2>
<p>虽然 yaml 的表达能力已经很丰富了，但 GitHub 觉得还是不够优雅，所以鼓捣出了一个 toml。toml 有着比 yaml 更简洁的语法，它的目标就是成为一个最简单的配置文件格式。然后 Python 解析 toml 文件需要使用一个名字也叫 toml 的库，直接 pip install toml 即可。</p>
<p>有了 ini 和 yaml，相信 toml 学习来也很简单，先直接看一个例子吧。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
title = &quot;toml 小栗子&quot;

[owner]
name = &quot;古明地觉&quot;
age = 17
place = &quot;东方地灵殿&quot;
nickname = [&quot;小五&quot;, &quot;少女觉&quot;, &quot;觉大人&quot;]

[database]
host = &quot;127.0.0.1&quot;
port = 5432
username = &quot;satori&quot;
password = &quot;123456&quot;
echo = true

[server]
    [server.v1]
    api = &quot;1.1&quot;
    enable = false
    
    [server.v2]
    api = &quot;1.2&quot;
    enable = true

[client]
client = [
    [&quot;socket&quot;, &quot;webservice&quot;], 
    [5555]
]
address = [
    &quot;xxxx&quot;,
    &quot;yyyy&quot;
]
&quot;&quot;&quot;

# loads：从字符串加载
# load：从文件加载
# dumps：生成 toml 格式字符串
# dump：生成 toml 格式字符串并写入文件中
data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'title': 'toml 小栗子', 
    'owner': {'name': '古明地觉', 
              'age': 17, 
              'place': '东方地灵殿', 
              'nickname': ['小五', '少女觉', '觉大人']},
    'database': {'host': '127.0.0.1', 
                 'port': 5432,
                 'username': 'satori', 
                 'password': '123456', 
                 'echo': True},
    'server': {'v1': {'api': '1.1', 'enable': False}, 
               'v2': {'api': '1.2', 'enable': True}},
    'client': {'client': [['socket', 'webservice'], [5555]], 
               'address': ['xxxx', 'yyyy']}
}
&quot;&quot;&quot;
</code></pre>
<p>toml 是采用 <code>var = value</code> 的形式进行配置，然后也有类似于 ini 里面的 section，每个 section 都是字典中的一个 key，然后该 key 也对应一个字典。但是我们注意看最开始的 title，由于它上面没有 section，所以它是一个单独的 key。</p>
<p>而且还有一点就是 toml 支持嵌套，我们看到 server.v1，表示 v1 是 server 对应的字典里面的一个 key，然后 v1 对应的值还是一个字典。</p>
<p>toml 变得更加简单了，而且写来也非常像 Python，它有如下特点：</p>
<ul>
<li>toml 文件是大小写敏感的；</li>
<li>toml 文件必须是有效的 UTF-8 编码的 Unicode 文档；</li>
<li>toml 文件的空白符应该是 Tab 或者空格；</li>
<li>toml 文件的换行是 LF 或者 CRLF；</li>
</ul>
<p>然后我们来介绍一下 toml 的数据结构。</p>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<p>toml 采用 # 表示注释，举个例子：</p>
<pre><code class="language-toml"># 这是注释
key = &quot;value&quot;  # 也是注释
</code></pre>
<p>可以解析一下看看会得到什么，剧透：会得到只包含一个键值对的字典。</p>
<h3 id="键值对"><a class="header" href="#键值对">键值对</a></h3>
<p>TOML 文档最基本的构成区块是键值对，键名在等号的左边、值在右边，并且键名和键值周围的空白会被忽略。此外键、等号和值必须在同一行（不过有些值可以跨多行）。</p>
<pre><code class="language-toml">key = &quot;value&quot;
</code></pre>
<p>键名可以是裸露的（裸键），引号引起来的（引号键），或点分隔的（点分隔键）。裸键只能包含：ascii 字符、ascii 数字、下划线、短横线。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
key = &quot;value&quot;
bare_key = &quot;value&quot;
bare-key = &quot;value&quot;
# 1234 会被当成字符串
1234 = &quot;value&quot;  
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'key': 'value', 
 'bare_key': 'value', 
 'bare-key': 'value', 
 '1234': 'value'}
&quot;&quot;&quot;
</code></pre>
<p>如果不是裸键，那么就必须使用引号括起来，但是此时也支持我们使用更加广泛的键名，但除了特殊场景，否则使用裸键是最佳实践。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
&quot;127.0.0.1&quot; = &quot;value&quot;
&quot;character encoding&quot; = &quot;value&quot;
&quot;ʎǝʞ&quot; = &quot;value&quot;
'key2' = &quot;value&quot;
'quoted &quot;value&quot;' = &quot;value&quot; 
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'127.0.0.1': 'value', 
 'character encoding': 'value', 
 'ʎǝʞ': 'value', 
 'key2': 'value', 
 'quoted &quot;value&quot;': 'value'}
&quot;&quot;&quot;
</code></pre>
<p>注意：裸键不能为空，但空引号键是允许的（虽然不建议如此）。</p>
<pre><code class="language-toml">= &quot;没有键名&quot;  # 错误
&quot;&quot; = &quot;空&quot;     # 正确但不鼓励
'' = '空'     # 正确但不鼓励
</code></pre>
<p>然后是点分隔键，它是一系列通过点相连的裸键或引号键，这允许我们将相近属性放在一起：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
name = &quot;橙子&quot;
physical.color = &quot;橙色&quot;
physical.shape = &quot;圆形&quot;
site.&quot;google.com&quot; = true
site.google.com = true
a.b.c.d = 123
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'name': '橙子',
    'physical': {'color': '橙色',
                 'shape': '圆形'},
    'site': {'google.com': True,
             'google': {'com': True}},
    'a': {'b': {'c': {'d': 123}}}
}
&quot;&quot;&quot;
</code></pre>
<p>我们看到这个点分隔符不错哟，自动实现了嵌套结构，并且点分隔符周围的空白会被忽略。</p>
<pre><code class="language-toml">fruit.name = &quot;香蕉&quot;     # 这是最佳实践
fruit. color = &quot;黄色&quot;    # 等同于 fruit.color
fruit . flavor = &quot;香蕉&quot;   # 等同于 fruit.flavor
</code></pre>
<p>注意：多次定义同一个键是不行的。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# name 和 &quot;name&quot; 是等价的
name = &quot;古明地觉&quot;
&quot;name&quot; = &quot;古明地恋&quot;  
&quot;&quot;&quot;

try:
    data = toml.loads(config)
except toml.decoder.TomlDecodeError as e:
    print(e)
&quot;&quot;&quot;
Duplicate keys! (line 4 column 1 char 36)
&quot;&quot;&quot;
</code></pre>
<p>对于点分隔键也是如此，只要一个键还没有被直接定义过，我们就仍可以对它和它下属的键名赋值。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
fruit.apple.smooth = true# 此时可以继续操作 fruit、fruit.apple，它们都是字典
# 给 fruit 这个字典加一个 key  
fruit.orange = 2  
# 给 fruit.apple 加一个 key
fruit.apple.color = &quot;red&quot;   
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'fruit': {'apple': {'smooth': True, 
                        'color': 'red'}, 
              'orange': 2}
}
&quot;&quot;&quot;
</code></pre>
<p>但下面这个操作是不行的：</p>
<pre><code class="language-toml"># 将 fruit.apple 的值定义为一个整数
fruit.apple = 1
# 但接下来就不合法了，因为整数不能变成字典
fruit.apple.smooth = true

# 如果我们设置 fruit.apple = {}，那么第二个赋值是可以的
# 没错，我们可以通过 {} 直接创建一个字典
</code></pre>
<p>可以看到，真的很像 Python。然后再来说一个特例：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
3.14 = &quot;pi&quot;  
&quot;3.14&quot; = &quot;pi&quot;  
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'3': {'14': 'pi'}, '3.14': 'pi'}
&quot;&quot;&quot;
</code></pre>
<p>如果键是浮点数，那么需要使用引号括起来，否则会被解释为点分隔键。</p>
<p>看完了键，再来看看值（value），其实对于 toml 来说，值比键要简单的多得多。</p>
<h3 id="字符串"><a class="header" href="#字符串">字符串</a></h3>
<p>字符串共有四种方式来表示：基础式的，多行基础式的，字面量式的，和多行字面量式的。</p>
<p><strong>1）基础字符串由引号包裹，任何 Unicode 字符都可以使用，除了那些必须转义的。</strong></p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
str = '我是一个字符串，&quot;你可以把我引起来&quot;' 
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'str': '我是一个字符串，&quot;你可以把我引起来&quot;'}
&quot;&quot;&quot;
</code></pre>
<p><strong>2）多行字符串由三个引号包裹，允许换行，注意：紧随开头引号的换行会被去除，其它空白和换行会被原样保留。</strong></p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
str = '''
玫瑰是红色的
紫罗兰是蓝色的
'''
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'str': '玫瑰是红色的\n紫罗兰是蓝色的\n'}
&quot;&quot;&quot;
</code></pre>
<p>这里的引号可以是双引号、也可以是单引号。</p>
<h3 id="整数"><a class="header" href="#整数">整数</a></h3>
<p>整数是纯数字，正数可以有加号前缀，负数的前缀是减号。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
int1 = +99
int2 = 42
int3 = 0
int4 = -17

# 对于大数，可以在数字之间用下划线来增强可读性
# 每个下划线两侧必须至少有一个数字。
int5 = 1_000
int6 = 5_349_221
int7 = 53_49_221  # 印度记数体系分组
int8 = 1_2_3_4_5  # 无误但不鼓励
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'int1': 99,
 'int2': 42,
 'int3': 0,
 'int4': -17,
 'int5': 1000,
 'int6': 5349221,
 'int7': 5349221,
 'int8': 12345}
&quot;&quot;&quot;
</code></pre>
<p>但是注意：数字不能以零开头，除了 0 本身。当然 -0 与 +0 也是有效的，并等同于无前缀的零。非负整数值也可以用十六进制、八进制或二进制来表示。</p>
<pre><code class="language-python"># 带有 `0x` 前缀的十六进制，大小写均可
hex1=0xDEADBEEF
hex2=0xdeadbeef
hex3=0xdead_beef

# 带有 `0o` 前缀的八进制
oct1=0o01234567
oct2=0o755# 对于表示 Unix 文件权限很有用

# 带有 `0b` 前缀的二进制
bin1= 0b11010110
</code></pre>
<h3 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h3>
<p>一个浮点数由一个整数部分（遵从与十进制整数值相同的规则）后跟上一个小数部分、或一个指数部分组成。如果小数部分和指数部分兼有，那小数部分必须在指数部分前面。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 小数
flt1 = +1.0
flt2 = 3.1415
flt3 = -0.01

# 指数
flt4 = 5e+22
flt5 = 1e06
flt6 = -2E-2

flt7 = 6.626e-34
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'flt1': 1.0,
 'flt2': 3.1415,
 'flt3': -0.01,
 'flt4': 5e+22,
 'flt5': 1000000.0,
 'flt6': -0.02,
 'flt7': 6.626e-34}
&quot;&quot;&quot;
</code></pre>
<p>小数部分是一个小数点后跟一个或多个数字，一个指数部分是一个 E（大小写均可）后跟一个整数部分（遵从与十进制整数值相同的规则，但可以包含前导零）。小数点，如果有用到的话，每侧必须紧邻至少一个数字。</p>
<pre><code class="language-python"># 非法的浮点数
invalid_float_1 = .7
invalid_float_2 = 7.
invalid_float_3 = 3.e+20
</code></pre>
<p>与整数相似，可以使用下划线来增强可读性，每个下划线必须被至少一个数字围绕。</p>
<pre><code class="language-python">flt8 = 224_617.445_991_228
</code></pre>
<p>浮点数值 -0.0 与 +0.0 是有效的，并且应当遵从 IEEE 754。特殊浮点值也能够表示：</p>
<pre><code class="language-python"># 无穷
sf1=inf  # 正无穷
sf2=+inf  # 正无穷
sf3=-inf  # 负无穷

# 非数
sf4=nan  # 是对应信号非数码还是静默非数码，取决于实现
sf5=+nan  # 等同于 `nan`
sf6=-nan  # 正确，实际码取决于实现
</code></pre>
<h3 id="布尔值"><a class="header" href="#布尔值">布尔值</a></h3>
<p>布尔值就是惯用的那样，但要小写。</p>
<pre><code class="language-toml">bool1 = true
bool2 = false
</code></pre>
<h3 id="日期"><a class="header" href="#日期">日期</a></h3>
<p>可以是普通的 datetime，或者是遵循 ISO-8859-1 格式的日期。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
dt1 = 2020-01-01T12:33:22+00:00
dt2 = 2020-11-12 12:11:33
dt3 = 2020-11-23
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'dt1': datetime.datetime(2020, 1, 1, 12, 33, 22, tzinfo=...), 
 'dt2': datetime.datetime(2020, 11, 12, 12, 11, 33), 
 'dt3': datetime.date(2020, 11, 23)}
&quot;&quot;&quot;
</code></pre>
<h3 id="数组-1"><a class="header" href="#数组-1">数组</a></h3>
<p>语法和 Python 的列表类似：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 每个数组里面的元素类型要一致
integers = [1, 2, 3]
colors = [&quot;红&quot;, &quot;黄&quot;, &quot;绿&quot;]
nested_array_of_ints = [[1, 2], [3, 4, 5]]
nested_mixed_array = [[1, 2], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]]
numbers = [0.1, 0.2, 0.5]
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'colors': ['红', '黄', '绿'],
 'integers': [1, 2, 3],
 'nested_array_of_ints': [[1, 2], [3, 4, 5]],
 'nested_mixed_array': [[1, 2], ['a', 'b', 'c']],
 'numbers': [0.1, 0.2, 0.5]}
&quot;&quot;&quot;
</code></pre>
<p>数组可以跨行，数组的最后一个值后面可以有终逗号（也称为尾逗号）。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
integers2 = [
  1, 2, 3
]

integers3 = [
  1,
  2, # 这是可以的
]
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'integers2': [1, 2, 3], 'integers3': [1, 2]}
&quot;&quot;&quot;
</code></pre>
<h3 id="表"><a class="header" href="#表">表</a></h3>
<p>表，完全可以把它想象成 ini 的 section。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 表名的定义规则与键名相同
# 解析之后得到的大字典中就有 &quot;table-1&quot; 这个 key
# 并且其 value 也是一个表，在它下方
# 直至下一个表头或文件结束，都是这个表内部的键值对
[table-1]
key1 = &quot;some string&quot;
key2 = 123

[table-2]
key1 = &quot;another string&quot;
key2 = 456
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'table-1': {'key1': 'some string', 'key2': 123},
 'table-2': {'key1': 'another string', 'key2': 456}}
&quot;&quot;&quot;
</code></pre>
<p>但是我们之前也实现过类似于这种结构，没错，就是点分隔符：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 所以 other-table-1 和 table-1 是等价的
# other-table-2 和 table-2 是等价的
other-table-1.key1 = &quot;some string&quot;
other-table-1.key2 = 123

other-table-2.key1 = &quot;another string&quot;
other-table-2.key2 = 456

[table-1]
key1 = &quot;some string&quot;
key2 = 123

[table-2]
key1 = &quot;another string&quot;
key2 = 456
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'other-table-1': {'key1': 'some string', 'key2': 123},
 'other-table-2': {'key1': 'another string', 'key2': 456},
 'table-1': {'key1': 'some string', 'key2': 123},
 'table-2': {'key1': 'another string', 'key2': 456}}
&quot;&quot;&quot;
</code></pre>
<p>不过注意：我们必须要把 other-table-1 和 other-table-2 定义在上面，如果我们定义在下面看看会有什么后果：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[table-1]
key1 = &quot;some string&quot;
key2 = 123

[table-2]
key1 = &quot;another string&quot;
key2 = 456

other-table-1.key1 = &quot;some string&quot;
other-table-1.key2 = 123

other-table-2.key1 = &quot;another string&quot;
other-table-2.key2 = 456
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'table-1': {'key1': 'some string', 'key2': 123},
    'table-2': {'key1': 'another string',
                'key2': 456,
                'other-table-1': {'key1': 'some string', 
                                  'key2': 123},
                'other-table-2': {'key1': 'another string', 
                                  'key2': 456}}
}
&quot;&quot;&quot;
</code></pre>
<p>估计你已经猜到了，它们被当成了 'table-2' 对应的字典里面的 key 了。此外我们还可以将上面两种方式结合起来：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# [] 里面的不再是一个普通的键，而是点分隔键
# 另外键名周围的空格会被忽略，但是最好不要有
[dog  .  &quot;tater.man&quot;]  
type.name = &quot;哈巴狗&quot;
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'dog': {'tater.man': {'type': {'name': '哈巴狗'}}}
}
&quot;&quot;&quot;
</code></pre>
<p>表的里面也是可以没有键值对的：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[x.y.z.w.a.n]

[x.m]

[x.n]

[x]
a.b.c = &quot;xxx&quot;
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'x':
    {
        'a': {'b': {'c': 'xxx'}},
        'm': {},
        'n': {},
        'y': {'z': {'w': {'a': {'n': {}}}}}
    }
}
&quot;&quot;&quot;
</code></pre>
<p>总的来说还是蛮强大的，但是要注意：不能重复定义。</p>
<h3 id="行内表"><a class="header" href="#行内表">行内表</a></h3>
<p>行内表提供了一种更为紧凑的语法来表示表，因为上面每一个键值对都需要单独写一行，比如：</p>
<pre><code class="language-toml">[table1]
a = 1
b = 2
c = 3
# 最终可以得到 
# {'table1': {'a': 1, 'b': 2, 'c': 3}}
</code></pre>
<p>但是除了上面的表达方式之外，我们还可以采用行内表：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 和 Python 字典的表示方式略有不同，并且也支持多种 key
table1 = {a = 1, b = &quot;二&quot;, c.a = &quot;3&quot;}
table2 = {c.&quot;b c&quot;.d = &quot;4&quot;}
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'table1': {'a': 1, 'b': '二', 'c': {'a': '3'}},
    'table2': {'c': {'b c': {'d': '4'}}}
}
&quot;&quot;&quot;
</code></pre>
<h3 id="表数组"><a class="header" href="#表数组">表数组</a></h3>
<p>然后来看看数组和表的结合：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[name1]
girl = &quot;古明地觉&quot;

[[name2]]
girl = &quot;古明地恋&quot;

[name3]
[[name4]]
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'name1': {'girl': '古明地觉'},
 'name2': [{'girl': '古明地恋'}],
 'name3': {},
 'name4': [{}]}
&quot;&quot;&quot;
</code></pre>
<p>当使用 [[]] 的时候，相当于在 [] 的基础上套上一层列表。并且任何对表数组的引用都指向该数组里最近定义的表元素，这允许我们在最近的表内定义子表，甚至子表数组。</p>
<p>我们再举个更复杂的例子：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[[fruits]]  
name = &quot;苹果&quot;  

# 会操作 [] 里面最近定义的 {}
[fruits.physical]  
color = &quot;红色&quot;
shape = &quot;圆形&quot;

[[fruits.varieties]]  # 嵌套表数组
name = &quot;蛇果&quot;    

[[fruits.varieties]]
name = &quot;澳洲青苹&quot; 

[[fruits]]
name = &quot;香蕉&quot; 

[[fruits.varieties]]
name = &quot;车前草&quot;  
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'fruits':
        [
            {
                'name': '苹果',
                'physical': {'color': '红色', 
                             'shape': '圆形'},
                'varieties': [{'name': '蛇果'}, 
                              {'name': '澳洲青苹'}]
            },
            {
                'name': '香蕉', 
                'varieties': [{'name': '车前草'}]
            }
        ]
}
&quot;&quot;&quot;
</code></pre>
<p>很明显这种定义不是很常用，配置文件应该要非常直观才对，但这已经不是很好理解了。</p>
<h2 id="小结-7"><a class="header" href="#小结-7">小结</a></h2>
<p>以上就是几种配置文件相关的内容，其中 ini 文件格式最简单，yaml 文件格式使用最广泛， toml 文件格式的表达能力更加丰富，像 Rust 项目采用的配置文件就是 toml 格式的。</p>
<div style="break-before: page; page-break-before: always;"></div><p>fuzzywuzzy 可以计算两个字符串之间的相似度，它依据 Levenshtein Distance 算法来进行计算，该算法又叫 Edit Distance 算法，是指两个字符串之间，由一个转成另一个所需要的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越高。</p>
<p>我们来看一下该模块的用法，非常简单：</p>
<pre><code class="language-python">from fuzzywuzzy import fuzz

# 调用 fuzz.ratio 即可计算两个字符串的相似度
print(fuzz.ratio(&quot;古明地觉&quot;, &quot;古明地恋&quot;))  # 75

# 我们看到 ratio 是完全匹配的，它把字符串的长度也考虑在内了
print(fuzz.ratio(&quot;古明地觉&quot;, &quot;古明地觉aa&quot;))  # 80

# partial_ratio 是非完全匹配
# 如果一方结束了，那么剩下的就不考虑了
print(fuzz.partial_ratio(&quot;古明地觉&quot;, &quot;古明地觉,小五萝莉&quot;))  # 100

# token_sort_ratio 表示忽略顺序匹配
# 但前提是多个词，以空格进行分隔
print(fuzz.ratio(&quot;古 明 地 觉&quot;, &quot;古 明 地 觉&quot;[:: -1]))  # 43
print(fuzz.token_sort_ratio(&quot;古 明 地 觉&quot;, &quot;古 明 地 觉&quot;[:: -1]))  # 100

# token_set_ratio 表示去重匹配
# 同样：前提是多个词，以空格进行分隔
print(fuzz.ratio(&quot;a a a he&quot;, &quot;a he&quot;))  # 67
print(fuzz.token_set_ratio(&quot;a a a he&quot;, &quot;a he&quot;))  # 100
</code></pre>
<p>当我们使用 git 的时候，如果命令输错了，那么会告诉你此命令不是一个 git 命令，这是理所应当的。然后重点来了，git 还会提示一些与你输错的命令长得非常相似的一些命令。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20fuzzywuzzy%20%E6%A8%A1%E5%9D%97%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6/./1.png" alt="" /></p>
<p>所以这里面也用到了字符串的相似度原理，找出 git 命令中和你输错的命令最相似的几个，然后进行提示。</p>
<p>如果我们也写了一个类似的程序，需要用户通过命令行参数的方式，那么当用户输入了一个不存在的命令时，也可以这么做。而实现方法也很简单，就是将所有的命令和用户输错的命令都计算一个相似度，然后返回相似度最高的 n 个即可。</p>
<p>使用上面的 fuzz 完全可以实现，当然 fuzzywuzzy 模块还提供了一个 extract 函数，可以让我们更加轻松地做到这一点。</p>
<pre><code class="language-python">from fuzzywuzzy import process

words = [&quot;hello python&quot;, &quot;hello java&quot;, &quot;hello golang&quot;, &quot;hello php&quot;]
# 会自动和 words 里面的每一个元素进行比较
# 然后按照相似度从高到低排列
print(process.extract(&quot;hello thon&quot;, words))
&quot;&quot;&quot;
[('hello python', 91), ('hello php', 74), 
 ('hello golang', 73), ('hello java', 64)]
&quot;&quot;&quot;

# 还可以传入一个 limit 参数
# 表示只返回前 limit 个，默认为 5
print(process.extract(&quot;hello thon&quot;, words, limit=2)) 
&quot;&quot;&quot;
[('hello python', 91), 
 ('hello php', 74)]
&quot;&quot;&quot;

# 返回分数最高的，此时返回一个元组
print(process.extractOne(&quot;hello thon&quot;, words))  
&quot;&quot;&quot;
('hello python', 91)
&quot;&quot;&quot;
</code></pre>
<p>这个模块使用起来还是比较简单的，当然核心是字符串相似度的计算原理，这才是重点，有兴趣可以去了解一下。</p>
<p>另外使用 fuzzywuzzy 这个模块的时候，会弹出一个警告：</p>
<blockquote>
<p>UserWarning: Using slow pure-python SequenceMatcher. Install python-Levenshtein to remove this warning</p>
</blockquote>
<p>提示我们可以通过安装 python-Levenshtein 得到解决，这是一个用于加速字符串匹配的库，可提供 4 到 10 倍的加速。当然即使没有这个库也是可以的，没有的话 fuzzywuzzy 底层会使用标准库 difflib 进行匹配，只是会弹出警告罢了。</p>
<div style="break-before: page; page-break-before: always;"></div><p>在工作中，我们经常需要从命令行当中解析出指定的参数，而 Python 也提供了相应的标准库来做这件事情，比如 sys, optparse, getopt, argparse。这里面功能最强大的莫过于 argparse，下面就来看看它用法。</p>
<pre><code class="language-python">import argparse

# 使用 argparse 分为以下几步
# 1. 创建命令行解析器对象
parse = argparse.ArgumentParser(
    description=&quot;这是命令行解析器&quot;
)

# 2.给解析器添加命令行参数，可以添加任意个
parse.add_argument(&quot;-n&quot;, dest=&quot;name&quot;)

# 3. 从命令中将参数解析出来
args = parse.parse_args()

# 然后通过 args 便可以拿到相应的参数值
print(args.name)
</code></pre>
<p>我们执行一下看看，当前文件叫做 main.py。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./1.png" alt="" /></p>
<p>怎么样，是不是很简单呢？所以我们的重点就在 add_argument 方法上面，来看看它都支持哪些参数。</p>
<pre><code class="language-python">import argparse

parse = argparse.ArgumentParser()

# 这里出现了 &quot;-n&quot; 和 &quot;--name&quot;
# 在命令行中可以通过 '-n 古明地觉' 或者 '--name 古明地觉' 进行指定
# 两者的含义是一样的，但 - 后面一般跟短参数，-- 后面跟长参数
# 然后是 dest，它表示获取相关参数值时，使用的名称
parse.add_argument(&quot;-n&quot;, &quot;--name&quot;, dest=&quot;name&quot;)
# 这里只有一个短参数，那么在命令行中需要通过 -a 来指定
parse.add_argument(&quot;-a&quot;, dest=&quot;age&quot;)
# 这里只有一个长参数，那么在命令行中需要通过 --gender 来指定
parse.add_argument(&quot;--gender&quot;, dest=&quot;gender&quot;)

args = parse.parse_args()

print(f&quot;name: {args.name}, age: {args.age}, gender: {args.gender}&quot;)
</code></pre>
<p>我们来试一下：</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./2.png" alt="" /></p>
<p>还是很简单的，一个 - 后面跟的是短参数，两个 - 后面跟的是长参数。在命令行中通过 - 或者 -- 进行指定，解析完毕之后再通过 dest 参数指定的名字进行获取。</p>
<p>另外，虽然 - 后面跟短参数，-- 后面跟长参数，但我们这样写也是可以的。</p>
<pre><code class="language-python">parse.add_argument(&quot;-name&quot;, &quot;--n&quot;, dest=&quot;name&quot;)
</code></pre>
<p>只不过这种写法比较怪异，应该写成 --name 和 -n，一个横杠后面是短参数，两个是长参数。</p>
<p>然后这些参数都是可以不指定的，会使用默认值 None。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./3.png" alt="" /></p>
<p>如果我希望它是必传参数，该怎么办呢？</p>
<pre><code class="language-python">import argparse

parse = argparse.ArgumentParser()

parse.add_argument(&quot;--host&quot;, dest=&quot;host&quot;, required=True)
parse.add_argument(&quot;-p&quot;, dest=&quot;port&quot;, default=6379)

args = parse.parse_args()

print(f&quot;host: {args.host}, port: {args.port}&quot;)
</code></pre>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./4.png" alt="" /></p>
<p>我们看到当 host 不指定的时候，就会报错。并且我们还通过 default 参数指定了默认值。然后是参数值的类型，不管什么参数，只要在命令行当中传递了，那么解析出来的默认都是字符串类型。</p>
<pre><code class="language-python">import argparse

parse = argparse.ArgumentParser()

parse.add_argument(&quot;-p&quot;, dest=&quot;port&quot;, default=6379)

args = parse.parse_args()

print(f&quot;port 类型: {args.port.__class__}&quot;)
</code></pre>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./5.png" alt="" /></p>
<p>不指定参数会使用默认值，而默认值是整型，但如果指定了，那么会按照字符串格式来解析。我们可不可以规定参数的类型呢？答案是可以的。</p>
<pre><code class="language-python">import argparse

parse = argparse.ArgumentParser()
parse.add_argument(&quot;-p&quot;, dest=&quot;port&quot;, type=int)
args = parse.parse_args()

print(f&quot;port 类型: {args.port.__class__}&quot;)
</code></pre>
<p>通过指定 type 为 int，那么在将参数值解析出来之后就会调用 int 进行转化，转化失败则报错。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./6.png" alt="" /></p>
<p>同理，我们也可以换成其它类型，举个例子。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./7.png" alt="" /></p>
<p>还是很简单的，甚至换成我们自定义的类，或者一个函数也是可以的，</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./8.png" alt="" /></p>
<p>此时我们就实现了给一个参数传递多个值，不过这种做法属于是曲线救国，我们应该通过另一个参数实现。</p>
<p><img src="%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%20argparse/./9.png" alt="" /></p>
<p>nargs 指定为 *，那么表示 --hobby 可以接收任意个值，并且值之间使用空格进行分隔，最终会得到一个列表。如果指定 --hobby，但是不传值，那么会得到空列表。</p>
<blockquote>
<p>注：如果希望接收多个值，并且至少接收一个，那么可以将 nargs 指定为 &quot;+&quot;。</p>
</blockquote>
<p>以上就是 argparse 的基本用法，更多内容可以参考官方文档。</p>
<div style="break-before: page; page-break-before: always;"></div><p>我们在工作中，特别是在做爬虫的时候，经常需要处理 URL。而 Python 的标准库里面有一个模块叫 urllib.parse，可以很方便地处理 URL，下面来看看它都支持哪些功能。</p>
<p><strong>1）对 URL 进行解析，获取每一个组成部分。</strong></p>
<pre><code class="language-python">from urllib.parse import urlparse

url = &quot;https://www.baidu.com/s/koishi/?id=ae4634ed#index&quot;
parse_result = urlparse(url)
# 获取 URL 使用的协议
print(&quot;协议:&quot;, parse_result.scheme)
# 获取 URL 中的域名或 IP
print(&quot;域名:&quot;, parse_result.netloc)
# 获取 URL 中的路径
print(&quot;路径:&quot;, parse_result.path)
# 获取 URL 中的查询参数
print(&quot;查询参数:&quot;, parse_result.query)
# 获取 URL 中的锚点
print(&quot;锚点:&quot;, parse_result.fragment)
&quot;&quot;&quot;
协议: https
域名: www.baidu.com
路径: /s/koishi/
查询参数: id=ae4634ed
锚点: index
&quot;&quot;&quot;
</code></pre>
<p>此时我们就将 URL 的每一个部分都解析出来了，如果里面还包含用户名和密码，也是可以解析出来的。</p>
<pre><code class="language-python">from urllib.parse import urlparse

url = &quot;https://satori:123456@www.example.com&quot;
parse_result = urlparse(url)
print(&quot;用户名:&quot;, parse_result.username)
print(&quot;密码:&quot;, parse_result.password)
&quot;&quot;&quot;
用户名: satori
密码: 123456
&quot;&quot;&quot;
</code></pre>
<p>如果没有用户名和密码的话，那么解析的结果就是 None。</p>
<p><strong>2）对 URL 进行拼接</strong></p>
<p>很多网站的前端标签中出现的 URL 并不完整，只包含了路径相关的部分，举个例子：</p>
<p><img src="%E4%BD%BF%E7%94%A8%20urllib.parse%20%E6%A8%A1%E5%9D%97%E4%BC%98%E9%9B%85%E5%9C%B0%E5%A4%84%E7%90%86%20URL/./1.png" alt="" /></p>
<p>我们看到 URL 并不完整，我们需要将主站的 URL 和它拼接在一起，才能拿到完整的 URL。</p>
<pre><code class="language-python">from urllib.parse import urljoin

# 第一个参数是主站的 URL，第二个参数是路径
url = urljoin(
    &quot;https://www.example.com&quot;,
    &quot;/image/1.png&quot;
)
print(url)
&quot;&quot;&quot;
https://www.example.com/image/1.png
&quot;&quot;&quot;

url = urljoin(
    # 结尾多一个 /
    &quot;https://www.example.com/&quot;,
    &quot;/image/1.png&quot;
)
# 该函数依旧能处理的很好
print(url)
&quot;&quot;&quot;
https://www.example.com/image/1.png
&quot;&quot;&quot;

url = urljoin(
    &quot;https://www.example.com&quot;,
    # 开头少一个 /
    &quot;image/1.png&quot;
)
# 该函数也能处理的很好
print(url)
&quot;&quot;&quot;
https://www.example.com/image/1.png
&quot;&quot;&quot;

# 如果第二个参数本身就是完整的 URL
# 那么不做处理
url = urljoin(
    &quot;https://www.example.com&quot;,
    &quot;https://www.example.com/image/1.png&quot;
)
print(url)
&quot;&quot;&quot;
https://www.example.com/image/1.png
&quot;&quot;&quot;
</code></pre>
<p>通过 urljoin 函数，我们能轻松地拼接 URL。</p>
<p><strong>3）查询参数拼接</strong></p>
<pre><code class="language-python">from urllib.parse import urlencode
print(
    urlencode([(&quot;a&quot;, 1), (&quot;b&quot;, 2), (&quot;a&quot;, 3)])
)  # a=1&amp;b=2&amp;a=3

# 也可以传递一个字典
print(
    urlencode({&quot;name&quot;: &quot;觉&quot;, &quot;age&quot;: 17})
)  # name=%E8%A7%89&amp;age=17
</code></pre>
<p>注意：汉字和特殊字符会进行编码。</p>
<p><strong>4）URL 的编码与解码</strong></p>
<pre><code class="language-python">from urllib.parse import quote, unquote
url = &quot;http://www.example.com/name=觉 恋&quot;
print(url)
# 对汉字和特殊字符进行编码
quote_url = quote(url)
print(quote_url)
&quot;&quot;&quot;
http://www.example.com/name=觉 恋
http%3A//www.example.com/name%3D%E8%A7%89%20%E6%81%8B
&quot;&quot;&quot;

# 对编码之后的 URL 进行解码
print(unquote(quote_url))
&quot;&quot;&quot;
http://www.example.com/name=觉 恋
&quot;&quot;&quot;
</code></pre>
<p>除了 quote 之外还有 quote_plus，那么这两者有啥区别呢？</p>
<pre><code class="language-python">from urllib.parse import quote_plus, quote
url = &quot;http://www.example.com?a=1 2&quot;
print(quote(url))
print(quote_plus(url))
&quot;&quot;&quot;
http%3A//www.example.com%3Fa%3D1%202
http%3A%2F%2Fwww.example.com%3Fa%3D1+2
&quot;&quot;&quot;
# 我们看到 quote 不会对 / 进行编码，而 quote_plus 会
# 并且 quote_plus 还会将空格替换成 +

# 既然有 quote_plus，那么就有 unquote_plus
# 对编码之后的 URL 进行解码
from urllib.parse import unquote_plus, unquote
# 不管是 quote 还是 quote_plus
# unquote_plus 都可以进行解码
print(unquote_plus(quote(url)))
print(unquote_plus(quote_plus(url)))
&quot;&quot;&quot;
http://www.example.com?a=1 2
http://www.example.com?a=1 2
&quot;&quot;&quot;

# 但如果使用 quote_plus 编码，unquote 解码
# 那么当 URL 里面出现空格的时候，就会出问题
print(unquote(quote(url)))
print(unquote(quote_plus(url)))
&quot;&quot;&quot;
http://www.example.com?a=1 2
http://www.example.com?a=1+2
&quot;&quot;&quot;
</code></pre>
<p>所以编码的时候 quote 和 quote_plus 均可使用，但解码的时候建议统一使用 unquote_plus。</p>
<p><strong>5）查询参数解析</strong></p>
<p>这个功能用的比较少，因为解析查询参数一般都是在做 web 的时候出现，而 web 框架都内置了查询参数解析功能。</p>
<pre><code class="language-python">from urllib.parse import parse_qs
query = &quot;name=satori&amp;age=17&quot;
# parse_qs 接收的不是完整的 URL
# 而是只包含查询参数相关的部分
print(parse_qs(query))
&quot;&quot;&quot;
{'name': ['satori'], 'age': ['17']}
&quot;&quot;&quot;

# 如果是完整的 URL，那么需要使用 urlparse 获取查询参数
url = &quot;http://www.baidu.com?id=ae4432f&quot;
from urllib.parse import urlparse
print(parse_qs(urlparse(url).query))
&quot;&quot;&quot;
{'id': ['ae4432f']}
&quot;&quot;&quot;

query = &quot;name=&amp;age=17&quot;
# 如果参数没有值，那么默认会忽略掉
# 但是可以通过指定 keep_blank_values=True 来改变这一点
print(parse_qs(query))
print(parse_qs(query, keep_blank_values=True))
&quot;&quot;&quot;
{'age': ['17']}
{'name': [''], 'age': ['17']}
&quot;&quot;&quot;

# 相同参数也可以指定多次
query = &quot;name=&amp;name=&amp;name=古明地觉&quot;
print(parse_qs(query, keep_blank_values=True))
&quot;&quot;&quot;
{'name': ['', '', '古明地觉']}
&quot;&quot;&quot;
</code></pre>
<p>除了 parse_qs 之外，还有一个 parse_qsl，只不过返回的是列表。</p>
<pre><code class="language-python">from urllib.parse import parse_qs, parse_qsl

query = &quot;name=satori&amp;age=17&amp;name=koishi&quot;
print(parse_qs(query))
print(parse_qsl(query))
&quot;&quot;&quot;
{'name': ['satori', 'koishi'], 'age': ['17']}
[('name', 'satori'), ('age', '17'), ('name', 'koishi')]
&quot;&quot;&quot;
</code></pre>
<p>以上就是 urllib.parse 模块的基本用法，可以看到，在处理 URL 的时候还是很方便的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-9"><a class="header" href="#楔子-9">楔子</a></h2>
<p>pandas 里面有一个 pd.read_clipboard 函数，可以根据你复制的内容生成DataFrame。是的，就是我们平时选中，然后 Ctrl+C 时拷贝的内容。所以比较神奇，那么 pandas 到底是怎么做到的，它是怎么读出我们使用 Ctrl +C 复制的内容呢。</p>
<p>看了一下源码，不同的操作系统使用的复制方式不同，Windows 比较复杂，方法是使用了ctypes，然后调用了操作系统的一个动态库实现的；而 macOS 和 Linux 比较简单，调用的是内置的命令。</p>
<p>下面我们来看看如何在这三个系统上实现复制粘贴的功能。</p>
<h2 id="windows-上的复制粘贴"><a class="header" href="#windows-上的复制粘贴">Windows 上的复制粘贴</a></h2>
<p>我们说 Windows 是使用 ctypes 调用动态库实现的，比较麻烦。但是我们知道 Python 有一个 pywin32 模块，对于 Windows 操作系统提供的接口进行了封装。所以在 Windows 上我们会使用 pywin32 来实现复制粘贴功能。</p>
<p>该模块直接通过 pip install pywin32 安装即可。</p>
<pre><code class="language-python">import win32clipboard as wcb
import win32con as wc

# 打开复制粘贴板
wcb.OpenClipboard()
# 我们之前可能已经 Ctrl + C 了
# 这里是清空目前 Ctrl + C 复制的内容
# 但显然没有这一步也无所谓，因为第二次复制会覆盖第一次复制的内容
wcb.EmptyClipboard()
# 将内容写入复制粘贴板，第一个参数是 win32con.CF_TEXT
# 第二个参数是要复制的内容，编码的时候指定为 &quot;gbk&quot;
wcb.SetClipboardData(wc.CF_TEXT, &quot;古明地觉&quot;.encode(&quot;gbk&quot;))
# 关闭复制粘贴板
wcb.CloseClipboard()
</code></pre>
<p>然后 Ctrl+V 粘贴就会得到 &quot;古明地觉&quot; 这个字符串，另外编码的时候要使用 gbk，因为我当前操作系统默认编码使用的是 gbk，所以会对输入的字节使用 gbk 解码。因此如果使用 utf-8 编码的话，那么粘贴之后得到的就会是乱码。当然具体编码根据你当前的机器决定。</p>
<p>复制我们实现了，下面来看看怎么实现粘贴。</p>
<pre><code class="language-python">import win32clipboard as wcb
import win32con as wc

wcb.OpenClipboard()
# 获取粘贴板内容，既然是获取，那么只需要一个参数即可
# 会返回已经使用 Ctrl + C 复制的内容
data = wcb.GetClipboardData(wc.CF_TEXT)
# 关闭复制粘贴板
wcb.CloseClipboard()

# 然后随便 Ctrl+C 拷贝一段内容
# 下面就会将拷贝的内容打印出来
print(data.decode(&quot;gbk&quot;))
</code></pre>
<p>还是很简单的，我们上面使用的模块是 win32 系列，所以它只适用于 Windows 系统。那如果我想在 Linux 和 macOS 中实现怎么办呢？也很简单，事实上，这两个系统实现起来反而会更简单，因为自带了相关的命令。</p>
<h2 id="macos-上的复制粘贴"><a class="header" href="#macos-上的复制粘贴">macOS 上的复制粘贴</a></h2>
<p>macOS 自带了相关命令，我们只需要通过 subprocess 模块去调用即可，举个例子：</p>
<p><img src="Python%20%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/./1.png" alt="" /></p>
<p>非常简单，那么代码要如何实现呢？</p>
<pre><code class="language-python">import subprocess

# 实现拷贝
def copy(text):
    p = subprocess.Popen([&quot;pbcopy&quot;, &quot;w&quot;],
                         stdin=subprocess.PIPE,
                         close_fds=True)
    # 将内容拷贝起来，注意 macOS 的编码默认是 utf-8
    p.communicate(input=text.encode(&quot;utf-8&quot;))

# 实现粘贴
def paste():
    p = subprocess.Popen([&quot;pbpaste&quot;, &quot;r&quot;],
                         stdout=subprocess.PIPE,
                         close_fds=True)
    stdout, stderr = p.communicate()
    # 返回粘贴内容
    return stdout.decode(&quot;utf-8&quot;)

copy(&quot;古明地觉的编程教室&quot;)
print(paste())  # 古明地觉的编程教室
</code></pre>
<p>以上代码在 macOS 上执行，由于自带了复制粘贴相关的命令，操作起来就比 Windows 方便多了。</p>
<h2 id="linux-上的复制粘贴"><a class="header" href="#linux-上的复制粘贴">Linux 上的复制粘贴</a></h2>
<p>Linux 也提供了复制粘贴的命令，叫 xclip，但这个命令不是自带的，我们需要使用 yum 安装。</p>
<pre><code class="language-python">import subprocess

# 实现拷贝
def copy(text):
    p = subprocess.Popen(
        [&quot;xclip&quot;, &quot;-selection&quot;, &quot;c&quot;], 
        stdin=subprocess.PIPE, close_fds=True
    )
    p.communicate(input=text.encode(&quot;utf-8&quot;))

# 实现粘贴   
def paste():
    p = subprocess.Popen(
        [&quot;xclip&quot;, &quot;-selection&quot;, &quot;c&quot;, &quot;-o&quot;], 
        stdout=subprocess.PIPE, close_fds=True
    )
    stdout, stderr = p.communicate()
    return stdout.decode(&quot;utf-8&quot;)  
</code></pre>
<p>但其实在 Linux 上通过命令实现复制粘贴没什么意义，因为我们都是通过 SSH 远程连接到公司的服务器，这种情况下 xclip 是不生效的。</p>
<p><img src="Python%20%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/./2.png" alt="" /></p>
<p>当然，感觉这个功能也没多大用，当做兴趣了解一下就行。</p>
<h2 id="pyperclip-实现复制粘贴"><a class="header" href="#pyperclip-实现复制粘贴">pyperclip 实现复制粘贴</a></h2>
<p>最后我们再来介绍一个模块，叫 pyperclip，它对不同的操作系统的复制粘贴功能进行了封装，可以简化我们的操作。举个例子：</p>
<pre><code class="language-python">import pyperclip

# 复制
pyperclip.copy(&quot;哼哼&quot;)
# 粘贴
print(pyperclip.paste())  # 哼哼 
</code></pre>
<p>还是很方便的，以后就可以使用这个模块，自动帮我们屏蔽了操作系统间的差异。另外，这个模块只支持复制文本。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-10"><a class="header" href="#楔子-10">楔子</a></h2>
<p>二维码在我们的生活中可以说是必不可少的，不单单是手机支付，其它很多地方也都需要扫描二维码，比如健康宝。那么下面我们就来看看如何使用 Python 来生成二维码，以及识别二维码。</p>
<p>关于二维码，我们来说一下它的结构。当然关于二维码的结构其实不是太重要，这里只是提一下，没兴趣可以不用看。</p>
<p><img src="Python%20%E7%94%9F%E6%88%90%E3%80%81%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81/./1.png" alt="" /></p>
<p>从图中我们可以看出，二维码结构整体可以划分为功能图形和编码区两大部分，功能图形又细分为：空白区、位置探测图形、位置探测图形分隔符、定位图形、校正图形；而编码区细分为：格式信息、版本信息、数据和纠错码字，来简单了解一下每一部分的功能：</p>
<ul>
<li>空白区：留白，不需要做任何处理</li>
<li>位置探测图形：协助扫描软件定位二维码码</li>
<li>位置探测图形分隔符：区分功能图形和编码区</li>
<li>定位图形：指示标识密度和确定坐标系</li>
<li>校正图形：校正图形的数量和位置</li>
<li>格式信息：存放格式化数据的信息</li>
<li>版本信息：二维码的规格，二维码符号共有 40 种规格的矩阵</li>
<li>数据和纠错码字：实际保存的二维码信息和纠错码字（用于修正二维码损坏带来的错误）</li>
</ul>
<h2 id="生成二维码"><a class="header" href="#生成二维码">生成二维码</a></h2>
<p>生成二维码的话，Python 有两个第三方模块：qrcode 和 MyQR，可以帮我们生成二维码，下面来看一下这两个模块的用法。</p>
<p>生成比较简单的二维码就是，当我们扫描的时候，会自动跳转到某个页面。</p>
<pre><code class="language-python">import qrcode
               
# 创建 QRCode 实例
qr = qrcode.QRCode()  

# 调用 add_data，指定 url。
qr.add_data(&quot;https://www.baidu.com/&quot;)
# 生成二维码图像，颜色为蓝色，背景色为粉色
img = qr.make_image(fill_color='blue', back_color='pink')
# 显示图像，会打开一个临时文件
img.show()
# 当然我们也可以保存到硬盘上
img.save(&quot;qrcode.png&quot;)

# 事实上这个 img 是通过 PIL 模块得到的
# 所以也可以将它保存为图片对应的字节流
from io import BytesIO

buf = BytesIO()
img.save(buf)  # 将字节流保存到buf里面
with open(&quot;qrcode2.png&quot;, &quot;wb&quot;) as f:
    # 和直接保存为 qrcode.png 是一样的
    f.write(buf.getvalue())  
</code></pre>
<p><img src="Python%20%E7%94%9F%E6%88%90%E3%80%81%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81/./2.png" alt="" /></p>
<p>此时我们就生成了一个二维码，当扫描该二维码的时候就会跳转到百度。另外我们在 add_data 中指定的是一个 url，我们也可以不指定 url，而是指定一段文字。这样的话，当扫描的时候就会显示我们输入的文字。</p>
<p>最后再来说一下 QRCode 这个类，它里面还支持一些参数，我们看一下。</p>
<ul>
<li>version：二维码的格子大小，可以是1到 40。值越大，格子越大，一般不超过 10，选择 3 比较合适。</li>
<li>error_correction：能够容忍的错误率，可选值如下。
<ul>
<li>qrcode.constants.ERROR_CORRECT_M，默认值，允许小于 15% 的错误率。</li>
<li>qrcode.constants.ERROR_CORRECT_L，允许小于 7% 的错误率。</li>
<li>qrcode.constants.ERROR_CORRECT_H，允许小于 30% 的错误率。</li>
</ul>
</li>
<li>box_size：二维码每个小格子包含的像素数量。</li>
<li>border：二维码到图片边框的小格子数，默认值为 4。</li>
</ul>
<p>参数可以根据实际情况进行选择。</p>
<p>以上 qrcode 模块生成二维码，下面来看看 MyQR 生成二维码，它和 qrcode 相比，最大的特点就是可以嵌入图片当背景。</p>
<pre><code class="language-python">from MyQR import myqr

# 主要用到以下几个参数
# words: 可以是一个链接，或者你想说的话(不支持中文)
# picture：你用到的图片，作为背景，不然只是一个光秃秃的二维码
# colorsize：True，表示生成彩图
# save_name：表示生成的二维码图片的名字
myqr.run(words=&quot;http://www.bilibili.com&quot;,
         picture=&quot;satori.jpg&quot;,
         colorized=True,
         save_name=&quot;bilibili.png&quot;)
</code></pre>
<p><img src="Python%20%E7%94%9F%E6%88%90%E3%80%81%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81/./3.png" alt="" /></p>
<p>当扫描这个二维码的时候，就会跳转到 bilibili。值得一提的是，这里的图片还可以使用 gif 格式的动图，当然生成的图片也要是 gif 格式的。</p>
<p>另外这里生成的二维码都是跳转到一个网址，你也可以写上一段你想说的话，扫描之后会显示出来。但如果要支持中文的话，应该使用 qrcode。</p>
<h2 id="解析二维码"><a class="header" href="#解析二维码">解析二维码</a></h2>
<p>除了使用 Python 生成二维码，还可以解析二维码，解析二维码也有两个模块，一个是 zxing，一个是 pyzbar。</p>
<p>首先是 zxing，这个模块有点让人尴尬，因为这个模块调用的是 Java 的接口。也就是说解析二维码的底层工作是 Java 做的，Python 只是负责调用，所以使用这个模块的时候需要你本地有 Java环境。</p>
<pre><code class="language-python">&gt;&gt;&gt; import zxing
&gt;&gt;&gt; reader = zxing.BarCodeReader()
&gt;&gt;&gt; barcode = reader.decode('bilibili.png')
&gt;&gt;&gt; barcode.parsed
'http://www.bilibili.com'  # 是可以解析出来的
&gt;&gt;&gt;
</code></pre>
<p>然后看看 pyzbar 模块，这个模块就不需要 Java 了，直接使用 Python 即可。</p>
<pre><code class="language-python">from PIL import Image
from pyzbar import pyzbar

im = Image.open(&quot;bilibili.png&quot;)
print(pyzbar.decode(im))
# 返回的信息还是很多的
&quot;&quot;&quot;
[
     Decoded(data=b'http://www.bilibili.com',
             type='QRCODE',
             rect=Rect(left=35, top=35, width=263, height=264),
             polygon=[Point(x=35, y=35), Point(x=35, y=297), 
                      Point(x=297, y=299), Point(x=298, y=35)])
]
&quot;&quot;&quot;

# 拿到内容
print(
    pyzbar.decode(im)[0].data.decode(&quot;utf-8&quot;)
)  # http://www.bilibili.com
</code></pre>
<p>两个模块都是可以正常解析的，以上就是 Python 关于二维码的一些操作。</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="__getattr__"><a class="header" href="#__getattr__">__getattr__</a></h3>
<p>当访问实例对象的某个不存在的属性时，毫无疑问会报错，会抛出 AttributeError。</p>
<pre><code class="language-python">class A:
    pass

a = A()
a.xxx
&quot;&quot;&quot;
AttributeError: 'A' object has no attribute 'xxx'
&quot;&quot;&quot;
</code></pre>
<p>但如果我们希望在找不到某个属性时，不要报错，而是返回默认值，该怎么做呢？这个时候我们就需要定义 __getattr__ 方法了，当实例对象找不到某个属性时会执行此方法。</p>
<pre><code class="language-python">class Girl:

    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 17

    def get_info(self):
        return f&quot;name: {self.name}, age: {self.age}&quot;

    def __getattr__(self, item):
        return f&quot;你访问了 {item} 属性&quot;


girl = Girl()
print(girl.name, girl.age)  # 古明地觉 17
print(girl.get_info)  # &lt;bound method Girl.get_info...&gt;
print(girl.get_info())  # name: 古明地觉, age: 17

print(girl.xxx)  # 你访问了 xxx 属性
print(girl.yyy)  # 你访问了 yyy 属性
print(girl.zzz)  # 你访问了 zzz 属性
</code></pre>
<p>所以非常简单，就是当实例对象访问了一个不存在的属性时，会执行 __getattr__ 方法。当然，如果属性存在的话，就不会执行了，而是返回相应的值。</p>
<p>此外 __getattr__ 还有一个用法，就是在模块导入的时候。假设我们有一个 tools.py，里面代码如下：</p>
<pre><code class="language-python">def __getattr__(name):
    return f&quot;{__name__} 中不存在 {name}&quot;

name = &quot;古明地觉&quot;
age = 17
</code></pre>
<p>相信你明白它是干什么的了，我们来导入它：</p>
<pre><code class="language-python">from tools import name, age, xxx, yyy

print(name, age)  # 古明地觉 17
print(xxx)  # tools 中不存在 xxx
print(yyy)  # tools 中不存在 yyy

import tools
print(tools.zzz)  # tools 中不存在 zzz
</code></pre>
<p>在获取 tools.py 里面的属性时，如果不存在，那么同样会去执行 __getattr__，应该还是很简单的。</p>
<h3 id="__getattribute__"><a class="header" href="#__getattribute__">__getattribute__</a></h3>
<p>__getattribute__ 被称为属性拦截器，它比 __getattr__ 要霸道的多，这两者的区别如下：</p>
<ul>
<li>__getattr__：当访问的属性不存在时，才会执行此方法；</li>
<li>__getattribute__：不管访问的属性是否存在，一律执行此方法；</li>
</ul>
<p>我们举个例子：</p>
<pre><code class="language-python">class Girl:

    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 17

    def __getattribute__(self, item):
        return f&quot;获取属性: {item}&quot;


girl = Girl()
print(girl.name)  # 获取属性: name
print(girl.age)  # 获取属性: age
print(girl.xxx)  # 获取属性: xxx

# 即便你想通过属性字典获取也是没有用的
# 因为不管什么属性，都会执行 __getattribute__
print(girl.__dict__)  # 获取属性: __dict__
</code></pre>
<p>并且在使用这个方法的时候，一定要谨慎，因为你一不小心就会陷入无限递归。</p>
<pre><code class="language-python">class Girl:

    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 17

    def __getattribute__(self, item):
        return getattr(self, item)


girl = Girl()
print(girl.name)
# 显然上面的代码会陷入无限递归
# 因为 girl.name 会调用 __getattribute__
# 而在里面又执行了 getattr(self, item)，还是在获取属性
# 所以又会调用 __getattribute__，于是会无限递归

# 可能有人说，那我换一种方式
# 我将 getattr(self, item) 改成 self.__dict__[item] 可以吗
# 答案也是不行的，因为 self.__dict__ 仍是在获取属性
# 只要获取属性，就会触发 __getattribute__，依旧会陷入无限递归
</code></pre>
<p>所以 __getattribute__ 非常霸道，那么我们如何使用它呢？答案是通过父类。</p>
<pre><code class="language-python">class Girl:

    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 17

    def __getattribute__(self, item):
        return super().__getattribute__(item)


girl = Girl()
print(girl.name)
print(girl.age)
try:
    girl.xxx
except AttributeError:
    print(&quot;属性 xxx 不存在&quot;)
&quot;&quot;&quot;
古明地觉
17
属性 xxx 不存在
&quot;&quot;&quot;
</code></pre>
<p>当我们调用父类的 __getattribute__ 时，如果属性存在，它会直接返回；如果实例没有该属性，那么会检测我们是否定义了 __getattr__，定义了则执行，没定义则抛出 AttributeError。我们将这两个方法结合起来，看一个例子：</p>
<pre><code class="language-python">class Girl:

    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 17

    def __getattr__(self, item):
        print(f&quot;__getattr__ {item}&quot;)
        return f&quot;获取属性 {item}&quot;

    def __getattribute__(self, item):
        print(f&quot;__getattribute__ {item}&quot;)
        return super().__getattribute__(item)


girl = Girl()
# 不管属性是否存在，一律调用 __getattribute__
# 然后在里面我们又调用了父类的 __getattribute__
# 那么会检测属性是否存在，存在则直接获取对应的值，然后返回
print(girl.name)
&quot;&quot;&quot;
__getattribute__ name
古明地觉
&quot;&quot;&quot;
# age 也是相同的逻辑，和 name 一样，这两个属性都是存在的
print(girl.age)
&quot;&quot;&quot;
__getattribute__ age
17
&quot;&quot;&quot;

# 依旧执行 __getattribute__，然后调用父类的 __getattribute__
# 由于属性 xxx 不存在，于是会执行 __getattr__
print(girl.xxx)
&quot;&quot;&quot;
__getattribute__ xxx
__getattr__ xxx
获取属性 xxx
&quot;&quot;&quot;
</code></pre>
<p>那么问题来了，这个 __getattribute__ 有啥用呢？该方法被称为属性拦截器，显然它可以起到一个控制属性访问权限的作用。</p>
<pre><code class="language-python">class Girl:

    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 17

    def __getattr__(self, item):
        return f&quot;属性 {item} 不存在&quot;

    def __getattribute__(self, item):
        if item == &quot;age&quot;:
            return &quot;女人芳龄不可泄露，别问，问就是还不到 18 岁&quot;
        return super().__getattribute__(item)


girl = Girl()
# name 属性存在，所以在 __getattribute__ 中直接返回
print(girl.name)
&quot;&quot;&quot;
古明地觉
&quot;&quot;&quot;
# age 也是如此，也是在 __getattribute__ 中直接返回
# 只不过它相当于被拦截了
print(girl.age)
&quot;&quot;&quot;
女人芳龄不可泄露，别问，问就是还不到 18 岁
&quot;&quot;&quot;
# 父类在执行 __getattribute__ 的时候，发现 xxx 属性不存在
# 于是会触发 __getattr__ 的执行（如果没定义则抛出 AttributeError）
print(girl.xxx)
&quot;&quot;&quot;
属性 xxx 不存在
&quot;&quot;&quot;
</code></pre>
<p>所以 __getattribute__ 就相当于一个属性拦截器，不管获取啥属性，都要先经过它。如果你发现有一些属性不想让外界访问，那么直接拦截掉即可，比如上面代码中的 age 属性。</p>
<p>然后对于那些可以让外界访问的属性，则需要调用父类的 __getattribute__ 帮我们去获取（因为我们手动获取的话会陷入无线递归），并且在获取不存在的属性时也会自动执行 __getattr__。</p>
<p>当然啦，除了属性，方法也是一样的。</p>
<pre><code class="language-python">class Girl:

    def __init__(self):
        self.name = &quot;古明地觉&quot;
        self.age = 17

    def get_info(self):
        return f&quot;name: {self.name}, age: {self.age}&quot;

    def __getattribute__(self, item):
        if item == &quot;get_info&quot;:
            return &quot;此方法禁止获取&quot;
        return super().__getattribute__(item)


girl = Girl()
print(girl.get_info)
&quot;&quot;&quot;
此方法禁止获取
&quot;&quot;&quot;
# 默认情况下 girl.get_info 拿到的是一个方法
# 然后再加上小括号就会执行该方法
# 但在 __getattribute__ 中我们将其拦截了，并返回一个字符串
# 所以此时 girl.get_info() 就会报错，因为字符串无法被调用
</code></pre>
<p>以上就是 __getattr__ 和 __getattribute__ 的区别与用法，在工作中看看能不能让它们派上用场。不过说实话，__getattr__ 用的还是蛮频繁的，而 __getattribute__ 则用的不多，至少我就很少用。</p>
<div style="break-before: page; page-break-before: always;"></div><p>当我们在读写文件的时候，如果该文件同时还被另一个进程操作，那么很容易出现混乱。这时候就需要加锁了，正如操作数据库表的时候需要加锁一样。</p>
<p>而 Python 提供了一个库 fcntl，通过 fcntl.flock 函数即可实现对文件进行加锁和解锁。</p>
<blockquote>
<p>注意：这个模块目前不支持 Windows，我们只能在类 Unix 下使用。</p>
</blockquote>
<p>fcntl.flock 接收两个参数，第一个参数是文件描述符，第二个参数是 operation。常见的 operation 如下：</p>
<ul>
<li>fcntl.LOCK_SH：共享锁，所有进程都可以对当前文件施加共享锁；</li>
<li>fcntl.LOCK_EX：排他锁，只能有一个进程对当前文件施加排他锁，其他进程在施加的时候会阻塞；</li>
<li>fcntl.LOCK_UN：对加锁文件进行解锁；</li>
<li>fcntl.LOCK_MAND：共享模式强制锁，可以和 LOCK_READ 或者 LOCK_WRITE 联合起来使用，从而表示是否允许并发的读操作或者并发的写操作(基本不用)；</li>
<li>fcntl.LOCK_NB：非阻塞锁，如果指定此参数，函数不能获得文件锁就立即返回；否则函数会等待获得文件锁，LOCK_NB 可以同 LOCK_SH、LOCK_EX 结合使用；</li>
</ul>
<p>例如：如果一个文件设置了排他锁：</p>
<pre><code class="language-python">fcntl.flock(f.fileno(), fcntl.LOCK_EX)
</code></pre>
<p>那么当其它进程在请求获取这个锁的时候就会一直阻塞在这里。</p>
<p>但如果和 LOCK_NB 结合起来使用：</p>
<pre><code class="language-python">fcntl.flock(f.fileno(), fcntl.LOCK_EX | fnctl.LOCK_NB)
</code></pre>
<p>那么其它进程在获取不到锁的时候就直接返回了。</p>
<blockquote>
<p>需要注意的是，在给文件加锁之前,一定要保证文件以相应的访问模式打开。</p>
<p>比如共享锁是让所有进程对文件只有读权限，那么在加共享锁的时候要保证文件以读方式打开；加上排他锁的时候，文件要以可写的形式打开。</p>
</blockquote>
<p>下面举例说明，由于 fcntl 不支持 Windows，我们在 Linux 上测试。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20fcntl%20%E6%A8%A1%E5%9D%97%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E9%94%81/./1.png" alt="" /></p>
<p>开启一个终端，打开 1.txt 并加上排他锁，而一旦施加了排他锁，其它进程就不能再加锁了（包括共享锁）。</p>
<p>这里再开启一个终端，测试一下：</p>
<p><img src="%E4%BD%BF%E7%94%A8%20fcntl%20%E6%A8%A1%E5%9D%97%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E9%94%81/./2.png" alt="" /></p>
<p>进程 1 已经施加了排他锁，进程 2 再加锁的话就会阻塞，不管是共享锁还是排他锁都会阻塞。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20fcntl%20%E6%A8%A1%E5%9D%97%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E9%94%81/./3.png" alt="" /></p>
<p>然后我们再回到进程 1，将锁释放掉。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20fcntl%20%E6%A8%A1%E5%9D%97%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E9%94%81/./4.png" alt="" /></p>
<p>再来看看进程 2：</p>
<p><img src="%E4%BD%BF%E7%94%A8%20fcntl%20%E6%A8%A1%E5%9D%97%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E9%94%81/./5.png" alt="" /></p>
<p>此时已经不再阻塞了，因为第一个终端把锁解除了。</p>
<p>我们说设置了排他锁的话，其它进程在获取不到锁的时候会阻塞，但如果和 fcntl.LOCK_NB 结合使用的话，在获取不到锁的时候会直接返回。</p>
<p>进程 1 释放锁之后，已经被进程 2 获取，此时进程 2 给文件施加了排他锁，然后我们继续尝试在进程 1 获取。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20fcntl%20%E6%A8%A1%E5%9D%97%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E9%94%81/./6.png" alt="" /></p>
<p>因为此时获取不到锁，所以直接返回，告诉我们资源不可用。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-11"><a class="header" href="#楔子-11">楔子</a></h2>
<p>本次我们来聊一聊 httpx，它是一个 HTTP 请求库。不过说到发送 HTTP 请求，我们首先想到的应该是 requests，但 requests 是一个同步库，目前只能同步发请求。而 httpx 不仅可以同步发请求，还可以异步发请求，并且支持 HTTP/1.1 和 HTTP/2。</p>
<p>另外 httpx 在设计上也模仿了 requests，两者的 API 是兼容的，如果你会 requests，那么 httpx 很容易上手。</p>
<blockquote>
<p>安装方式：直接 pip install httpx 即可</p>
</blockquote>
<p>下面就来看一下相关用法。</p>
<h2 id="使用-httpx-发请求"><a class="header" href="#使用-httpx-发请求">使用 httpx 发请求</a></h2>
<p>使用 httpx 发送请求非常简单，首先请求有以下几种：</p>
<p><img src="%E8%AF%A6%E8%A7%A3%E6%96%B0%E4%B8%80%E4%BB%A3%20HTTP%20%E8%AF%B7%E6%B1%82%E5%BA%93%EF%BC%9Ahttpx/./1.png" alt="" /></p>
<p>API 和 requests 是相似的，我们以 GET 请求为例，测试一下：</p>
<pre><code class="language-python">import httpx

# 发送请求，会返回一个 httpx.Response 对象
response = httpx.get(&quot;http://www.baidu.com&quot;)
print(response)
print(response.__class__)
&quot;&quot;&quot;
&lt;Response [200 OK]&gt;
&lt;class 'httpx.Response'&gt;
&quot;&quot;&quot;
</code></pre>
<p>当然其它请求也是类似的，我们一会儿会说。不过虽然请求种类有很多，但不管发送的是哪一种请求，背后调用的都是 httpx.request。</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://www.baidu.com&quot;)
# 等价于如下：
response = httpx.request(&quot;GET&quot;, &quot;http://www.baidu.com&quot;)

# 同理：
&quot;&quot;&quot;
httpx.post(url) 等价于 httpx.request(&quot;POST&quot;, url)
httpx.put(url) 等价于 httpx.request(&quot;PUT&quot;, url)
httpx.delete(url) 等价于 httpx.request(&quot;DELETE&quot;, url)
&quot;&quot;&quot;
</code></pre>
<p>因此我们调用 httpx.request 即可发送所有类型的请求，但为了方便使用，httpx 又专门针对不同的请求，封装了相应的函数。比如我们要发送 get 请求，那么直接调用 httpx.get 就好。</p>
<h2 id="服务端响应httpxresponse"><a class="header" href="#服务端响应httpxresponse">服务端响应（httpx.Response）</a></h2>
<p>当服务端收到请求并处理完毕之后，会给客户端返回响应，而这里的客户端显然就是 httpx。httpx 收到响应之后，会将其包装成  Response 对象。</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://www.baidu.com&quot;)
print(response)
print(response.__class__)
&quot;&quot;&quot;
&lt;Response [200 OK]&gt;
&lt;class 'httpx.Response'&gt;
&quot;&quot;&quot;
</code></pre>
<p>那么这个 Response 对象内部都包含了哪些属性呢？我们来总结一下。</p>
<p><font color="darkblue"><strong>url：客户端请求的 URL</strong></font></p>
<pre><code class="language-python">print(response.url)
&quot;&quot;&quot;
http://www.baidu.com
&quot;&quot;&quot;
</code></pre>
<p>注意：通过 response.url 拿到的不是字符串，而是一个 httpx.URL 对象，我们可以很方便地获取 URL 的每一个组成部分。</p>
<pre><code class="language-python">response = httpx.get(&quot;http://www.baidu.com&quot;)
url = response.url
print(
    url.scheme,
    url.host,
    url.port,
    url.username,
    url.password,
    url.netloc,
    url.path
)
</code></pre>
<p><font color="darkblue"><strong>status_code：状态码，比如请求成功返回 200</strong></font></p>
<pre><code class="language-python">print(response.status_code)
&quot;&quot;&quot;
200
&quot;&quot;&quot;
</code></pre>
<p>Response 对象还有一个 raise_for_status() 方法，如果状态码不在 200 ~ 299 之间，那么调用的时候会根据状态码的值，抛出相应的异常来提示开发者。</p>
<p><font color="darkblue"><strong>reason_phrase：状态码的文字描述</strong></font></p>
<pre><code class="language-python"># 一般跟在状态码后面，比如 200 OK，404 NOT FOUND
print(response.reason_phrase)
&quot;&quot;&quot;
OK
&quot;&quot;&quot;
</code></pre>
<p><font color="darkblue"><strong>headers：响应头，返回的是 httpx.Headers 对象。我们将它当成字典来用即可，但会忽略 key 的大小写</strong></font></p>
<pre><code class="language-python">print(response.headers[&quot;Content-Type&quot;])
print(response.headers[&quot;CONTENT-TYPE&quot;])
print(response.headers.get(&quot;content-TYPE&quot;))
&quot;&quot;&quot;
text/html
text/html
text/html
&quot;&quot;&quot;
# 也可以调用 dict 转成字典，但转成字典之后，key 一律全部小写
print(dict(response.headers)[&quot;content-type&quot;])
&quot;&quot;&quot;
text/html
&quot;&quot;&quot;
</code></pre>
<p><font color="darkblue"><strong>content：响应体，一个原始的字节流</strong></font></p>
<pre><code class="language-python">print(&quot;百度一下&quot;.encode(&quot;utf-8&quot;) in response.content)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<p><font color="darkblue"><strong>text：对响应体进行解码所得到的字符串</strong></font></p>
<pre><code class="language-python"># 相当于对 response.content 进行 decode
print(&quot;百度一下&quot; in response.text)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<p><font color="darkblue"><strong>json：对响应体进行 JSON 解析所得到的字典</strong></font></p>
<pre><code class="language-python"># 相当于 json.loads(response.content)
# 因此服务端返回的响应体数据必须满足 JSON 格式，否则报错
try:
    print(response.json())
except Exception:
    print(&quot;返回的数据不符合 JSON 格式&quot;)
&quot;&quot;&quot;
返回的数据不符合 JSON 格式
&quot;&quot;&quot;
# httpx 在解析 JSON 的时候，使用的是内置的 json 库
# 但这个库的性能不好，因此推荐一个第三方库叫 orjson，是基于 Rust 编写的
# 个人觉得它是目前性能最好、使用最方便的 JSON 解析库
# 所以我个人习惯先获取 content，然后手动调用 orjson.loads 进行解析
</code></pre>
<p><font color="darkblue"><strong>cookies：服务端返回的 cookie，一个 httpx.Cookies 对象</strong></font></p>
<pre><code class="language-python"># 可以调用 dict，将其转成字典，也可以直接当成字典来操作
# 注意，对于 Cookie 而言，大小写是敏感的
print(response.cookies[&quot;PSTM&quot;])
print(response.cookies.get(&quot;pstm&quot;))
&quot;&quot;&quot;
1676011925
None
&quot;&quot;&quot;
</code></pre>
<p><font color="darkblue"><strong>encoding：返回网站的编码，没有的话则使用 utf-8</strong></font></p>
<pre><code class="language-python"># response.text 就等价于
# response.content.decode(response.encoding)
print(response.encoding)
&quot;&quot;&quot;
utf-8
&quot;&quot;&quot;
</code></pre>
<p>基于以上这些字段，我们可以获取服务端响应的全部信息。既然服务端的响应可以拿到，那客户端请求该如何获取呢？</p>
<h2 id="客户端请求httpxrequest"><a class="header" href="#客户端请求httpxrequest">客户端请求（httpx.Request）</a></h2>
<p>调用 httpx.get 的时候，内部会构建一个请求，然后直接发给服务端，而请求我们也可以通过 response 来获取。</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://www.baidu.com&quot;)
# 客户端请求是一个 httpx.Request 对象
# 我们可以通过 response.request 获取
request = response.request
print(request)
print(request.__class__)
&quot;&quot;&quot;
&lt;Request('GET', 'http://www.baidu.com')&gt;
&lt;class 'httpx.Request'&gt;
&quot;&quot;&quot;

# 客户端请求的 URL，和 response.url 是一样的
print(request.url)
&quot;&quot;&quot;
http://www.baidu.com
&quot;&quot;&quot;

# 请求方式
print(request.method)
&quot;&quot;&quot;
GET
&quot;&quot;&quot;

# 客户端发送请求时的请求头，一个 httpx.Headers 对象
# 而 response.header 是服务端返回响应时的响应头
print(request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
python-httpx/0.23.3
&quot;&quot;&quot;

# 请求体，这里是 GET 请求，所以请求体为空
print(request.content)
&quot;&quot;&quot;
b''
&quot;&quot;&quot;
</code></pre>
<p>所以 HTTP 的核心就是：客户端发送请求，服务端返回响应。请求包含请求头、请求体，响应包含响应头、响应体。</p>
<p>怎么发请求我们已经知道了，然后再来看看发请求时的一些更具体的细节。</p>
<h2 id="向服务端传递数据"><a class="header" href="#向服务端传递数据">向服务端传递数据</a></h2>
<p>在发送请求时，客户端还可以携带指定的数据给服务端。对于 GET 请求而言，数据是以查询参数的方式，拼接在 URL 的尾部。</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://www.baidu.com/s?wd=python&quot;)
print(response.url)

# 但上面的做法有些麻烦，我们可以让 httpx 帮我们拼接
response = httpx.get(&quot;http://www.baidu.com/s&quot;, params={&quot;wd&quot;: &quot;python&quot;})
print(response.url)
&quot;&quot;&quot;
http://www.baidu.com/s?wd=python
http://www.baidu.com/s?wd=python
&quot;&quot;&quot;

# 当然也可以传递多个参数
response = httpx.get(&quot;http://httpbin.org/get&quot;, params={&quot;k1&quot;: &quot;v1&quot;, &quot;k2&quot;: [&quot;v2&quot;, &quot;v3&quot;]})
print(response.url)  
&quot;&quot;&quot;
http://httpbin.org/get?k1=v1&amp;k2=v2&amp;k2=v3
&quot;&quot;&quot;
</code></pre>
<p>如果是 post 请求，则可以将数据放在请求体中，通过 data 或者 json 参数传递。至于参数选择哪一个，则看服务端要求是使用表单数据提交、还是使用 JSON 数据提交。</p>
<pre><code class="language-python">import httpx

# 传递表单数据，通过 data 参数
response = httpx.post(
    &quot;https://httpbin.org/post&quot;,
    data={&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 16}
)
# 查看请求体
print(response.request.content)
&quot;&quot;&quot;
b'name=satori&amp;age=16'
&quot;&quot;&quot;

# 传递 JSON 数据，通过 json 参数
response = httpx.post(
    &quot;https://httpbin.org/post&quot;,
    json={&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 16}
)
print(response.request.content)
&quot;&quot;&quot;
b'{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 16}'
&quot;&quot;&quot;
</code></pre>
<p>现在你一定明白表单数据和 JSON 数据之间的差异了，当然不管什么数据，无论是请求体还是响应体，都是一坨字节流。所谓的文本、字典，都是拿到字节流之后再进行解析所得到的，如果无法解析则返回错误。</p>
<p>比如上面的 POST 请求，如果通过 data 参数传递，那么服务端拿到的字节流就是下面这样：</p>
<pre><code class="language-python">b'name=satori&amp;age=16'
</code></pre>
<p>显然服务端应该通过表单的方式去解析，如果使用 JSON 库则解析失败。</p>
<p>如果客户端是通过 json 参数传递，那么服务端拿到的字节流就是下面这样：</p>
<pre><code class="language-python">b'{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 16}'
</code></pre>
<p>此时服务端可以放心地使用 json.loads。</p>
<p>对于客户端来说也是如此，比如这里的 httpx。如果明确服务端会返回 JSON，那么可以直接调用 response.json() 拿到字典；但如果返回的不是 JSON，那么就不能这么做，比如服务端返回的是图片、视频，我们只能以二进制的方式保存下来。</p>
<p>再补充一点，查询参数对于所有请求都是适用的，比如 POST 请求，我们也可以通过 params 指定查询参数。</p>
<pre><code class="language-python">import httpx

response = httpx.post(
    &quot;https://httpbin.org/post&quot;,
    params={&quot;ping&quot;: &quot;pong&quot;},
    json={&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 16}
)
print(response.url)
print(response.request.content)
&quot;&quot;&quot;
https://httpbin.org/post?ping=pong
b'{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 16}'
&quot;&quot;&quot;
</code></pre>
<p>结果没有问题。</p>
<h2 id="自定制请求头"><a class="header" href="#自定制请求头">自定制请求头</a></h2>
<p>很多网站，都设置了反爬虫机制。最常用的就是判断请求头里的 User-Agent 字段，如果不是浏览器的，会直接将你屏蔽掉。</p>
<pre><code class="language-python">import httpx, requests

response = httpx.get(&quot;http://www.baidu.com&quot;,)
print(response.request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
python-httpx/0.23.3
&quot;&quot;&quot;

response = requests.get(&quot;http://www.baidu.com&quot;,)
print(response.request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
python-requests/2.28.0
&quot;&quot;&quot;
</code></pre>
<p>无论是 httpx 还是 requests，都会设置一个默认的 User-Agent。但很明显，很容易被服务端检测出来，因此我们需要自定制请求头。</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://www.baidu.com&quot;,
                     headers={&quot;User-Agent&quot;: &quot;Chrome user agent&quot;})
print(response.request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
Chrome user agent
&quot;&quot;&quot;
</code></pre>
<p>此时 User-Agent 就被我们替换掉了，这里是我随便指定的，在真正发请求的时候，从浏览器里面拷贝一下即可。另外不仅是 User-Agent，请求头里的其它字段也是可以设置的。</p>
<blockquote>
<p>headers 参数不仅可以接收字典，还可以接收一个 httpx.Headers 对象</p>
</blockquote>
<h2 id="自定制-cookie"><a class="header" href="#自定制-cookie">自定制 cookie</a></h2>
<p>这个在模拟登录的时候非常有用，一般在输入用户名和密码登录成功之后，服务端会返回一个 cookie，这个 cookie 里面存储了 Session ID。后续浏览器发请求的时候，会带上这个 cookie，服务端检测到之后就知道该用户已经登录了。</p>
<p>那么 httpx 在发请求的时候，如何带上 cookie 呢？</p>
<pre><code class="language-python">from pprint import pprint
import httpx

cookies = httpx.Cookies({&quot;Session ID1&quot;: &quot;0000001&quot;})
# 也可以单独设置
cookies[&quot;Session ID2&quot;] = &quot;0000001&quot;
cookies.set(&quot;Session ID3&quot;, &quot;0000003&quot;, domain=&quot;&quot;, path=&quot;/&quot;)

response = httpx.get(&quot;http://httpbin.org/cookies&quot;,
                     # 这里也可以直接传一个字典
                     cookies=cookies)
pprint(response.json())
&quot;&quot;&quot;
{'cookies': {'Session ID1': '0000001',
             'Session ID2': '0000001',
             'Session ID3': '0000003'}}
&quot;&quot;&quot;
</code></pre>
<p>至于服务端返回的 cookie，可以通过 response.cookies 获取。比如模拟登录成功之后，将服务端返回的 cookie 保存下来，然后下一次发请求的时候带上它。</p>
<h2 id="重定向与请求历史"><a class="header" href="#重定向与请求历史">重定向与请求历史</a></h2>
<p>重定向分为暂时性重定向和永久性重定向。</p>
<ul>
<li>暂时性重定向：状态码为 302，比如我们要发表评论，但是没有登录，那么此时就会被重定向到登录页面；</li>
<li>永久性重定向：状态码为 301，比如我们访问一个已经废弃的域名，会被永久性重定向到新的域名。</li>
</ul>
<p>那我们怎么判断在访问的时候有没有重定向呢？如果被重定向了，那么如何获取重定向之前的页面呢？</p>
<pre><code class="language-python">import httpx, requests

# 如果是 requests，那么会自动重定向
# 会被重定向到 https://www.taobao.com
response = requests.get(&quot;http://www.taobao.com&quot;)
# 而 response 也是重定向之后返回的响应
print(response.status_code)
&quot;&quot;&quot;
200
&quot;&quot;&quot;
# 但通过 response.history 可以获取重定向之前的响应
# 因为可能会被重定向多次，因此返回的是列表
print(response.history)
&quot;&quot;&quot;
[&lt;Response [301]&gt;]
&quot;&quot;&quot;
print(response.history[0].text)
&quot;&quot;&quot;
&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;
&lt;p&gt;The requested resource has been assigned a new permanent URI.&lt;/p&gt;
&lt;hr/&gt;Powered by Tengine&lt;/body&gt;
&lt;/html&gt;
&quot;&quot;&quot;

# 但 httpx 不会自动重定向
response = httpx.get(&quot;http://www.taobao.com&quot;)
print(response.status_code)
print(response.history)
&quot;&quot;&quot;
301
[]
&quot;&quot;&quot;
# 如果希望重定向，那么需要指定一个参数
response = httpx.get(&quot;http://www.taobao.com&quot;, follow_redirects=True)
print(response.status_code)
print(response.history)
&quot;&quot;&quot;
200
[&lt;Response [301 Moved Permanently]&gt;]
&quot;&quot;&quot;
</code></pre>
<p>个人觉得 httpx 的这个设计不是很好，首先它和 requests 一样，都有一个参数用来控制是否重定向。</p>
<ul>
<li>requests 里面的参数叫 allow_redirects，默认为 True，表示允许重定向。如果不希望重定向，那么将其设置为 False；</li>
<li>httpx 里面的参数叫 follow_redirects，默认为 False，表示不进行重定向。如果希望重定向，那么将其设置为 True；</li>
</ul>
<p>但个人觉得，应该自动重定向会好一些。</p>
<h2 id="上传文件"><a class="header" href="#上传文件">上传文件</a></h2>
<p>如果服务端需要接收一个文件，那么我们应该怎么上传呢？比如我们有一个 1.txt，里面写着一句 Hello World，那这个 1.txt 要如何上传呢？</p>
<pre><code class="language-python">from pprint import pprint
import httpx

response = httpx.post(&quot;http://httpbin.org/post&quot;,
                      files={&quot;file&quot;: open(&quot;1.txt&quot;, &quot;rb&quot;)})

pprint(response.json())
&quot;&quot;&quot;
{'args': {},
 'data': '',
 'files': {'file': 'Hello World'},
 'form': {},
 'headers': {...},
 'json': None,
 'origin': '120.244.40.157',
 'url': 'http://httpbin.org/post'}
&quot;&quot;&quot;
</code></pre>
<p>http://httpbin.org/post 是一个专门用来测试 HTTP 请求的网站，根据返回结果我们知道文件上传成功了。</p>
<p>当然，在上传文件的时候，也可以显示地指定文件名和文件类型。</p>
<pre><code class="language-python">from pprint import pprint
import httpx

response = httpx.post(
    &quot;http://httpbin.org/post&quot;,
    files={&quot;file&quot;: (&quot;1.html&quot;, open(&quot;1.html&quot;, &quot;rb&quot;), &quot;text/html&quot;)}
)

pprint(response.json())
&quot;&quot;&quot;
{'args': {},
 'data': '',
 'files': {'file': '&lt;h1&gt;我是 HTML 文件&lt;/h1&gt;'},
 'form': {},
 'headers': {...},
 'json': None,
 'origin': '120.244.40.157',
 'url': 'http://httpbin.org/post'}
&quot;&quot;&quot;
</code></pre>
<p>我们也可以同时上传多个文件，并且上传文件的同时，还可以传递表单数据。</p>
<pre><code class="language-python">from pprint import pprint
import httpx

response = httpx.post(
    &quot;http://httpbin.org/post&quot;,
    files={&quot;file1&quot;: open(&quot;1.html&quot;, &quot;rb&quot;),
           &quot;file2&quot;: open(&quot;1.txt&quot;, &quot;rb&quot;)},
    data={&quot;ping&quot;: &quot;pong&quot;},
)

pprint(response.json())
&quot;&quot;&quot;
{'args': {},
 'data': '',
 'files': {'file1': '&lt;h1&gt;我是 HTML 文件&lt;/h1&gt;', 
           'file2': 'Hello World'},
 'form': {'ping': 'pong'},
 'headers': {...},
 'json': None,
 'origin': '120.244.40.157',
 'url': 'http://httpbin.org/post'}
&quot;&quot;&quot;
</code></pre>
<p>然后上传文件还有一种方式，就是我们可以将文件以二进制的方式读出来，然后将字节流传过去。</p>
<pre><code class="language-python">import httpx

with open(&quot;1.txt&quot;, &quot;rb&quot;) as f:
    content = f.read()

response = httpx.post(
    &quot;http://httpbin.org/post&quot;,
    content=content
)
</code></pre>
<p>前面我们说传递表单数据使用参数 data，传递 JSON 数据使用参数 json，如果是普通的字节流，那么应该使用参数 content。</p>
<p>当然这种方式的话，服务端只能拿到文件的字节流，但是类型并不知道。因此可以在 headers 参数里面，通过 Content-Type 告诉服务端字节流对应文件的类型。</p>
<h2 id="流式响应"><a class="header" href="#流式响应">流式响应</a></h2>
<p>到目前为止，我们都是调用 httpx 的请求函数发送 HTTP 请求（比如 GET、POST），服务端返回响应，然后通过 response.content 获取响应体。但如果响应体非常大，该怎么办？显然这会带来两个问题：</p>
<ul>
<li>1）程序在调用 httpx.get 或 httpx.post 的时候，会一直处于阻塞状态，直到服务端将数据一次性全部返回。而响应体如果比较大，那么阻塞的时间就会比较长。</li>
<li>2）如果服务端返回的数据过大，可能会导致内存不够用。</li>
</ul>
<p>所以需要有一种机制，能够不让数据一次性全部返回，而是分批返回。在 httpx 里面是支持的。</p>
<pre><code class="language-python">import httpx

# httpx.stream 和 httpx.request 的参数是一样的
# 可以传递 headers、cookies、data、json 等等
with httpx.stream(&quot;GET&quot;, &quot;http://www.baidu.com&quot;) as r:
    # 分块返回，每块 100KB
    for chunk in r.iter_bytes(chunk_size=1024 * 100):
        print(len(chunk))
&quot;&quot;&quot;
102400
102400
102400
62890
&quot;&quot;&quot;
</code></pre>
<p>通过分块读取，可以避免因响应体过大，而导致内存溢出。</p>
<h2 id="超时控制"><a class="header" href="#超时控制">超时控制</a></h2>
<p>httpx 有很多优秀的特性，其中一个就是超时控制。httpx 为所有的网络操作都提供了一个合理的超时时间，如果连接没有正确地建立，那么 httpx 会及时地引发错误，而不会让开发者陷入长时间的等待。</p>
<pre><code class="language-python">import httpx

# 默认的超时时间是 5 秒，我们可以将其设置的更严格一些
response = httpx.get(&quot;https://www.google.com&quot;, timeout=1)

# 如果传递一个 None，那么表示不设置超时时间
</code></pre>
<p>非常简单，但 httpx 还支持更细粒度地控制超时时间。因为如果发生超时，无非以下几种情况：</p>
<ul>
<li>连接超时：如果没有在规定时间内，和请求的主机建立套接字连接，我们就说连接超时了，会引发 ConnectTimeout 异常；</li>
<li>读超时：如果没有在规定时间内，接收到服务端返回的数据块（响应体的一个块），我们就说读超时了，会引发 ReadTimeout 异常。</li>
<li>写超时：如果没有在规定时间内，将数据块（请求体的一个块）发送给服务端，我们就说写超时了，会引发 WriteTimeout 异常。</li>
</ul>
<p>而不同种类的超时，可以设置不同的超时时间，如果只写一个整数或浮点数，那么表示所有的超时时间都是相同的。</p>
<pre><code class="language-python">import httpx

# 连接超时时间设置为 10 秒，其它超时时间设置为 3 秒
timeout1 = httpx.Timeout(3, connect=10)

# 连接超时时间设置为 10 秒，读超时时间设置为 5 秒
# 其它超时时间设置为 3 秒
timeout2 = httpx.Timeout(3, connect=10, read=5)

# 连接超时时间设置为 10 秒，读超时时间设置为 5 秒
# 写超时时间设置为 6 秒，其它超时时间设置为 3 秒
timeout3 = httpx.Timeout(3, connect=10, read=5, write=6)

# 如果 connect、read、write 都不传，比如 Timeout(1)
# 那么 timeout=Timeout(1) 和 timeout=1 是等价的

response = httpx.get(
    &quot;https://www.google.com&quot;,
    timeout=timeout1  # timeout2、timeout3
)
</code></pre>
<p>读超时时间适用于 get、head 等请求，写超时时间适用于 post、put 等请求，连接超时时间适用于所有请求（因为不管什么请求都需要建立连接）。</p>
<h2 id="身份验证"><a class="header" href="#身份验证">身份验证</a></h2>
<p>有的时候发起 HTTP 请求的时候，会让你输入用户名和密码，也就是所谓的 Basic 认证。我们用 FastAPI 编写一个服务，举例说明：</p>
<p><img src="%E8%AF%A6%E8%A7%A3%E6%96%B0%E4%B8%80%E4%BB%A3%20HTTP%20%E8%AF%B7%E6%B1%82%E5%BA%93%EF%BC%9Ahttpx/./2.png" alt="" /></p>
<p>在浏览器中输入 URL 之后，会让我们提供用户名和密码，用户名密码正确才会执行请求，否则直接返回认证失败。那么面对这种情况，我们如何在发起请求的同时指定用户名和密码呢？</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://localhost:5555/index&quot;)
# 如果没有认证的话，FastAPI 会默认返回一个 JSON
print(response.status_code)
&quot;&quot;&quot;
401
&quot;&quot;&quot;
print(response.json())
&quot;&quot;&quot;
{'detail': 'Not authenticated'}
&quot;&quot;&quot;

# 如何输入用户名和密码呢，通过 auth 参数指定即可
response = httpx.get(&quot;http://localhost:5555/index&quot;, auth=(&quot;satori&quot;, &quot;123456&quot;))
# 这里的 FastAPI 服务会将输入的用户名和密码返回
print(response.json())
&quot;&quot;&quot;
{'username': 'satori', 'password': '123456'}
&quot;&quot;&quot;

# 或者下面这种做法也行
response = httpx.get(&quot;http://satori:123456@localhost:5555/index&quot;)
print(response.json())
&quot;&quot;&quot;
{'username': 'satori', 'password': '123456'}
&quot;&quot;&quot;
</code></pre>
<p>以上就是 Basic 认证，但除了 Basic 认证之外还有 Digest 认证，要更安全一些。如果是 Digest 认证的话，我们实例化一个 httpx.DigestAuth 对象（输入用户名和密码），然后传给 auth 参数即可。</p>
<h2 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h2>
<p>当请求出现错误时，httpx 会引发相应的异常。在 httpx 里面有两个关键的异常：</p>
<p><strong>1）RequestError</strong></p>
<p>这是一个超类，发送 HTTP 请求后产生的任何异常都可以用它来捕获。</p>
<pre><code class="language-python">import httpx

try:
    httpx.get(&quot;https://www.google.com&quot;,
              timeout=1)
except httpx.RequestError as e:
    # 内部有一个 request 属性，值为 httpx.Request 对象
    # 通过该属性可以拿到请求相关的信息
    print(f&quot;访问 {e.request.url} 失败&quot;)
&quot;&quot;&quot;
访问 https://www.google.com 失败
&quot;&quot;&quot;
</code></pre>
<p><strong>2）HTTPStatusError</strong></p>
<p>Response 对象有一个 raise_for_status 方法，如果状态码不是 200 ~ 299，那么调用的时候会抛异常，而 HTTPStatusError 专门用来捕获该异常。</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://localhost:5555/index&quot;)
print(response.status_code)
&quot;&quot;&quot;
401
&quot;&quot;&quot;

try:
    # 状态码不在 200 ~ 299，调用会抛异常
    response.raise_for_status()
except httpx.HTTPStatusError as e:
    print(e)
    &quot;&quot;&quot;
    Client error '401 Unauthorized' for url 'http://localhost:5555/index'
    For more information check: https://httpstatuses.com/401
    &quot;&quot;&quot;
    # 然后内部还有两个属性，分别是 response 和 request
    print(e.response is response)
    print(e.request is response.request)
    &quot;&quot;&quot;
    True
    True
    &quot;&quot;&quot;
</code></pre>
<p>比较简单，并且也不是很常用。</p>
<h2 id="client-对象"><a class="header" href="#client-对象">Client 对象</a></h2>
<p>我们知道 httpx 内部的 get、post 等函数，背后都调用了 request 函数，那么 request 函数的逻辑是怎么样的呢？我们看一下源代码。</p>
<p><img src="%E8%AF%A6%E8%A7%A3%E6%96%B0%E4%B8%80%E4%BB%A3%20HTTP%20%E8%AF%B7%E6%B1%82%E5%BA%93%EF%BC%9Ahttpx/./3.png" alt="" /></p>
<p>发送请求的逻辑都在类 Client 里面，我们可以实例化一个 Client 对象，然后调用它的 get、post、put 等方法，当然这些方法背后都调用了 client.request。如果是通过 httpx 调用的话，比如 httpx.get，那么内部会先帮我们实例化一个 Client 对象，然后调用对象的 request 方法。</p>
<blockquote>
<p>httpx.Client 和 requests.Session 的作用是类似的。</p>
</blockquote>
<p>所以当我们要多次向某个网址发请求（比如 get 请求）时，那么先实例化一个 Client 对象，然后再调用它的 get 方法会更好一些。因为底层的 TCP 连接会复用，从而带来性能提升。如果使用 httpx.get，那么每次访问都要新创建一个 TCP 连接。</p>
<pre><code class="language-python">import httpx

# 内部会创建一个 Client 对象，然后调用它的 request 方法
# 调用结束之后，再将对象销毁，因此底层的 TCP 连接无法复用
httpx.get(&quot;http://www.baidu.com&quot;)
httpx.get(&quot;http://www.baidu.com&quot;)
httpx.get(&quot;http://www.baidu.com&quot;)

# 实例化一个 Client 对象，它内部使用了 HTTP 连接池
client = httpx.Client()
# 向同一主机发出多个请求时，客户端将重用底层的 TCP 连接
# 而不是为每个请求重新创建一个
client.get(&quot;http://www.baidu.com&quot;)
client.get(&quot;http://www.baidu.com&quot;)
client.get(&quot;http://www.baidu.com&quot;)
</code></pre>
<p>使用 Client 对象除了能带来性能上的提升，还有一个重要的地方就是，它可以将请求参数保存起来，并让它们跨请求传递。举个例子：</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;http://www.baidu.com&quot;, headers={&quot;ping&quot;: &quot;pong&quot;})
print(&quot;ping&quot; in response.request.headers)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
# httpx 内部每次都会创建一个新的 Client 对象
# 因此在上一个请求当中设置的请求头，与后续请求无关
response = httpx.get(&quot;http://www.baidu.com&quot;)
print(&quot;ping&quot; in response.request.headers)
&quot;&quot;&quot;
False
&quot;&quot;&quot;

# 先实例化一个 Client 对象，在里面设置请求头
# 那么每一次请求的时候，都会带上，因为用的是同一个对象
client = httpx.Client(headers={&quot;ping&quot;: &quot;pong&quot;})
response = client.get(&quot;http://www.baidu.com&quot;)
print(&quot;ping&quot; in response.request.headers)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
response = client.get(&quot;http://www.baidu.com&quot;)
print(&quot;ping&quot; in response.request.headers)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<p>除了请求头，像 cookie、超时时间、auth、代理等等都是支持的，一旦设置了，那么后续的每次请求都会带上。</p>
<p>并且除了在实例化的时候设置之外，也可以实例化之后单独设置，举个例子：</p>
<pre><code class="language-python">import httpx

client = httpx.Client()
client.headers[&quot;ping&quot;] = &quot;pong&quot;
response = client.get(&quot;http://www.baidu.com&quot;)
print(&quot;ping&quot; in response.request.headers)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<p>总的来说，和 requests 模块是一致的。</p>
<p>还有一点，如果我们在请求的方法中又传了相应的参数，那么请求方法中的参数，会覆盖 client 当中的参数。</p>
<pre><code class="language-python">import httpx

client = httpx.Client(headers={&quot;ping&quot;: &quot;pong&quot;})
response = client.get(&quot;http://www.baidu.com&quot;,
                      headers={&quot;X-MAN&quot;: &quot;TX&quot;, &quot;ping&quot;: &quot;pong pong pong&quot;})
# 调用 get 方法时，也设置了 headers，那么以具体的方法为准
# 并且在请求方法中设置的参数，不会影响下一个请求
print(response.request.headers[&quot;ping&quot;])
print(response.request.headers[&quot;X-MAN&quot;])
&quot;&quot;&quot;
pong pong pong
TX
&quot;&quot;&quot;

# 重新调用，两个请求互不影响
response = client.get(&quot;http://www.baidu.com&quot;)
print(response.request.headers[&quot;ping&quot;])
print(&quot;X-MAN&quot; in response.request.headers)
&quot;&quot;&quot;
pong
False
&quot;&quot;&quot;
</code></pre>
<p>非常简单，比如我们要多次访问一个比较私密的接口，而接口要求我们在访问时，必须在请求头中带上指定的 Token，而 Token 需要访问另一个接口才能获取。那么便可以实例化一个 Client 对象，获取完 Token 之后通过 client.headers 设置进去，这样后续在请求的时候就会自动带上。</p>
<blockquote>
<p>Client 对象和 requests 的 Session 对象一样，不用了应该调用 close 方法进行关闭。或者使用 with 语句，会自动关闭。</p>
</blockquote>
<h2 id="指定代理"><a class="header" href="#指定代理">指定代理</a></h2>
<p>如果要使用代理，那么需要通过 proxies 参数指定。</p>
<pre><code class="language-python">import httpx

proxies = {
  &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;,
  &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;,
}

httpx.get(&quot;...&quot;,  proxies=proxies)
# 或者手动实例化 Client 对象，后续每次请求都会带上
with httpx.Client(proxies=proxies) as client:
    client.get(&quot;...&quot;)
    client.get(&quot;...&quot;)
</code></pre>
<p>若你的代理需要使用HTTP Basic Auth，可以使用 http://user:pass@host:port 语法：</p>
<pre><code class="language-python">proxies = {
    &quot;http&quot;: &quot;http://user:pass@10.10.1.10:3128&quot;,
}
</code></pre>
<p>还可以为某个特定的连接方式或者主机设置代理，使用 scheme://host:port 作为 key，它会针对指定的主机和连接方式进行匹配。</p>
<pre><code class="language-python">proxies = {
    'http://10.20.1.128': 'http://10.10.1.10:5323'
}
</code></pre>
<p>以上是 HTTP 代理，除了它之外 httpx 还支持 SOCKS 代理。如果要使用的话，需要安装第三方库，pip install &quot;httpx[socks]&quot;。</p>
<pre><code class="language-python">import httpx

httpx.Client(
    proxies='socks5://user:pass@host:port'
)
</code></pre>
<h2 id="ssl-证书"><a class="header" href="#ssl-证书">SSL 证书</a></h2>
<p>HTTP 在传输数据的时候是不安全的，所以引入了 HTTPS。在发送 HTTPS 请求时，httpx 会对服务端主机的 SSL 证书进行验证（默认行为），如果验证失败，或者不信任服务端的 SSL 证书，那么 httpx 会抛出异常。</p>
<p>对于大部分网站来说，它们的 SSL 证书都是由受信任的 CA 机构颁发，所以能够直接正常访问，验证通过。但有些网站比较特殊，它会单独提供证书，你需要先把证书下载下来，然后发请求的时候带过去。</p>
<pre><code class="language-python">import httpx

response = httpx.get(&quot;https://xxx.org&quot;,
                     verify=&quot;证书.pem&quot;)

with httpx.Client(verify=&quot;证书.pem&quot;) as client:
    client.get(&quot;https://xxx.org&quot;)
</code></pre>
<p>或者你还可以使用标准库 ssl，传递一个 SSLContext 对象。</p>
<pre><code class="language-python">import ssl
import httpx

ctx = ssl.create_default_context()
ctx.load_verify_locations(&quot;证书.pem&quot;)
# 或者直接 ctx = httpx.create_ssl_context(&quot;证书.pem&quot;)
response = httpx.get(&quot;https://xxx.org&quot;, verify=ctx)
</code></pre>
<p>SSL 证书是为了保证客户端和服务端之间的数据传输安全，如果你不需要考虑安全性的话，那么也可以指定 verify 为 False，表示禁用 SSL 验证。</p>
<p>既然服务端有证书，那么客户端也可以有。</p>
<pre><code class="language-python">import httpx

cert1 = &quot;客户端证书.pem&quot;
cert2 = (&quot;客户端证书.pem&quot;, &quot;秘钥文件.key&quot;)
cert3 = (&quot;客户端证书.pem&quot;, &quot;秘钥文件.key&quot;, &quot;密码&quot;)
httpx.get(
    &quot;https://example.org&quot;,
    cert=cert1  # cert2、cert3
)
</code></pre>
<p>不是太常用，了解一下就好。</p>
<h2 id="手动构造-request-对象"><a class="header" href="#手动构造-request-对象">手动构造 Request 对象</a></h2>
<p>调用 httpx 里面的函数发送请求时，httpx 内部会帮我们构造 Resquest 对象；服务端返回响应之后，httpx 会帮我们构造 Response 对象。</p>
<p>但为了最大限度地控制发送的内容，HTTPX 还支持我们手动构建 Request 对象。</p>
<pre><code class="language-python">import httpx

request = httpx.Request(&quot;GET&quot;, &quot;http://www.baidu.com&quot;)
# 通过 client.send 方法将请求发送给服务端
with httpx.Client(headers={&quot;ping&quot;: &quot;pong&quot;}) as client:
    response = client.send(request)
    print(&quot;ping&quot; in response.request.headers)  # False

# 但上面这种方式，Client() 里面的参数无法作用在请求上
# 因此还可以通过 Client 对象来构造请求
with httpx.Client(headers={&quot;ping&quot;: &quot;pong&quot;}) as client:
    request = client.build_request(&quot;GET&quot;, &quot;http://www.baidu.com&quot;)
    response = client.send(request)
    print(&quot;ping&quot; in response.request.headers)  # True
</code></pre>
<p>这种方式用的不多，我们直接调用 client 下面的 get、post 等方法发请求即可。</p>
<h2 id="钩子函数"><a class="header" href="#钩子函数">钩子函数</a></h2>
<p>httpx 还允许我们向 Client 实例注册一些钩子函数，当指定事件发生时会调用，而事件有两种：</p>
<ul>
<li>request：请求完全准备好之后，发给服务端之前调用；</li>
<li>response：从服务端获取响应之后，返回之前调用；</li>
</ul>
<p>通过钩子函数，我们可以跟踪请求的整个过程，并进行记录。</p>
<pre><code class="language-python">import httpx

def before_request1(request):
    print(f&quot;1）向 {request.url} 发送了请求&quot;)

def before_request2(request):
    print(f&quot;2）向 {request.url} 发送了请求&quot;)

def after_response1(response):
    print(f&quot;1）服务端返回了响应，状态码 {response.status_code}&quot;)

def after_response2(response):
    print(f&quot;2）服务端返回了响应，状态码 {response.status_code}&quot;)

client = httpx.Client(
    event_hooks={&quot;request&quot;: [before_request1, before_request2],
                 &quot;response&quot;: [after_response1, after_response2]}
)
client.get(&quot;http://www.baidu.com&quot;)
&quot;&quot;&quot;
1）向 http://www.baidu.com 发送了请求
2）向 http://www.baidu.com 发送了请求
1）服务端返回了响应，状态码 200
2）服务端返回了响应，状态码 200
&quot;&quot;&quot;
</code></pre>
<p>总的来说，钩子函数很有用，但对于我们简单地发送 HTTP 请求而言，用的不多。</p>
<h2 id="开启-http2"><a class="header" href="#开启-http2">开启 HTTP/2</a></h2>
<p>先来说一说为什么会有 HTTP/2，存在即合理，既然 HTTP/2 会出现，那么说明 HTTP/1.1 一定存在一些缺点。那么缺点都有哪些呢？</p>
<p><font color="blue"><strong>队头阻塞</strong></font></p>
<p>HTTP/1.1 是基于「请求-响应」模式，如果一个请求阻塞，那么在后面排队的所有请求也会一同阻塞，会导致客户端一直请求不到数据，就类似堵车。</p>
<p><font color="blue"><strong>延迟高</strong></font></p>
<p>HTTP/1.1 处理响应的顺序和请求顺序是一致的，只有第一个响应处理完毕之后才能处理第二个响应。就类似于打卡，第一个人因为某些原因怎么也打不上卡，但他如果打不上，后面的人也没法打。</p>
<p>总的来说，对于 HTTP/1.1 而言，没有轻重缓急的优先级，只有先后入队的顺序。</p>
<p><font color="blue"><strong>HTTP 头部过大</strong></font></p>
<p>无论是请求报文还是响应报文，都由 Header + Body 组成，因为 HTTP/1.1 是无状态的，所以就要求 Header 携带很多的头字段，有时多达几百字节甚至上千字节。但 Body 却经常只有几十字节、甚至几字节（比如 GET 请求、204/301/304 响应），等于说变成了一个不折不扣的大头儿子。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，长尾效应导致大量带宽消耗在了这些冗余度极高的数据上。</p>
<p>以上就是 HTTP/1.1 面临的一些问题，尽管也通过一些额外的手段来曲线救国，但仍然不能很好的解决问题。所以业界就开始改革了，发明了 HTTP/2 协议，这个协议很好地解决了 HTTP/1.1 所面临的问题。</p>
<p>首先 HTTP/2 它是安全的，和 HTTPS 一样，也是基于 SSL/TLS 之上。但将 HTTP 分解成了语义和语法两个部分，语义层不做改动，与 HTTP/1 完全一致。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2，如果代理服务器不支持 HTTP/2，那么会自动降级到 HTTP/1.1（HTTPS）。</p>
<p>特别要说的是，与 HTTPS 不同，HTTP/2 没有在 URI 里引入新的协议名，仍然用 http 表示明文协议，用 https 表示加密协议。这是一个非常了不起的决定，可以让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。</p>
<p>在语义保持稳定之后，HTTP/2 在语法层做了天翻地覆的改造，完全变更了 HTTP 报文的传输格式。</p>
<p><font color="blue"><strong>头部压缩</strong></font></p>
<p>HTTP/1.1 对 Body 进行了压缩，并且还提供了 Content-Encoding 指定压缩方式，但 Header 却没有进行优化。</p>
<p>于是 HTTP/2 把头部压缩作为性能改进的一个重点，优化的方式自然还是压缩。但 HTTP/2 并没有使用传统的压缩算法，而是开发了专门的 HPACK 算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。</p>
<p><font color="blue"><strong>二进制格式</strong></font></p>
<p>HTTP/1.1 的报文是明文格式，但这样容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低，还麻烦。</p>
<p>于是 HTTP/2 将报文换成了二进制格式，这样虽然对人不友好，但却大大方便了计算机的解析。具体做法是把原来的 Header+Body 的消息打散为数个小片的二进制帧（Frame），其中 HEADERS 帧存放头数据、DATA 帧存放实体数据。</p>
<p><img src="%E8%AF%A6%E8%A7%A3%E6%96%B0%E4%B8%80%E4%BB%A3%20HTTP%20%E8%AF%B7%E6%B1%82%E5%BA%93%EF%BC%9Ahttpx/./4.png" alt="" /></p>
<p>这种做法有点像是 Chunked 分块编码的方式，也是化整为零的思路，但 HTTP/2 数据分帧后 Header+Body 的报文结构就完全消失了，协议看到的只是一个个的碎片。</p>
<p><font color="blue"><strong>虚拟的流</strong></font></p>
<p>在连接的层面上看，多个消息就是一堆乱序收发的帧，比如可以先接收消息 1 的帧、再接收消息 2 的帧，然后再接收消息 1 的帧。这个过程不要求顺序（比如先将消息 1 的帧全部接收完毕之后才能接收消息 2 的帧），否则和 HTTP/1.1 就没有区别了。</p>
<p>那么问题来了，这些消息碎片（二进制帧）到达目的地之后应该怎么组装起来呢？HTTP/2 为此定义了一个流（Stream）的概念，它是虚拟的，可以想象成二进制帧的双向传输序列。隶属同一个消息的所有帧都有一个相同的流 ID，不同消息的流 ID 则不同。后续在对帧进行组装的时候，根据这个 ID 来将属于同一个消息的帧组装在一起，得到类似 HTTP/1.1 中的报文，也就是传输时无序，接收时组装。</p>
<p>所以，在 HTTP/2 中的多个请求与响应之间没有了顺序关系，不需要排队等待，也就不会再出现队头阻塞问题，降低了延迟，大幅度提高了连接的利用率。</p>
<blockquote>
<p>说白了在 HTTP/2 中就是将二进制的报文数据切分成多个帧进行传输，而不同消息的帧可以混在一起发送（传输时无序），而在接收时再根据流 ID 将属于同一个消息的帧组装在一起（接收时组装）。</p>
</blockquote>
<p>因为流是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上同时发送多个碎片化的消息，这就是常说的多路复用（ Multiplexing），多个往返通信都复用一个连接来处理。</p>
<p>但需要注意的是，我们说传输时无序指的是多个消息之间的帧可以无序，但同一个消息的帧则必须是有序的，比如每条消息必须先传输其 HEADER 帧、再传输 DATA 帧，否则消息就乱掉了。然后组装的时候，直接按照顺序进行组装即可。</p>
<p><img src="%E8%AF%A6%E8%A7%A3%E6%96%B0%E4%B8%80%E4%BB%A3%20HTTP%20%E8%AF%B7%E6%B1%82%E5%BA%93%EF%BC%9Ahttpx/./5.png" alt="" /></p>
<p>另外为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的流，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。</p>
<p>HTTP/2 还在一定程度上改变了传统的请求响应工作模式，服务器不再是完全被动地响应请求，也可以新建流主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为服务器推送（Server Push）。</p>
<p>好了，说回重点，虽然 HTTP/1.1 存在一些问题，但它非常成熟，所以 httpx 默认没有开启 HTTP/2。如果想开启的话，那么只需要在实例化 Client 的时候加上一个参数即可。</p>
<blockquote>
<p>但是要安装 HTTP/2 的依赖项，直接 pip install &quot;httpx[http2]&quot; 即可</p>
</blockquote>
<pre><code class="language-python">import httpx

# 通过指定 http2=True，即可开启 HTTP/2
client = httpx.Client(http2=True)
response = client.get(&quot;http://www.baidu.com&quot;)
</code></pre>
<p>注：httpx.get、http.post 里面没有 http2 这个参数，如果想开启 HTTP/2，那么必须手动实例化 Client 对象，然后指定相关参数。</p>
<h2 id="发送异步请求"><a class="header" href="#发送异步请求">发送异步请求</a></h2>
<p>前面介绍的所有内容都是基于同步模式，但 httpx 还可以发送异步请求，否则就没有必要学它了，直接用 requests 就行了。</p>
<p>那么如何发送异步请求呢？</p>
<pre><code class="language-python">import asyncio
import httpx

async def send():
    async with httpx.AsyncClient() as client:
        response = await client.get(&quot;http://www.baidu.com&quot;)
        print(response.status_code)
        print(response.url)

asyncio.run(send())
&quot;&quot;&quot;
200
http://www.baidu.com
&quot;&quot;&quot;
</code></pre>
<p>过程非常简单，使用 AsyncClient 实例化一个客户端，然后调用里面的方法发送请求即可。用法和同步的 Client 对象是一样的，只有几个方法名不一样，我们举例说明：</p>
<pre><code class="language-python">import asyncio
import httpx

async def send():
    client = httpx.AsyncClient()
    # 分块读取
    async with client.stream(
        'GET', 'http://www.baidu.com'
    ) as response:
        # 如果是 Client，那么方法名为 iter_bytes
        # 而 AsyncClient 的方法名则是 aiter_bytes
        # 然后遍历要用 async for，因为返回的是异步生成器
        async for chunk in response.aiter_bytes():
            pass

    # 关闭的时候要使用 aclose()，而不是 close
    await client.aclose()
</code></pre>
<p>对啦，还有钩子函数，如果使用的是异步客户端，钩子函数应该使用 async def 定义。也就是说，我们要传协程函数，而不是普通的函数。</p>
<h2 id="小结-8"><a class="header" href="#小结-8">小结</a></h2>
<p>关于 httpx 的内容就说到这里，总的来说它的功能还是很强大的，在设计上和 requests 保持了高度的一致性。熟悉 requests 的话，那么学习 httpx 基本上没有任何压力。</p>
<p>但 httpx 在 requests 的基础上提供了很多新功能，比如严格的超时控制，精确的类型注解，HTTP/2 和协程的支持等等。以后在发送 HTTP 请求的时候，不妨使用 httpx 吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-12"><a class="header" href="#楔子-12">楔子</a></h2>
<p>本篇文章来聊一下 Python 的 with 语句，它用于实现上下文管理器。我们使用 with 语句最多的场景，应该就是操作文件了，比如打开一个文件的时候会通过类似于 <font color="blue">with open() as f:</font> 这种形式打开，而这么做好处就是当 with 语句结束后会自动关闭文件。</p>
<p>那么 with 语句的原理是什么呢？我们怎么样才能使用 with 语句呢？这次就全方位地剖析一下。并且 Python 的标准库里面有一个模块叫做 contextlib，从名字上也能看出来这是一个用于上下文管理的模块。我们后面也会通过分析 contextlib 的源码，来手动实现一下 contextlib 的功能。</p>
<h2 id="上下文管理器-api"><a class="header" href="#上下文管理器-api">上下文管理器 API</a></h2>
<p>上下文管理器（context manager）负责管理一个代码块的资源，会在进入代码块时创建资源，在退出代码块时清理资源。比如文件就支持上下文管理器 API，可以确保文件读写后自动关闭。</p>
<p><strong>我们来模拟一下文件的读取：</strong></p>
<pre><code class="language-python">class Open:

    def __init__(self, filename, mode='r', encoding=None):
        self.filename = filename
        self.mode = mode
        self.encoding = encoding

    def __enter__(self):
        print(&quot;开始执行 __enter__&quot;)
        return self

    def read(self):
        print(f&quot;以 `{self.mode}` 模式打开文件 `{self.filename}`&quot;)

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&quot;最后执行 __exit__，用于清理资源&quot;)


with Open(&quot;1.txt&quot;) as f:
    f.read()
&quot;&quot;&quot;
开始执行 __enter__
以 `r` 模式打开文件 `1.txt`
最后执行 __exit__，用于清理资源
&quot;&quot;&quot;
</code></pre>
<p>with Open() as f: 的整个流程就是先实例化一个 Open 对象，然后通过实例对象来调用 __enter__ 方法，将其返回值赋给 with 语句中的 f，接着执行 with 语句块内的代码，最后执行 __exit__ 方法。</p>
<p>因此需要注意：with Open() as f 里面的 f，不一定是 Open 的实例对象，它到底是什么，取决于 __enter__ 方法返回了什么。</p>
<pre><code class="language-python">class Open:

    def __enter__(self):
        return &quot;古明地觉&quot;

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass


# 如果是 f = Open(), 那么毫无疑问 f 就是类 Open 的实例对象
# 但是对于 with Open() as f 而言，则不一样
# 我们说这个 f 到底是什么, 它取决于 __enter__ 中返回了什么
with Open() as f:
    print(f)
&quot;&quot;&quot;
古明地觉
&quot;&quot;&quot;
</code></pre>
<p>我们看到 print(f) 打印的是一个字符串，这是因为 __enter__ 返回的就是一个字符串。首先 with Open() as f: 这一行代码所做的事情就是先实例化一个 Open 对象，虽然这个实例对象我们无法用变量进行接收，但它确实存在。然后该实例对象再调用 __enter__，将 __enter__ 的返回值赋给 f，所以在 with 代码块中打印 f 得到的是一个字符串。</p>
<p>因此要记住：f 是由 __enter__ 的返回值决定的，只不过大多数情况下，__enter__ 里面返回的都是 self 本身，所以 f 指向的也是该类的实例对象。</p>
<p><strong>当然，我们先实例化一个对象，再使用 with 也是可以的。</strong></p>
<pre><code class="language-python">class Open:

    def __enter__(self):
        return &quot;古明地觉&quot;

    def __exit__(self, exc_type, exc_val, exc_tb):
        pass


o = Open()
# 会将 o.__enter__() 赋值给 f
with o as f:
    print(f&quot;{f}, 世界第一可爱&quot;)
&quot;&quot;&quot;
古明地觉, 世界第一可爱
&quot;&quot;&quot;

# with Open() as f: 相当于将实例化和调用 __enter__ 放在一起执行
# 但也可以先实例化，然后对实例对象单独使用 with 语句
# 比如 with o as f:, 那么会执行 o.__enter__(), 将其返回值赋值给 f
# 当 with 语句结束，再通过实例对象 o 来调用 __exit__，进行资源的释放等操作

# 当然 with 也可以不搭配 as，即独立存在
with o:
    pass
</code></pre>
<p>因此 with 语句的流程我们就很清晰了，以 with A() as a: 为例，总共分为三步：</p>
<ul>
<li>创建 A 的实例对象，然后调用 __enter__ 方法，将其返回值交给 a；</li>
<li>执行 with 语句块的代码；</li>
<li>最后由该实例对象再调用 __exit__ 进行一些收尾工作；</li>
</ul>
<blockquote>
<p>因此一个对象能否使用 with 语句，取决于实例化该对象的类（或者继承的基类）是否同时实现了 __enter__ 和 __exit__ 两个魔法函数，两者缺一不可。</p>
</blockquote>
<p>__enter__ 我们清楚了，然后再来看看 __exit__。我们看到它的参数除了 self 之外，还有三个参数，分别是 exc_type, exc_val, exc_tb。显然这三个参数分别是异常类型、异常值、异常的回溯栈， 从名字上也能看出来。</p>
<pre><code class="language-python">class Open:

    def __enter__(self):
        return &quot;古明地觉&quot;

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&quot;__exit__执行:&quot;)
        print(exc_type)
        print(exc_val)
        print(exc_tb)
        return True

with Open() as f:
    print(f)
&quot;&quot;&quot;
古明地觉
__exit__执行:
None
None
None
&quot;&quot;&quot;
# 我们看到 exc_type, exc_val, exc_tb 三者全部为 None
# 因为它们是和异常有关的，而当前没有出现异常，所以为 None

# 但如果出现异常了呢？
with Open() as f:
    print(f)
    1 / 0
    print(123)
    print(456)
    print(789)
print(&quot;你猜我会被执行吗？&quot;)
&quot;&quot;&quot;
古明地觉
__exit__执行:
&lt;class 'ZeroDivisionError'&gt;
division by zero
&lt;traceback object at 0x0000024CD4E4C080&gt;
你猜我会被执行吗？
&quot;&quot;&quot;
</code></pre>
<p>我们看到在没有出现异常的时候，exc_type, exc_val, exc_tb 打印的值全部是 None。然而一旦 with 语句里面出现了异常，那么会立即执行 __exit__，并将异常的类型，异常的值，异常的回溯栈传入到 __exit__ 中。</p>
<p>因此：当 with 语句正常结束之后会调用 __exit__，如果 with 语句里面出现了异常则会立即调用 __exit__。</p>
<p>但是 __exit__ 方法返回了个 True 是什么意思呢？当 with 语句里面出现了异常，理论上是会报错的，但由于要执行 __exit__ 方法，所以相当于暂时把异常塞进了嘴里。如果 __exit__ 方法最后返回了一个布尔类型为 True 的值，那么会把塞进嘴里的异常吞下去，程序不报错正常执行。如果返回布尔类型为 False 的值，则会在执行完 __exit__ 方法之后再把异常吐出来，引发程序崩溃。</p>
<p>这里我们返回了 True，因此程序正常执行，最后一句话被打印了出来。但是 1 / 0 这行代码后面的几个 print 却没有打印，为什么呢？</p>
<p>因为我们说上下文管理执行是有顺序的：</p>
<ul>
<li>先实例化 Open 的实例对象，调用 __enter__ 方法，将返回值交给 f；</li>
<li>执行 with 语句块的代码；</li>
<li>最后调用 __exit__；</li>
</ul>
<p>只要 __exit__ 方法执行结束，那么这个 with 语句就算结束了。而 with 语句里面如果有异常，那么会立即进入 __exit__，因此异常下面的代码是无论如何都不会被执行的。</p>
<p>但当 __exit__ 返回 True 时，整个 with 语句块下面的代码是不受影响的。</p>
<blockquote>
<p>另外，如果是 __enter__ 和 __exit__ 里面出现了异常，那么 with 语句肯定是会报错的。</p>
</blockquote>
<p>目前我们就把 with 语句说完了，下面进行 contextlib 的分析。contextlib 是一个专门用于上下文管理的内置模块，我们来分析一下它内部是怎么实现的。</p>
<h2 id="上下文管理器作为函数修饰符"><a class="header" href="#上下文管理器作为函数修饰符">上下文管理器作为函数修饰符</a></h2>
<p>contextlib 有一个类 ContextDecorator，增加了对常规上下文管理器类的支持，使得上下文管理器，也可以作为函数的装饰器，我们来看一下。</p>
<pre><code class="language-python">import contextlib

class Context(contextlib.ContextDecorator):
    def __init__(self, how):
        self.how = how

    def __enter__(self):
        print(f&quot;__enter__, {self.how}&quot;)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(f&quot;__exit__, {self.how}&quot;)
        return True


@Context(&quot;我要去装饰了&quot;)
def foo(name):
    print(&quot;执行函数 foo&quot;)
    return f&quot;我的名字叫: {name}&quot;

ret = foo(&quot;古明地觉&quot;)
&quot;&quot;&quot;
__enter__, 我要去装饰了
执行函数 foo
__exit__, 我要去装饰了
&quot;&quot;&quot;
print(ret)
&quot;&quot;&quot;
我的名字叫: 古明地觉
&quot;&quot;&quot;
</code></pre>
<p>我们看到上下文管理器还可以作为函数的装饰器，先执行了__enter__，然后执行 foo 函数内部的代码，最后执行 __exit__，而打印返回值也没有问题。</p>
<p>那么内部是如何实现的呢？首先我们装饰 foo 的时候，是使用 Context 的实例对象去装饰的，相当于给这个实例对象加上了括号，并把 foo 函数作为参数传进去了。既然实例对象加上了括号（调用），这就意味着该实例对象对应的类一定实现了 __call__，但我们定义的类没有，所以继承的父类肯定有。</p>
<p>我们看一下父类的 __call__ 函数的逻辑：</p>
<p><img src="%E9%80%9A%E8%BF%87%20contextlib%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E5%A4%8D%E4%B9%A0%E4%B8%80%E4%B8%8B%20with%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95/./1.png" alt="" /></p>
<p>当 Context 实例对象在对 foo 装饰的时候，会执行这里（父类）的 __call__，函数 foo 会被传给参数 func，然后返回 inner。所以 foo 在被装饰完之后就变成了这里的 inner，只不过由于有 @wraps(func) 这个装饰器在，所以装饰之后的函数名、__doc__ 等元信息没有改变。</p>
<p>那么当调用 foo(&quot;古明地觉&quot;) 的时候，就等价于调用这里的 inner(&quot;古明地觉&quot;)，而里面 <code>with self: 中的 self</code>，显然就是 Context 的实例对象。所以就很清晰了，with self 会先执行 Context 实例的 __enter__，然后执行 func、也就是原本的 foo，最后执行 __exit__。</p>
<p>当然也可以把父类中 __call__ 的实现放在自己定义的类中，这样直接用就可以了，就不用再继承 contextlib 里面的父类了。</p>
<p>整体的逻辑就是上面分析的那样，可以仔细理一遍这里的流程。但是有一点需要注意，就是返回值问题，虽然 __exit__ 是最后执行的，但返回的仍是函数 foo 的返回值。</p>
<pre><code class="language-python">@Context(&quot;我要去装饰了&quot;)
def foo(name):
    print(&quot;执行函数 foo&quot;)
    1 / 0
    return f&quot;我的名字叫: {name}&quot;


ret = foo(&quot;古明地觉&quot;)
&quot;&quot;&quot;
__enter__, 我要去装饰了
执行函数 foo
__exit__, 我要去装饰了
&quot;&quot;&quot;
print(ret)
&quot;&quot;&quot;
None
&quot;&quot;&quot;
</code></pre>
<p>我们看到返回值是 None，因为执行 foo 时出现了异常，导致立刻执行了 __exit__。既然函数返回之前出现异常了，那么就相当于返回了 None，而不是 __exit__ 里面的 True。</p>
<h2 id="从生成器到上下文管理器"><a class="header" href="#从生成器到上下文管理器">从生成器到上下文管理器</a></h2>
<p>采用传统方式创建上下文管理器并不难，只需要创建一个包含 __enter__ 和 __exit__ 的类即可。不过某些时候，如果只有很少的上下文需要管理，那么定义一个类便会有些麻烦。在这些情况下，可以使用 contextmanager 修饰符将一个生成器函数转换为上下文管理器。</p>
<pre><code class="language-python">import contextlib

@contextlib.contextmanager
def foo(name, where):
    print(f&quot;我的名字是: {name}, 居住在: {where}&quot;)
    yield &quot;baka⑨&quot;
    print(f&quot;{where}是一个很美的地方&quot;)


with foo(&quot;古明地觉&quot;, &quot;地灵殿&quot;) as f:
    print(f.upper())
&quot;&quot;&quot;
我的名字是: 古明地觉, 居住在: 地灵殿
BAKA⑨
地灵殿是一个很美的地方
&quot;&quot;&quot;
</code></pre>
<p>只要给函数加上这个装饰器，那么调用函数的时候便可以使用 with 语句。函数里面的 yield 相当于将函数分隔为两个战场：通过 with 调用函数时，yield 和它上面的代码相当于 __enter__ 会先执行，然后将 yield 后面的值交给 f，接着执行 with 语句块；最后执行 yield 下面的代码块，相当于 __exit__。</p>
<blockquote>
<p>注意：如果使用 contextmanager 装饰的话，函数中只能出现、且必须出现一个 yield。</p>
</blockquote>
<p>下面来手动实现 contextmanager 函数，contextlib 中实现的比较复杂，主要是最后对异常进行了很多的检测。我们可以适当简化，把主要的逻辑实现一下。</p>
<pre><code class="language-python">from functools import wraps

def contextmanager(func):

    class GeneratorContextManager:

        def __init__(self, func, *args, **kwargs):
            self.gen = func(*args, **kwargs)

        def __enter__(self):
            try:
                assert hasattr(self.gen, &quot;__next__&quot;)
                return next(self.gen)
            except AssertionError:
                raise RuntimeError(&quot;函数中必须出现、且只能出现一个yield&quot;)

        def __exit__(self, exc_type, exc_val, exc_tb):
            try:
                next(self.gen)
            except StopIteration:
                return False
            else:
                raise RuntimeError(&quot;函数中必须出现、且只能出现一个yield&quot;)

    @wraps(func)
    def inner(*args, **kwargs):
        return GeneratorContextManager(func, *args, **kwargs)
    return inner

@contextmanager
def foo(name, where):
    print(f&quot;我的名字是: {name}, 居住在: {where}&quot;)
    yield &quot;baka⑨&quot;
    print(f&quot;{where}是一个很美的地方&quot;)

with foo(&quot;古明地觉&quot;, &quot;地灵殿&quot;) as f:
    print(f.upper())
&quot;&quot;&quot;
我的名字是: 古明地觉, 居住在: 地灵殿
BAKA⑨
地灵殿是一个很美的地方
&quot;&quot;&quot;
</code></pre>
<p>结果没有问题，以上我们就手动实现了一个 contextmanager，下面还是分析一下整体的流程。</p>
<p>当使用 contextmanager 装饰的时候，foo 函数就变成了内层函数 inner。然后通过 with 语句调用的时候：</p>
<p><img src="%E9%80%9A%E8%BF%87%20contextlib%20%E6%A8%A1%E5%9D%97%E8%AF%A6%E7%BB%86%E5%A4%8D%E4%B9%A0%E4%B8%80%E4%B8%8B%20with%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95/./2.png" alt="" /></p>
<p>最终会创建一个 GeneratorContextManager 对象，而 self.gen 显然是基于生成器函数 foo 创建的生成器。因为是在 with 语句里面，实例对象创建完之后要执行 __enter__。然后在里面通过 next(self.gen) 驱动生成器执行，此时 foo 里面 yield 上半部分的代码就开始执行了。当执行到 yield 时，生成器暂停，然后 __enter__ 会将 yield 后面的值赋给变量 f。</p>
<p>接着就开始执行 with 代码块了，因为 yield 返回的是一个字符串，所以 f 也是一个字符串，我们转成大写并打印。</p>
<p>with 语句块结束之后，跳转到 __exit__，在里面通过 next(self.gen) 继续驱动生成器执行。此时 foo 里面 yield 下半部分的代码开始执行，当出现 StopIteration 时代表执行完毕。如果没有出现 StopIteration，那么说明 yield 的下面还有 yield，此时程序会报错。</p>
<p>以上就是整个流程，本质上还是转成了类的上下文管理。</p>
<p>最后，由于 contextlib 中的 contextmanager 返回的上下文管理器继承自 ContextDecorator，所以它也可被用作函数修饰符。</p>
<pre><code class="language-python">import contextlib

@contextlib.contextmanager
def foo(name, where):
    print(f&quot;我的名字是: {name}, 居住在: {where}&quot;)
    yield &quot;baka⑨&quot;
    print(f&quot;{where}是一个很美的地方&quot;)

@foo(&quot;古明地觉&quot;, &quot;地灵殿&quot;)
def bar():
    print(&quot;猜猜我会在什么地方输出&quot;)

bar()
&quot;&quot;&quot;
我的名字是: 古明地觉, 居住在: 地灵殿
猜猜我会在什么地方输出
地灵殿是一个很美的地方
&quot;&quot;&quot;
</code></pre>
<p>当执行 bar 的时候，还是会先执行 foo 里面 yield 的上半部分，然后执行 bar 函数，最后执行 foo 里面 yield 的下半部分。并且此时 yield 后面的内容是什么也已经无关紧要了，因为根本用不到了。</p>
<p>当然我们也可以手动实现上面的功能，建议当做练习自己尝试一下，并不难。</p>
<h2 id="关闭打开的句柄"><a class="header" href="#关闭打开的句柄">关闭打开的句柄</a></h2>
<p>诸如文件之类的 io 流，都会有一个 close 操作。因此为了确保关闭，可以使用 contextlib 中的一个叫做 closing 的类。</p>
<pre><code class="language-python">import contextlib

class Open:

    def __init__(self):
        self.status = &quot;open&quot;

    def main(self):
        return &quot;执行了很复杂的逻辑&quot;

    def close(self):
        self.status = &quot;closed&quot;


with contextlib.closing(Open()) as f:
    print(f.main())  # 执行了很复杂的逻辑
    print(f&quot;状态: {f.status}&quot;)  # 状态: open

# with 语句结束后
print(f&quot;状态: {f.status}&quot;)  # 状态: closed
</code></pre>
<p>contextlib.closing 接收一个类的实例对象，其实主要就帮我们做了两件事：一个是可以通过 with 语句的方式来执行，另一个是执行完毕之后自动帮我们调用 close 方法。这里我们不手动实现了，非常简单，感觉没啥卵用，直接看源码中是如何实现的吧。</p>
<pre><code class="language-python">class closing(AbstractContextManager):

    def __init__(self, thing):
        # 这里的 thing 显然是我们之前传入的 Open 的实例对象 f
        self.thing = thing
    def __enter__(self):
        # 先调用 __enter__ 返回之前的实例
        return self.thing
    def __exit__(self, *exc_info):
        # 最后调用我们实例的 close 方法
        self.thing.close()
</code></pre>
<p>因此当使用 closing 的时候，我们的类必须定义 close。</p>
<h2 id="忽略异常"><a class="header" href="#忽略异常">忽略异常</a></h2>
<p>很多情况下，忽略产生的异常很有用，如果这个异常无法百分百避免、并且该异常又没啥卵用，那么就可以忽略掉。而要忽略异常，最常用的办法就是利用一个 try except 语句。</p>
<p>但在我们当前的主题中，try except 也可以被替换成 contextlib.suppress()，以更显示地抑制 with 块中产生的异常。</p>
<pre><code class="language-python">import contextlib

def foo():
    print(123)
    1 / 0
    print(456)


with contextlib.suppress(ZeroDivisionError, TypeError):
    foo()
    print(789)
&quot;&quot;&quot;
123
&quot;&quot;&quot;
</code></pre>
<p>在 foo 中出现了除零错误，但是程序并没有报错，相当于异常被镇压了。注意：如果 with 块中出现的异常，无法匹配 suppress 接收的异常，那么异常还是会抛出来的。但是对于当前的例子来说，除零错误显然是被成功捕获了，最终只输出了 123。并且不仅 1/0 下面的 456 没有打印，连 foo() 下面的 789 也没有打印。</p>
<p>因为只要出现了异常，就会进入到 __exit__ 中，我们看一下源码是如何实现的。</p>
<pre><code class="language-python">class suppress(AbstractContextManager):
    def __init__(self, *exceptions):
        self._exceptions = exceptions

    def __enter__(self):
        pass

    def __exit__(self, exctype, excinst, exctb):
        return exctype is not None and issubclass(exctype, self._exceptions)
</code></pre>
<p>非常简单，没有发生异常就不说了。如果发生异常，但只要能和给定的异常相匹配的话，程序也不会报错。</p>
<h2 id="异步上下文管理器的实现"><a class="header" href="#异步上下文管理器的实现">异步上下文管理器的实现</a></h2>
<p>Python 在 3.5 的时候引入了 async 和 await，可以通过 async def 定义一个原生的协程函数，通过 await 驱动一个协程执行。</p>
<p><strong>而异步上下文则可以通过 async with 来实现。</strong></p>
<pre><code class="language-python">import asyncio

class A:

    def __init__(self, name):
        self.name = name

    async def __aenter__(self):
        print(&quot;__aenter__&quot;)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        print(&quot;__aexit__&quot;)
        return True


# 必须定义一个协程函数，然后通过事件循环驱动协程执行
async def main():
    async with A(&quot;古明地觉&quot;) as f:
        print(f.name)


asyncio.run(main())
&quot;&quot;&quot;
__aenter__
古明地觉
__aexit__
&quot;&quot;&quot;
</code></pre>
<p>异步上下文管理需要定义 __aenter__ 和 __aexit__。</p>
<pre><code class="language-python">import contextlib
import asyncio

@contextlib.asynccontextmanager
async def foo():
    print(123)
    yield 456
    print(789)

async def main():
    async with foo() as f:
        print(f == 456)

asyncio.run(main())
&quot;&quot;&quot;
123
True
789
&quot;&quot;&quot;
</code></pre>
<p>关于异步上下文管理，其实和普通的同步上下文管理是类似的，其它相关内容有兴趣可以自己实现一下。</p>
<h2 id="小结-9"><a class="header" href="#小结-9">小结</a></h2>
<p>以上就是 with 语句的用法，非常基础的内容了，当然我们还介绍了一个模块 contextlib，在工作中也可以多多使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-13"><a class="header" href="#楔子-13">楔子</a></h2>
<p>Python 标准库提供了一个 collections 模块，里面提供了很多的数据类，在工作中使用这些类能够简化我们的开发。</p>
<p>下面就来看看这个模块能够帮助我们做哪些事情？</p>
<h2 id="搜索多个字典"><a class="header" href="#搜索多个字典">搜索多个字典</a></h2>
<p>假设当前有 3 个字典：dct1、dct2、dct3，现在要通过 key 查找对应的 value。如果 key 在 dct1 里面存在，那么直接返回，否则从 dct2 里面找。dct2 里面如果不存在，那么从 dct3 里面找。</p>
<p>这个需求该怎么实现呢？</p>
<pre><code class="language-python">dct1 = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
dct2 = {&quot;d&quot;: 4, &quot;e&quot;: 5, &quot;f&quot;: 6}
dct3 = {&quot;e&quot;: 7, &quot;f&quot;: 8, &quot;g&quot;: 9}

def get_value_by_key(key):
    if key in dct1:
        return dct1[key]
    elif key in dct2:
        return dct2[key]
    elif key in dct3:
        return dct3[key]
    else:
        raise KeyError

print(get_value_by_key(&quot;b&quot;))  # 2
print(get_value_by_key(&quot;d&quot;))  # 4
print(get_value_by_key(&quot;f&quot;))  # 6
</code></pre>
<p>实现起来非常简单，但通过 ChainMap 对象可以更方便地做到这一点。</p>
<pre><code class="language-python">from collections import ChainMap

dct1 = {&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3}
dct2 = {&quot;b&quot;: 4, &quot;c&quot;: 5, &quot;d&quot;: 6}

# 将多个字典传进去，
dct = ChainMap(dct1, dct2)

# 如果多个字典存在相同的 key，那么返回第一次出现的 key 对应的 value
print(dct[&quot;b&quot;], dct[&quot;d&quot;])
&quot;&quot;&quot;
2 6
&quot;&quot;&quot;

# 字典的 API 都可以使用
print(dct.items())
&quot;&quot;&quot;
ItemsView(ChainMap({'a': 1, 'b': 2, 'c': 3}, {'b': 4, 'c': 5, 'd': 6}))
&quot;&quot;&quot;

# 也可以使用 get，如果 key 在所有的字典中都不存在，则返回默认值
print(dct.get(&quot;k&quot;, 333))
&quot;&quot;&quot;
333
&quot;&quot;&quot;

# ChainMap 对象有一个 maps 属性，存储了要搜索的映射列表
# 这个列表是可变的，所以可以直接增加新映射，或者改变元素的顺序以控制查找和更新行为。
print(dct.maps)
&quot;&quot;&quot;
[{'a': 1, 'b': 2, 'c': 3}, {'b': 4, 'c': 5, 'd': 6}]
&quot;&quot;&quot;

# dct.maps 保存了原始的字典，修改 dct.maps 会影响原字典
print(dct1)
&quot;&quot;&quot;
{'a': 1, 'b': 2, 'c': 3}
&quot;&quot;&quot;
dct.maps[0][&quot;a&quot;] = 11111111
print(dct1)
&quot;&quot;&quot;
{'a': 11111111, 'b': 2, 'c': 3}
&quot;&quot;&quot;
# 同理修改原字典，也会影响 dct.maps
</code></pre>
<p>以上就是 ChainMap 对象的用法，当你需要从多个字典中进行搜索的话，它会很有用。</p>
<h2 id="统计可散列的对象"><a class="header" href="#统计可散列的对象">统计可散列的对象</a></h2>
<p>我们经常会遇到数量统计相关的问题，比如有一个序列，计算里面每个元素出现了多少次。一般情况下，我们会这么做。</p>
<pre><code class="language-python">words = [&quot;hello&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;beautiful&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;cruel&quot;, &quot;world&quot;]

counter = {}
for word in words:
    if word in counter:
        counter[word] += 1
    else:
        counter[word] = 1

print(counter)
&quot;&quot;&quot;
{'hello': 3, 'world': 3, 'beautiful': 1, 'cruel': 1}
&quot;&quot;&quot;
</code></pre>
<p>实现方法没有任何问题，但通过 Counter 会更方便，并且还提供了更多功能。</p>
<pre><code class="language-python">from collections import Counter

words = [&quot;hello&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;beautiful&quot;, &quot;world&quot;,
         &quot;hello&quot;, &quot;cruel&quot;, &quot;world&quot;]

# 将序列传进去即可
counter = Counter(words)
print(counter)
&quot;&quot;&quot;
Counter({'hello': 3, 'world': 3, 'beautiful': 1, 'cruel': 1})
&quot;&quot;&quot;

# Counter 继承 dict，所以字典的 API 它也是都支持的
counter = Counter(hello=3, world=3, beautiful=1, cruel=1)
print(counter)
&quot;&quot;&quot;
Counter({'hello': 3, 'world': 3, 'beautiful': 1, 'cruel': 1})
&quot;&quot;&quot;
</code></pre>
<p>Counter 对象还支持动态更新操作，举个例子：</p>
<pre><code class="language-python">from collections import Counter

# Counter 需要接收一个可迭代对象，然后会遍历它
# 所以结果就是 a 出现了三次，b 出现了两次，c 出现了一次
counter = Counter(&quot;aaabbc&quot;)
print(counter)
&quot;&quot;&quot;
Counter({'a': 3, 'b': 2, 'c': 1})
&quot;&quot;&quot;

# 也可以动态更新，比如又来了一个序列，需要和当前的 counter 组合起来进行统计
counter.update(&quot;bcd&quot;)
print(counter)
&quot;&quot;&quot;
Counter({'a': 3, 'b': 3, 'c': 2, 'd': 1})
&quot;&quot;&quot;
# 可以看到 b 和 c 的值都增加了 1，并且出现了 d
# 需要注意的是：update 方法同样接收一个可迭代对象，然后进行遍历
# 如果我希望添加一个 key 叫 &quot;bcd&quot; 的话，那么要这么做
counter.update([&quot;bcd&quot;])
print(counter)
&quot;&quot;&quot;
Counter({'a': 3, 'b': 3, 'c': 2, 'd': 1, 'bcd': 1})
&quot;&quot;&quot;

# 访问计数，Counter 对象可以像字典一样访问
print(counter[&quot;a&quot;])  
&quot;&quot;&quot;
3
&quot;&quot;&quot;
# 如果访问一个不存在的 key，不会引发 KeyError
# 而是会返回 0，表示对象中没有这个 key
print(counter[&quot;mmp&quot;])  
&quot;&quot;&quot;
0
&quot;&quot;&quot;

# 还可以计算出现最多的元素，这是用的最频繁的一个功能
# 统计 string 中前三个出现次数最多的元素
string = &quot;sasaxzsdsadfscxzcasdscxzdfscxsasadszczxczxcsds&quot;
counter = Counter(string)
print(counter)
&quot;&quot;&quot;
Counter({'s': 13, 'c': 7, 'a': 6, 'x': 6, 'z': 6, 'd': 6, 'f': 2})
&quot;&quot;&quot;
print(counter.most_common(3))
&quot;&quot;&quot;
[('s', 13), ('c', 7), ('a', 6)]
&quot;&quot;&quot;
</code></pre>
<p>Counter 对象还有一个强大的功能，就是它支持算数操作以及位运算。</p>
<pre><code class="language-python">from collections import Counter

counter1 = Counter(&quot;aabbccc&quot;)
counter2 = Counter(&quot;bbbccdd&quot;)
print(counter1)  
print(counter2)  
&quot;&quot;&quot;
Counter({'a': 2, 'b': 2, 'c': 3})
Counter({'b': 3, 'c': 2, 'd': 2})
&quot;&quot;&quot;
# 如果 counter1 的元素出现在了 counter2 中，就把该元素减去，记住：减的是次数
print(counter1 - counter2)  
&quot;&quot;&quot;
Counter({'a': 2, 'c': 1})
&quot;&quot;&quot;
# a 在 counter1 中出现了 2 次，在 counter2 中没有出现，所以是 a: 2
# b 在 counter1 中出现了 2 次，在 counter2 中出现 3 次，所以一减就没有了
# c 在 counter1 中出现了 3 次，在 counter2 中出现 2 次，所以相减还剩下一次
# 至于 counter1 中没有的元素就不用管了


# 相加就很好理解了
print(counter1 + counter2) 
&quot;&quot;&quot;
Counter({'b': 5, 'c': 5, 'a': 2, 'd': 2}) 
&quot;&quot;&quot;

# 相交的话，查找公共的元素，并且取次数出现较小的那个
print(counter1 &amp; counter2)  
&quot;&quot;&quot;
Counter({'b': 2, 'c': 2})
&quot;&quot;&quot;

# 并集的话，取较大的，记住不是相加
# 所以 b 和 c 出现的次数不会增加，只是取较大的那个
print(counter1 | counter2)  
&quot;&quot;&quot;
Counter({'b': 3, 'c': 3, 'a': 2, 'd': 2})
&quot;&quot;&quot;
</code></pre>
<p>以上就是 Counter 的用法，更多的还是统计次数，求 topK。</p>
<h2 id="缺少的键返回默认值"><a class="header" href="#缺少的键返回默认值">缺少的键返回默认值</a></h2>
<p>很明显，这是针对于字典的。首先字典也支持这种操作，通过 setdefault 和 get 两个方法，可以用来获取 key 对应的 value，并且还能在 key 不存在的时候给一个默认值。</p>
<p>如果 key 存在，两者会获取 key 对应的 value；但如果 key 不存在，setdefault 会先将 key 和指定的默认值设置进去，然后再将设置的值返回，而 get 则只会返回默认值，不会进行设置。</p>
<pre><code class="language-python">d = {&quot;a&quot;: 1}
# 如果 key 存在，直接返回 value
print(d.get(&quot;a&quot;, 0))  # 1
print(d.setdefault(&quot;a&quot;, 0))  # 1
# 原字典不受影响
print(d)  # {&quot;a&quot;: 1}

# key 不存在，则返回指定的默认值
print(d.get(&quot;b&quot;, 0))  # 0
# 原字典不受影响
print(d)  # {&quot;a&quot;: 1}

# key 不存在的话，会将 key 和默认值组成键值对，设置在字典中
print(d.setdefault(&quot;b&quot;, 0))  # 0
print(d)  # {&quot;a&quot;: 1, &quot;b&quot;: 0}
</code></pre>
<p>指的一提的是，setdefault 是一个非常实用且简洁的方法，但用的却不多。我们举一个例子：</p>
<pre><code class="language-python">data = [
    (&quot;banana&quot;, 15), (&quot;banana&quot;, 17), (&quot;banana&quot;, 22),
    (&quot;apple&quot;, 31), (&quot;apple&quot;, 30), (&quot;apple&quot;, 33),
    (&quot;orange&quot;, 45), (&quot;orange&quot;, 47), (&quot;orange&quot;, 44),
]
# 如果我希望将 data 转成以下格式，该怎么办呢？
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;

def change_data1():
    result = {}
    for product, count in data:
        if product not in result:
            result[product] = [count]
        else:
            result[product].append(count)
    return result

print(change_data1())
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;

# 结果没问题，但如果用 setdefault 的话会更方便
def change_data2():
    result = {}
    for product, count in data:
        result.setdefault(product, []).append(count)
    return result

print(change_data2())
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;
</code></pre>
<p>但这个功能也可以通过 defaultdict 完成，该类要求调用者传递一个类型，当 key 不存在时会返回对应类型的零值。</p>
<pre><code class="language-python">from collections import defaultdict

d = defaultdict(int)
print(d)  # defaultdict(&lt;class 'int'&gt;, {})
print(d[&quot;a&quot;])  # 0
print(d)  # defaultdict(&lt;class 'int'&gt;, {'a': 0})

d = defaultdict(tuple)
print(d)  # defaultdict(&lt;class 'tuple'&gt;, {})
print(d[&quot;a&quot;])  # ()
print(d)  # defaultdict(&lt;class 'tuple'&gt;, {'a': ()})

# 之前的例子就可以这么做
data = [
    (&quot;banana&quot;, 15), (&quot;banana&quot;, 17), (&quot;banana&quot;, 22),
    (&quot;apple&quot;, 31), (&quot;apple&quot;, 30), (&quot;apple&quot;, 33),
    (&quot;orange&quot;, 45), (&quot;orange&quot;, 47), (&quot;orange&quot;, 44),
]

result = defaultdict(list)
for product, count in data:
    result[product].append(count)
# defaultdict 继承 dict，支持字典的 API
print(dict(result))
&quot;&quot;&quot;
{'banana': [15, 17, 22], 
 'apple': [31, 30, 33], 
 'orange': [45, 47, 44]}
&quot;&quot;&quot;
# 整个过程就是，key 如果存在，那么获取 value
# key 不存在，那么将指定类型的零值作为 value（这里是空列表）
# 并且返回之前，会先将 key、value 添加到键值对中

# 再比如之前的词频统计
string = &quot;aabbccdddddee&quot;
counter = defaultdict(int)
for c in string:
    counter[c] += 1
print(dict(counter))
&quot;&quot;&quot;
{'a': 2, 'b': 2, 'c': 2, 'd': 5, 'e': 2}
&quot;&quot;&quot;
</code></pre>
<p>怎么样，是不是很方便呢？在实例化 defaultdict 的时候，指定一个类型即可，获取一个不存在的 key 的时候，会返回指定的类型的零值，并且还会将 key 和零值添加到字典中。</p>
<p>此外 defaultdict 还可以自定义返回值，只需要指定一个不需要参数的函数即可。</p>
<pre><code class="language-python">from collections import defaultdict

# 此时的默认值就是 default
d = defaultdict(lambda: &quot;default&quot;)
print(d[&quot;aa&quot;])  # default

# 此外还可以添加参数，因为单独指定了 aa，所以打印的时候以指定的为准
# 如果没有指定，那么才会得到默认值
d4 = defaultdict(lambda: &quot;default&quot;, aa=&quot;bar&quot;)
print(d4[&quot;aa&quot;])  # bar
print(d4[&quot;bb&quot;])  # default
</code></pre>
<p>那么估计会有人好奇，这是如何实现的呢？其实主要是实现了一个叫做 __missing__ 的魔法方法。字典在查找元素的时候，会调用 __getitem__，然后在找不到的时候会去调用 __missing__。但是注意：dict 这个类本身并没有实现 __missing__，所以我们需要继承自 dict，然后在子类中实现。</p>
<pre><code class="language-python">class MyDict(dict):

    def __getitem__(self, item):
        # 执行父类的 __getitem__ 方法
        # 如果 key 不存在，会去执行 __missing__ 方法
        value = super().__getitem__(item)
        # 所以这里的 value 就是 __missing__ 方法的返回值
        return value

    def __missing__(self, key):
        self[key] = &quot;搞事情ﾍ(´ー｀ﾍ)搞事情&quot;
        return self[key]


d = MyDict([(&quot;a&quot;, 3), (&quot;b&quot;, 4)])
print(d)  # {'a': 3, 'b': 4}
print(d[&quot;mmm&quot;])  # 搞事情ﾍ(´ー｀ﾍ)搞事情
print(d)  # {'a': 3, 'b': 4, 'mmm': '搞事情ﾍ(´ー｀ﾍ)搞事情'}
</code></pre>
<p>都是一些基础的内容了，突然想到了，就提一遍。</p>
<h2 id="双端队列"><a class="header" href="#双端队列">双端队列</a></h2>
<p>如果你需要维护一个序列，并根据需求动态地往序列的尾部添加元素和弹出元素，那么你会选择什么序列呢？很明显，如果只在尾部操作，那么列表一定是最合适的选择。</p>
<p>但如果我们操作的不止是尾部，还有头部呢？比如往序列的头部添加和弹出元素，此时双端队列就是一个不错的选择。</p>
<p>双端队列支持从任意一端添加和删除元素，更为常用的两种数据结构（即栈和队列）就是双端队列的退化形式，它们的输入和输出被限制在某一端。</p>
<pre><code class="language-python">from collections import deque

# 接收一个可迭代对象，然后进行遍历
d = deque(&quot;abcdefg&quot;)
print(d) 
&quot;&quot;&quot;
deque(['a', 'b', 'c', 'd', 'e', 'f', 'g'])
&quot;&quot;&quot;
print(len(d)) 
&quot;&quot;&quot;
7
&quot;&quot;&quot;
print(d[0]) 
&quot;&quot;&quot;
a
&quot;&quot;&quot;
print(d[-1])  
&quot;&quot;&quot;
g
&quot;&quot;&quot;

# 由于 deque 是一种序列容器，因此同样支持 list 的操作
# 如：通过索引获取元素，查看长度，删除元素，反转元素等等
# list 支持的操作，deque 基本上都支持
d.reverse()
print(d)  # deque(['g', 'f', 'e', 'd', 'c', 'b', 'a'])
d.remove(&quot;c&quot;)
print(d)  # deque(['g', 'f', 'e', 'd', 'b', 'a'])
</code></pre>
<p>deque 还有很多的 API，比如添加元素。</p>
<pre><code class="language-python">from collections import deque

d = deque(&quot;abc&quot;)

# 添加元素，可以从两端添加
d.append(&quot;Hello&quot;)  # 从尾部添加
d.appendleft(&quot;World&quot;)  # 也可以从头部添加
print(d)
&quot;&quot;&quot;
deque(['World', 'a', 'b', 'c', 'Hello'])
&quot;&quot;&quot;

# 还可以使用 insert, 如果范围越界，自动添加在两端
d.insert(100, &quot;古明地觉&quot;)
print(d)
&quot;&quot;&quot;
deque(['World', 'a', 'b', 'c', 'Hello', '古明地觉'])
&quot;&quot;&quot;

# 也可以通过extend，extendleft 一次添加多个元素
d = deque([1, 2, 3])
d.extend([4, 5, 6])
print(d)
&quot;&quot;&quot;
deque([1, 2, 3, 4, 5, 6])
&quot;&quot;&quot;
d.extendleft([7, 8, 9])
print(d)
&quot;&quot;&quot;
deque([9, 8, 7, 1, 2, 3, 4, 5, 6])
&quot;&quot;&quot;
# 注意添加的顺序，我们是从左边开始添加的
# 先添加 7，然后 8 会跑到 7 的左边，所以是结果是倒过来的
</code></pre>
<p>再来看看删除元素：</p>
<pre><code class="language-python">from collections import deque

d = deque(range(1, 7))
print(d)
&quot;&quot;&quot;
deque([1, 2, 3, 4, 5, 6])
&quot;&quot;&quot;

# 调用 pop 方法可以从尾部弹出一个元素
print(d.pop())  # 6
print(d.pop())  # 5
print(d.pop())  # 4
# pop 是从右端删除一个元素，popleft 是从左端开始删除一个元素
# 但如果想 pop 掉指定索引的元素，则只能用 pop 函数，传入索引值即可
print(d.popleft())  # 1
print(d)
&quot;&quot;&quot;
deque([2, 3])
&quot;&quot;&quot;
# 注意：deque 和 queue一样，是线程安全的
# 它们均受 GIL 这把超级大锁保护，可以不同的线程中进行消费
# 如果想清空里面的元素，可以像 list、dict 一样，使用 clear 方法
d.clear()
print(d)  
&quot;&quot;&quot;
deque([])
&quot;&quot;&quot;
</code></pre>
<p>最后 deque 还有一个非常有意思的方法，叫 rotate，它是做什么的呢？来看一下。</p>
<pre><code class="language-python">from collections import deque

# 按任意一个方向进行旋转，从而跳过某些元素。
# d.rotate(n)：n 大于0，从右边开始取 n 个元素放到左边
# n 小于 0，从左边取 n 个元素放到右边
d = deque(range(10))
print(d)  
&quot;&quot;&quot;
deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
&quot;&quot;&quot;

# 从右边取 2 个元素放到左边，所以 8 和 9 被放到了左边
d.rotate(2)
print(d)  
&quot;&quot;&quot;
deque([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
&quot;&quot;&quot;
d.rotate(-3)
# 从左边取 3 个元素放到右边，所以 8、9、0 被放到了右边
print(d)  
&quot;&quot;&quot;
deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])
&quot;&quot;&quot;
</code></pre>
<p>当然双端队列默认是容量无限的，但很多时候我们需要给队列加上容量限制，如何加呢？</p>
<pre><code class="language-python">from collections import deque

# 限制队列的大小
# 我们在初始化一个双端队列的时候，还可以限制它的大小
d = deque(&quot;abcdefg&quot;, maxlen=5)
# 我们初始化 7 个元素，但是指定最大长度只有 5
# 所以前面两个元素（&quot;a&quot; 和 &quot;b&quot;）就被挤出去了
print(d)
&quot;&quot;&quot;
deque(['c', 'd', 'e', 'f', 'g'], maxlen=5)
&quot;&quot;&quot;

# 当我往前面添加元素的时候，后面的就被挤出去了
# 因为队列最多只能容纳 5 个元素
d.appendleft(&quot;Hello&quot;)
print(d)  
&quot;&quot;&quot;
deque(['Hello', 'c', 'd', 'e', 'f'], maxlen=5)
&quot;&quot;&quot;
</code></pre>
<p>当你要维护一个从首尾两端添加、删除元素的序列时，使用 deque 是一个非常正确的选择。比如 asyncio 的锁 Lock，当获取锁时，就会创建一个 Future 对象，并保存在双端队列中。</p>
<h2 id="带有名字的元组"><a class="header" href="#带有名字的元组">带有名字的元组</a></h2>
<p>元组的话，我们都是通过索引来获取元素，但通过索引的话，如果你不手动数一数，你是不知道该索引会对应哪一个元素的。所以问题来了，可不可以给里面的元素一个字段名呢？我们通过字段名来获取对应的值不就行啦，没错，这就是 namedtuple。</p>
<pre><code class="language-python">from collections import namedtuple

# 传入名字，和字段
Person = namedtuple(&quot;Person&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;gender&quot;])
person1 = Person(name=&quot;satori&quot;, age=16, gender=&quot;f&quot;)
print(person1)
&quot;&quot;&quot;
Person(name='satori', age=16, gender='f')
&quot;&quot;&quot;
print(person1.name, person1.age, person1.gender)
&quot;&quot;&quot;
satori 16 f
&quot;&quot;&quot;
print(person1[0])
&quot;&quot;&quot;
satori
&quot;&quot;&quot;
# 不仅可以像普通的 tuple 一样使用索引访问
# 还可以像类一样通过 . 字段名访问

person2 = Person(&quot;satori&quot;, 16, &quot;f&quot;)
# 注意：这个和普通的元组一样，是不可以修改的
try:
    person2.name = &quot;xxx&quot;
except AttributeError as e:
    print(e)  # can't set attribute

# 非法字段名，不能使用 Python 的关键字
try:
    namedtuple(&quot;keywords&quot;, [&quot;for&quot;, &quot;in&quot;])
except ValueError as e:
    print(e)
    &quot;&quot;&quot;
    Type names and field names cannot be a keyword: 'for'
    &quot;&quot;&quot;

# 如果字段名重复了，会报错
try:
    namedtuple(&quot;Person&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;age&quot;])
except ValueError as e:
    print(e)
    &quot;&quot;&quot;
    Encountered duplicate field name: 'age'
    &quot;&quot;&quot;

# 如果非要加上重名字段，可以设置一个参数
Person = namedtuple(&quot;Person&quot;, [&quot;name&quot;, &quot;age&quot;, &quot;age&quot;],
                    rename=True)
print(Person)  
&quot;&quot;&quot;
&lt;class '__main__.Person'&gt;
&quot;&quot;&quot;
person3 = Person(&quot;koishi&quot;, 15, 15)
# 可以看到重复的字段名会按照索引的值，在前面加上一个下划线
# 比如第二个 age 重复，它的索引是多少呢？是 2，所以默认帮我们把字段名修改为 _2
print(person3)  
&quot;&quot;&quot;
Person(name='koishi', age=15, _2=15)
&quot;&quot;&quot;
# 此外我们所有的字段名都保存在 _fields 属性中
print(person3._fields)  
&quot;&quot;&quot;
('name', 'age', '_2')
&quot;&quot;&quot;
</code></pre>
<p>但 namedtuple 还有一个不完美的地方，就是它无法指定字段的类型，所以我们更推荐使用 typing 模块里的 NamedTuple。</p>
<pre><code class="language-python">from typing import NamedTuple

class Person(NamedTuple):
    name: str
    age: int
    gender: str

p = Person(&quot;satori&quot;, 16, &quot;f&quot;)
print(p)
&quot;&quot;&quot;
Person(name='satori', age=16, gender='f')
&quot;&quot;&quot;
# 同样能够基于索引和字段名来获取值
print(p[0], p.name)
&quot;&quot;&quot;
satori satori
&quot;&quot;&quot;

# 创建类的话，还可以这么创建
Person = NamedTuple('Person', name=str, age=int, gender=str)
Person = NamedTuple(
    'Person', [(&quot;name&quot;, str), (&quot;age&quot;, int), (&quot;gender&quot;, str)]
)
</code></pre>
<p>更建议使用 NamedTuple。</p>
<h2 id="记住键值对顺序的字典"><a class="header" href="#记住键值对顺序的字典">记住键值对顺序的字典</a></h2>
<p>从 Python3.6 开始，字典遍历默认是有序的，但我们不应该依赖这个特性。如果希望字典有序，应该使用 OrderDict 字典子类。</p>
<pre><code class="language-python">from collections import OrderedDict

d = OrderedDict()
d[&quot;a&quot;] = &quot;A&quot;
d[&quot;b&quot;] = &quot;B&quot;
d[&quot;c&quot;] = &quot;C&quot;
for k, v in d.items():
    print(k, v)
&quot;&quot;&quot;
a A
b B
c C
&quot;&quot;&quot;
# 此外也可以在初始化的时候，添加元素
print(OrderedDict({&quot;a&quot;: 1}))  
&quot;&quot;&quot;
OrderedDict([('a', 1)])
&quot;&quot;&quot;

# 相等性，对于常规字典来说，只要里面元素一样便是相等的，不考虑顺序
# 但是对于OrderDict来说，除了元素，顺序也要一样，否则就不相等
d1 = {&quot;a&quot;: 1, &quot;b&quot;: 2}
d2 = {&quot;b&quot;: 2, &quot;a&quot;: 1}
print(d1 == d2)  
&quot;&quot;&quot;
True
&quot;&quot;&quot;

d1 = OrderedDict({&quot;a&quot;: 1, &quot;b&quot;: 2})
d2 = OrderedDict({&quot;b&quot;: 2, &quot;a&quot;: 1})
print(d1 == d2)  
&quot;&quot;&quot;
False
&quot;&quot;&quot;

# 重排，在 OrderDict 中可以使用 move_to_end 方法
# 将某个键移动到序列的起始位置或末尾位置来改变顺序
d3 = OrderedDict({&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4})
# 表示将 key=&quot;c&quot; 的键值对移动到末尾
d3.move_to_end(&quot;c&quot;)  
print(d3)  
&quot;&quot;&quot;
OrderedDict([('a', 1), ('b', 2), ('d', 4), ('c', 3)])
&quot;&quot;&quot;
# 表示将 key=&quot;c&quot; 的这个键值对移动到行首
d3.move_to_end(&quot;c&quot;, last=False)  
print(d3)  
&quot;&quot;&quot;
OrderedDict([('c', 3), ('a', 1), ('b', 2), ('d', 4)])
&quot;&quot;&quot;

# 从尾部弹出一个元素
print(d3.popitem())
&quot;&quot;&quot;
('d', 4)
&quot;&quot;&quot;
# 从头部弹出一个元素
print(d3.popitem(last=False))
&quot;&quot;&quot;
('c', 3)
&quot;&quot;&quot;
</code></pre>
<p>使用 OrderDict 要比 dict 更加耗费内存，因此在存储大量键值对的时候，思考一下，是否需要保证键值对有序。</p>
<p>但在实现 LRU 缓存的时候，OrderDict 非常常用，比如某个键被访问了，通过 move_to_end 移到头部。当缓存满了的时候，通过 popitem 弹出尾部元素。</p>
<h2 id="小结-10"><a class="header" href="#小结-10">小结</a></h2>
<p>以上就是 collections 模块的用法，这个模块还是非常好用的，我们拿出来说一说。</p>
<div style="break-before: page; page-break-before: always;"></div><p>本次我们来聊一聊 Python 的一个内置模块：unicodedata，它是专门用来处理 unicode 字符串的，下面来看看它的用法。</p>
<p><strong><font color="blue">unicodedata.normalize</font></strong></p>
<p>负责对 unicode 字符串进行规范化处理，因为有些字符看似长度为 1，但其实不是，举个例子：</p>
<pre><code class="language-python">s1 = &quot;é&quot;
s2 = &quot;é&quot;
s3 = &quot;e\u0301&quot;
print(len(s1))  # 1
print(len(s2))  # 2
print(len(s3))  # 2
print(s1 == s2)  # False
print(s2 == s3)  # True
print(s1, s2, s3)  # é é é
</code></pre>
<p>相信打印结果会让你感到诧异，s2 的长度看似为 1，但其实是 2，这是因为 Python3 的字符串存储的其实是码位序列。而某些字符可以有多种表示方式，比如 é：</p>
<ul>
<li>预组合字符：代码中的 s1，这是一个单一的 unicode 码点，表示带有重音符号的小写字母 e；</li>
<li>分解序列：代码中的 s3，将小写字母 e 和重音符号（\u0301）分开，使用两个 unicode 码点表示，而 s2 虽然看起来和 s1 一样，但它的表示方式和 s3 是相同的；</li>
</ul>
<pre><code class="language-python"># 两个码点
s = &quot;é&quot;
print(s[0] == &quot;e&quot;)  # True
print(s[1] == &quot;\u0301&quot;)  # True
</code></pre>
<p>这种情况直接处理的话会比较头疼，所以 normalize 的作用就是规范化，让多个码点表示的字符使用一个码点表示。规范化前后的字符串长得一样，但是长度变短了。</p>
<pre><code class="language-python">import unicodedata

s1 = &quot;lové&quot;
s2 = &quot;lové&quot;
s3 = &quot;love\u0301&quot;
print(s1 == s2 == s3)  # False
print(len(s1), len(s2), len(s3))  # 4 5 5

# 对字符串进行规范化，第一个参数是规范化方式，第二个参数是字符串
# &quot;NFC&quot;：将多个码点表示的字符替换为等效的单个码点形式
normalize_s2 = unicodedata.normalize(&quot;NFC&quot;, s2)
normalize_s3 = unicodedata.normalize(&quot;NFC&quot;, s3)
print(
    s1 == normalize_s2 == normalize_s3
)  # True

print(s2, normalize_s2)  # lové lové
print(len(s2), len(normalize_s2))  # 5 4
</code></pre>
<p>规范化方式除了 NFC 之外还有 NFD，它和 NFC 是相反的，表示让一个码点表示的字符使用多个码点表示。</p>
<pre><code class="language-python">import unicodedata

s1 = &quot;lové&quot;
s2 = &quot;lové&quot;
s3 = &quot;love\u0301&quot;

print(len(s1), len(s2), len(s3))  # 4 5 5

# s1 中的 é 使用一个码点表示，这里让它变成等效的两个码点
normalize_s1 = unicodedata.normalize(&quot;NFD&quot;, s1)
print(len(normalize_s1))  # 5

print(s1 == s3)  # False
print(normalize_s1 == s3)  # True
</code></pre>
<p>因此这就是 unicode 的规范化处理，因为有的 unicode 字符可以有多种表示方式，可以是一个码点，也可以是两个码点，但它们长得都一样。NFC 是让两个码点表示的字符使用一个码点表示，NFD 是让一个码点表示的字符使用两个码点表示。</p>
<p>但需要注意：如果字符只有一种表示方式，那么规范化前后的结果是一样的。</p>
<pre><code class="language-python">import unicodedata

# 这六个字符都只有一种表示方式
s = &quot;satori&quot;
nfc_s = unicodedata.normalize(&quot;NFC&quot;, s)
nfd_s = unicodedata.normalize(&quot;NFD&quot;, s)
print(s == nfc_s == nfd_s)  # True

# 这个 emoji 同样只有一种表示方式，并且占用两个码点
s = &quot;😀&quot;
nfc_s = unicodedata.normalize(&quot;NFC&quot;, s)
nfd_s = unicodedata.normalize(&quot;NFD&quot;, s)
print(s == nfc_s == nfd_s)  # True
</code></pre>
<p>所以 NFC 相当于组合，NFD 相当于分解。</p>
<p>然后除了 NFC 和 NFD 之外，还有 NFKC 和 NFKD，它们有什么区别呢？用大白话解释就是：</p>
<ul>
<li>NFC 和 NFD 标准化前后的字符，虽然占用的码点不同，但起码长得一样，两者在外观上是等价的。这种替换方式也被称为标准替换。</li>
<li>而 NFKC 和 NFKD 则是兼容替换，它们更关注文字语义的表达。</li>
</ul>
<pre><code class="language-python">import unicodedata

print(unicodedata.normalize(&quot;NFKD&quot;, &quot;㍿&quot;))  # 株式会社
print(unicodedata.normalize(&quot;NFKD&quot;, &quot;㊥&quot;))  # 中
print(
    unicodedata.normalize(&quot;NFKD&quot;, &quot;①②③④⑤&quot;)
)  # 12345

# 上述几个字符串如果使用 NFC、NFD 标准化，那么结果还是原来的样子
# 而 '㍿' 和 '株式会社' 显然不是一个东西，它们长的都不一样
# 所以这两者不可能是同一个字符的不同表达形式
# 但从人类的思维来说，这两者就是一个东西，在语义上是等价的

# 所以 NFKD 是兼容替换，说白了就是按照语义替换
# 比如全角转半角，组合字符分解成多个独立字符
comma1 = &quot;，&quot;
comma2 = &quot;,&quot;
print(
    unicodedata.normalize(&quot;NFD&quot;, comma1) == comma2
)  # False
print(
    unicodedata.normalize(&quot;NFKD&quot;, comma1) == comma2
)  # True

# comma1 是中文的逗号，comma2 是英文的逗号
# 采用 NFD 标准化的结果和之前一样，因为全角和半角压根不是一个东西
# 但对于人类而言，一眼就知道它们都是逗号
# 所以 NFKD 标准化之后，会将中文逗号转成英文逗号
</code></pre>
<p>所以这几种规范化方式区别如下：</p>
<ul>
<li>NFC：某些字符可以有多种表达方式，将多个码点表示的字符转成使用一个码点表示，字符在替换前后的外观是一样的；</li>
<li>NFD：和 NFC 相反，将一个码点表示的字符转成使用多个码点表示，字符在替换前后的外观也是一样的；</li>
<li>NFKD：按照语义对字符进行兼容分解（全角转半角，组合字符分解），前后外观会发生变化，但现实语义不变。比如 ㊥ 和 中，㊋ 和 火；</li>
<li>NFKC：NFKD 是兼容分解，直接就完事了，而 NFKC 还会进行组合；</li>
</ul>
<p>大部分情况下，我们只需要使用 NFC 规范化即可，而 NFKD 在处理带圆圈的数字的时候也会使用。</p>
<p><strong><font color="blue">unicodedata.category</font></strong></p>
<p>该函数可以返回一个字符的类别，而类别有以下几种：</p>
<pre><code class="language-python">'Lu'：'大写字母（Letter, uppercase）'
'Ll'：'小写字母（Letter, lowercase）'
'Lt'：'标题大小写字母（Letter, titlecase）'
'Lm'：'修饰字母（Letter, modifier）'
'Lo'：'其他字母（Letter, other）'
'Mn'：'非间断标记（Mark, nonspacing）'
'Mc'：'间断标记（Mark, spacing combining）'
'Me'：'封闭标记（Mark, enclosing）'
'Nd'：'十进制数字（Number, decimal digit）'
'Nl'：'字母数字（Number, letter）'
'No'：'其他数字（Number, other）'
'Pc'：'连接符号（Punctuation, connector）'
'Pd'：'破折号符号（Punctuation, dash）'
'Ps'：'开放的标点符号（Punctuation, open）'
'Pe'：'关闭的标点符号（Punctuation, close）'
'Pi'：'初引号（Punctuation, initial quote）'
'Pf'：'末引号（Punctuation, final quote）'
'Po'：'其他标点符号（Punctuation, other）'
'Sm'：'数学符号（Symbol, math）'
'Sc'：'货币符号（Symbol, currency）'
'Sk'：'修饰符号（Symbol, modifier）'
'So'：'其他符号（Symbol, other）'
'Zs'：'空格符号（Separator, space）'
'Zl'：'分行符（Separator, line）'
'Zp'：'分段符（Separator, paragraph）'
'Cc'：'控制字符（Other, control）'
'Cf'：'格式字符（Other, format）'
'Cs'：'代理字符（Other, surrogate）'
'Co'：'私用字符（Other, private use）'
'Cn'：'未分配字符（Other, not assigned）'
</code></pre>
<p>举个例子：</p>
<pre><code class="language-python">import unicodedata

print(unicodedata.category('A'))  # Lu
print(unicodedata.category('a'))  # Ll
print(unicodedata.category('1'))  # Nd
print(unicodedata.category('$'))  # Sc
print(unicodedata.category(' '))  # Zs
</code></pre>
<p>'A' 是大写字母，所以它的类别是 'Lu'。'a' 是小写字母，所以它的类别是 'Ll'。'1' 是十进制数字，所以它的类别是 'Nd'。'$' 是货币符号，所以它的类别是 'Sc'。' ' 是空格符号，所以它的类别是 'Zs'。</p>
<p><strong><font color="blue">unicodedata.lookup</font></strong></p>
<p>有些 unicode 字符是有名字的，可以根据它的名字查找相应的字符。</p>
<pre><code class="language-python">import unicodedata

print(
    unicodedata.lookup(&quot;LATIN SMALL LETTER A&quot;),
    unicodedata.lookup(&quot;COPYRIGHT SIGN&quot;),
    unicodedata.lookup(&quot;PEACH&quot;),
)  # a © 🍑
</code></pre>
<p>如果给定的名字不是一个有效的 Unicode 字符名，那么会抛出 KeyError。</p>
<p><strong><font color="blue">unicodedata.name</font></strong></p>
<p>和 lookup 功能相反，负责返回字符的名称。</p>
<pre><code class="language-python">import unicodedata

print(unicodedata.name(&quot;z&quot;))  # LATIN SMALL LETTER Z
print(unicodedata.name(&quot;@&quot;))  # COMMERCIAL AT
print(unicodedata.name(&quot;🍑&quot;))  # PEACH
</code></pre>
<p>比较简单，如果字符没有名称，则抛出 ValueError，或者也可以指定一个默认值。</p>
<p><strong><font color="blue">unicodedata.numeric</font></strong></p>
<p>将 unicode 字符转成等效的数值，如果无法转换则返回默认值（没有则抛出 ValueError）。</p>
<pre><code class="language-python">import unicodedata

print(unicodedata.numeric(&quot;零&quot;))  # 0.0
print(unicodedata.numeric(&quot;〇&quot;))  # 0.0
print(unicodedata.numeric(&quot;一&quot;))  # 1.0
print(unicodedata.numeric(&quot;贰&quot;))  # 2.0
print(unicodedata.numeric(&quot;叁&quot;))  # 3.0
print(unicodedata.numeric(&quot;四&quot;))  # 4.0
print(unicodedata.numeric(&quot;伍&quot;))  # 5.0
print(unicodedata.numeric(&quot;⑥&quot;))  # 6.0
print(unicodedata.numeric(&quot;漆&quot;))  # 7.0
print(unicodedata.numeric(&quot;捌&quot;))  # 8.0
print(unicodedata.numeric(&quot;玖&quot;))  # 9.0
print(unicodedata.numeric(&quot;拾&quot;))  # 10.0


text = &quot;加 v́ 壹捌⑤壹零贰❤️捌⑥捌〇②，看 Python❤️&quot;

def chr_to_num(char):
    try:
        return str(unicodedata.numeric(char))[0]
    except ValueError:
        return char

print(
    &quot;&quot;.join(map(chr_to_num, text))
)  # 加 v́ 185102❤️86802，看 Python❤️
</code></pre>
<p>以上就是 unicodedata 模块的一些用法，当然还有几个函数没有说，个人觉得用不上。这里面最有用的应该就是 normalize 函数了，更多内容可以参考官网。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-14"><a class="header" href="#楔子-14">楔子</a></h2>
<p>Python 有一个内置模块 struct，从名字上看这和 C 的结构体有着千丝万缕的联系，C 的结构体是由多个数据组合而成的一种新的数据类型。</p>
<pre><code class="language-c">typedef struct {
    char *name;
    int age;
    char * gender;
    long salary;
} People;
</code></pre>
<p>struct 模块也是负责将多个不同类型的数据组合在一起，因为网络传输的数据都是二进制字节流。而 Python 只有字符串可以直接转成字节流，对于整数、浮点数则无能为力了。所以 Python 提供了 struct 模块来帮我们解决这一点，下面来看看它的用法。</p>
<h2 id="打包和解包"><a class="header" href="#打包和解包">打包和解包</a></h2>
<p>struct 模块内部有两个函数用于打包和解包，分别是 pack 和 unpack。</p>
<ul>
<li>pack：将数据打包成二进制字节流；</li>
<li>unpack：对二进制字节流进行解包；</li>
</ul>
<pre><code class="language-python">import binascii
import struct

# values 包含一个 12 字节的字节串、一个整数、以及一个浮点数。
values = (&quot;古明地觉&quot;.encode(&quot;utf-8&quot;), 17, 156.7)

# 第一个参数 &quot;12s i f&quot; 表示格式化字符串(format)，里面的符号则代表数据的类型
# 12s：12 个字节的字节串、i: 整数、f: 浮点数
# 因此 12s i f 表示打包的数据有三个，分别是：12 个字节的字节串、一个整数、以及一个浮点数
# 中间使用的空格只是用来对表示类型的符号进行分隔，在编译时会被忽略
packed_data = struct.pack(&quot;12s i f&quot;, *values)  # 这里需要使用 * 将元组打开

# 查看打印的结果
print(packed_data)
&quot;&quot;&quot;
b'\xe5\x8f\xa4\xe6\x98\x8e\xe5\x9c\xb0\xe8\xa7\x89\x11\x00\x00\x003\xb3\x1cC'
&quot;&quot;&quot;

# 还可以将打包后的结果转成十六进制, 这样传输起来更加方便
print(binascii.hexlify(packed_data))
&quot;&quot;&quot;
b'e58fa4e6988ee59cb0e8a7891100000033b31c43'
&quot;&quot;&quot;
</code></pre>
<p>代码中的 packed_data 就是打包之后的结果，而我们又将其转成了 16 进制表示。那么问题来了，既然能打包，那么肯定也能解包。</p>
<pre><code class="language-python">import struct
import binascii

# 之前对打包之后的数据转成 16 进制所得到的结果
data = b'e58fa4e6988ee59cb0e8a7891100000033b31c43'

# 所以可以使用 binascii.unhexlify 将其转回来，得到 struct 打包之后的数据
packed_data = binascii.unhexlify(data)

# 然后调用 struct.unpack 进行解包，打包用的什么格式，解包也用什么格式
# 会得到一个元组，哪怕解包之后只有一个元素，得到的也是元组
values = struct.unpack(&quot;12s i f&quot;, packed_data)
print(str(values[0], encoding=&quot;utf-8&quot;))  # 古明地觉
print(values[1])  # 17
print(values[2])  # 156.6999969482422
</code></pre>
<p>发送端将数据按照某种格式转成二进制字节流，接收端在接收到数据之后再按照相同的格式转成相应的数据就行。只不过 Python 中，只有字符串可以直接转换成二进制字节流，整数、浮点数则需要借助于 struct 模块。</p>
<p>但是注意：在使用 struct 打包的时候，不能直接对字符串打包，而是需要先将字符串编码成bytes对象。因为中文字符采用不同的编码所占的字节数不同，所以需要先手动编码成 bytes 对象。</p>
<p>整体还是比较简单的，就是将数据按照指定格式进行打包，然后再按照指定格式进行解包。而像 12s、i、f 这些都属于我们定义的格式中的类型指示符，而除了这些指示符之外，还有哪些类型指示符呢？</p>
<p><img src="%E4%BD%BF%E7%94%A8%20struct%20%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E3%80%81%E8%A7%A3%E5%8C%85%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE/./1.png" alt="" /></p>
<p>然后需要注意，我们在进行打包的时候，类型以及个数一定要匹配。</p>
<pre><code class="language-python">import struct

try:
    struct.pack(&quot;iii&quot;, 1, 2, 3.14)
except Exception as e:
    print(e)  # required argument is not an integer
# 告诉我们需要的是整数, 但我们传递了浮点数

try:
    # iii 表示接收 3 个整数, 但我们只传递了两个
    struct.pack(&quot;iii&quot;, 1, 2)
except Exception as e:
    print(e)  # pack expected 3 items for packing (got 2)

try:
    # iii 表示接收 3 个整数, 但我们却传递了四个
    struct.pack(&quot;iii&quot;, 1, 2, 3, 4)
except Exception as e:
    print(e)  # pack expected 3 items for packing (got 4)
</code></pre>
<p>此外，我们之前说一个长度为 12 的字节串，可以使用 12s 来表示，那么 3s 就表示长度为 3 的字节串。问题来了，i 表示整数，那么3i 表示什么呢？</p>
<pre><code class="language-python">import struct

try:
    struct.pack(&quot;3i&quot;, 1, 2)
except Exception as e:
    print(e)  # pack expected 3 items for packing (got 2)

# 告诉我们接收 3 个值, 但是只传递了两个
packed_data = struct.pack(&quot;3i&quot;, 1, 2, 3)
print(struct.unpack(&quot;3i&quot;, packed_data))  # (1, 2, 3)
</code></pre>
<p>我们看到 3i 在结果上等同于 iii，但对于 s 而言，3s 可不等同于 sss。3s 仍然表示接收一个元素，只不过这个元素是字节串，并且长度为 3。这些细节要注意。</p>
<p>当然对于字符串而言，即使长度不一样也是无所谓的，我们举个例子。</p>
<pre><code class="language-python">import struct

# 第一个值是整数, 第二个值是字节串(长度应该为3, 但不是3也可以)
packed_data = struct.pack(&quot;i3s&quot;, 6, b&quot;abcdefg&quot;)
print(packed_data)  # b'\x06\x00\x00\x00abc'
# 我们看到被截断了, 只剩下了 abc

packed_data = struct.pack(&quot;i6s&quot;, 6, b&quot;abc&quot;)
print(packed_data)  # b'\x06\x00\x00\x00abc\x00\x00\x00'
# 6s 需要字节长度为 6, 但是我们只有三个, 所以在结尾补上了 3 个 \0
</code></pre>
<p>总之在使用 struct 进行打包的时候，需要记住两点：</p>
<ul>
<li>元素个数和符号个数要对应, 比如 3i3s3f 表示接收 7 个元素，依次是 3 个整数、一个字节串、3 个浮点数；</li>
<li>元素类型和符号要对应，比如 i 对应整数，s 对应字节串等等；并且对于 s 而言，前面的数字表示接收的字节串的长度；</li>
</ul>
<p>而对于解包而言，我们也需要关注，但只需要关注一点，那就是大小。怎么理解呢？来举个例子：</p>
<pre><code class="language-python">import struct

packed_data = struct.pack(&quot;ii&quot;, 1, 2)
print(packed_data)  # b'\x01\x00\x00\x00\x02\x00\x00\x00'
# 因为 i 表示 C 的 int, 而 C 的一个 int 占 4 字节, 所以结果是 8 字节。
# 只不过 1 和 2 只需一字节即可存储, 因此其它的部分都是 0
# 打包之后的 packed_data 的大小, 不取决于打包的元素, 而是取决于格式化字符串中的类型符号
# 比如 struct.pack(&quot;4s&quot;, b&quot;abc&quot;) , 尽管传递的字节串只有 3 字节
# 但指定的是 4s, 所以打包之后的 packed_data 占 4 字节

# 而我们在解包的时候, 指定的符号的字节大小 和 packed_data 要匹配
# 比如这里的 packed_data 是 8 字节, 在打包结束之后它的大小就已经固定了
try:
    print(struct.unpack(&quot;i&quot;, packed_data))
except Exception as e:
    print(e)  # unpack requires a buffer of 4 bytes
# 告诉我们需要一个 4 字节的buffer, 这是因为我们的 packed_data 是 8 字节
# 同理:
try:
    print(struct.unpack(&quot;iii&quot;, packed_data))
except Exception as e:
    print(e)  # unpack requires a buffer of 12 bytes
# 这样也是不可以的, 告诉我们需要 12 字节

# 只有字节数匹配, 才可以正常解析
print(struct.unpack(&quot;ii&quot;, packed_data))  # (1, 2)
</code></pre>
<p>那么问题来了，我们说一个 long long 是占 8 字节，正好对应两个 int，那么将两个 int 按照一个 long long 来解析可不可以呢？再有 8s 也是 8 字节，又可不可以进行解析呢？我们来试一下。</p>
<pre><code class="language-python">import struct

packed_data = struct.pack(&quot;ii&quot;, 1, 2)
print(packed_data)
&quot;&quot;&quot;
b'\x01\x00\x00\x00\x02\x00\x00\x00'
&quot;&quot;&quot;

print(struct.unpack(&quot;8s&quot;, packed_data))
&quot;&quot;&quot;
(b'\x01\x00\x00\x00\x02\x00\x00\x00',)
&quot;&quot;&quot;
print(struct.unpack(&quot;q&quot;, packed_data))
&quot;&quot;&quot;
(8589934593,)
&quot;&quot;&quot;

# 答案显然是可以的, 因为字节数是相匹配的
# 对于 8s 而言, 我们看到解析出来的结果就是原始的字节流
# 对于 q, 也可以正确解析, 只不过结果不是我们想要的

# 但是我们观察一下按照 q 解析出来的结果, 结果是 8589934593, 那么它是怎么得到的呢?
# 如果将 packet_data 按照 8 字节整数解析，相当于将两个 4 字节整数合并成一个 8 字节整数
# 其中整数 2 占据前 32 个位，整数 1 占据后 32 个位
print((2 &lt;&lt; 32) + 1)
&quot;&quot;&quot;
8589934593
&quot;&quot;&quot;
# 怎么样, 结果是不是一样呢? 至于这里为什么不是 (1 &lt;&lt; 31) + 2, 我们后面会说
</code></pre>
<p>所以在解析的时候，格式化字符串中的类型符号对应的字节数，要和 packed_data 的字节数相匹配，这是不报错的前提。当然如果想得到正确的结果，最关键的还是解包对应的格式化字符串，要和打包对应的格式化字符串保持一致。</p>
<h2 id="structstruct"><a class="header" href="#structstruct">struct.Struct</a></h2>
<p>在 struct 模块中，我们可以直接使用 struct.pack 和 struct.unpack 这两个模块级的函数，但是 struct 模块还提供了一个 Struct 类。</p>
<pre><code class="language-python">import struct

s = struct.Struct(&quot;ii&quot;)
# 和使用 struct.pack(&quot;ii&quot;, 1, 2) 之间是等价的
packed_data = s.pack(1, 2) 
print(packed_data)  
&quot;&quot;&quot;
b'\x01\x00\x00\x00\x02\x00\x00\x00'
&quot;&quot;&quot;
</code></pre>
<p>如果我们需要使用同一种格式化字符串来对大量数据进行打包的话，那么使用 struct.Struct 是更推荐的，可以类比正则。</p>
<p>re.search(pattern, string) 这个过程分为两步，会先将 pattern 进行编译转换，然后再进行匹配。如果我们需要同一个 pattern 匹配 100 个字符串的话，那么要编译转换 100 次。</p>
<p>而如果先对 pattern 进行编译 comp = re.compile(pattern)，那么不管调用 comp.search(string) 多少次，都只会进行一次编译转换，效率会更高。struct 也是类似的，如果要按照相同的格式进行多次打包，那么创建一个 Struct 实例并在这个实例上调用方法时（不使用模块级函数）会更高效。</p>
<p>当然，使用 Struct 类还有一个好处，就是可以获取一些额外信息。</p>
<pre><code class="language-python">import struct

s = struct.Struct(&quot;ii4sf&quot;)
print(&quot;格式化字符串:&quot;, s.format)  # 格式化字符串: ii4sf
print(&quot;字节数:&quot;, s.size)  # 字节数: 16
</code></pre>
<p>我们看到打包后的数据大小是由格式化字符串中的符号所决定的。</p>
<h2 id="字节序"><a class="header" href="#字节序">字节序</a></h2>
<p>说到字节序，你应该会想到大端存储、小端存储，所谓大端存储就是：数据的低位存储在内存的高地址中，高位存储在内存的低地址中。而小端存储与之相反：数据的低位存储在内存的低地址中，高位存储在内存的高地址中。</p>
<p>那么 Python 的 struct 默认使用什么存储呢？答案是小端存储。</p>
<pre><code class="language-python">import struct

# i 表示 int32，那么相应的整数 1 就占 4 字节
# 其中最低位存储的是 1，剩余三个位存储的是 0
packed_data = struct.pack(&quot;i&quot;, 1)
print(packed_data)  # b'\x01\x00\x00\x00'
# 打包之后的数据是一个字节串，或者理解为 C 的字符数组
# 而数组的元素，从左往右对应的内存地址是依次增大的
# 所以结果就是低位存在了低地址中，所以这里是小端存储

# 而如果想要变成大端存储的话, 可以这么做
packed_data = struct.pack(&quot;&gt;i&quot;, 1)
print(packed_data)  # b'\x00\x00\x00\x01'
# 我们看到此时结果就变了
</code></pre>
<p>当然我们在解析的时候也需要注意大小端的问题，如果是打包的时候使用的是大端存储，那么解包的时候也要使用大端存储。</p>
<pre><code class="language-python">import struct

# 因为 \x01 在最后面，而后面表示内存的高地址
# 此时这个数字如果想表示 1, 那么它一定是大端存储的 1
# 也就是将低位的 \x01 放在了高地址中
packed_data = b'\x00\x00\x00\x01'

# 这里我们不指定大小端, 默认是小端
print(struct.unpack(&quot;i&quot;, packed_data))
&quot;&quot;&quot;
(16777216,)
&quot;&quot;&quot;
# 我们看到结果变了, 至于这个结果怎么来的, 很简单
# 无论打包还是解包，如果不指定字节序，那么默认都是小端，低位存在低地址中
# 所以 b'\x00\x00\x00\x01' 等价于如下
print(0b00000001_00000000_00000000_00000000) 
&quot;&quot;&quot;
16777216
&quot;&quot;&quot;

# 所以我们也要用大端存储进行解析, 表示: 我是大端存储, 存储在高地址的是数据的低位
print(struct.unpack(&quot;&gt;i&quot;, packed_data)) 
&quot;&quot;&quot;
(1,)
&quot;&quot;&quot;
print(0b00000000_00000000_00000000_00000001)  
&quot;&quot;&quot;
1
&quot;&quot;&quot;
# 所以通过 b'\x00\x00\x00\x01' 的值是不是 1，可以判断当前采用的是大端还是小端
# 因为 \x01 在高地址，如果值为 1，说明 \x01 是低位，因此是大端，否则小端
</code></pre>
<p>然后再回顾一下之前的例子，我们用一个 long long 表示两个 int。</p>
<pre><code class="language-python">import struct

packed_data = struct.pack(&quot;ii&quot;, 1, 2)
print(packed_data)
&quot;&quot;&quot;
b'\x01\x00\x00\x00\x02\x00\x00\x00'
&quot;&quot;&quot;

# 将两个 int 转成一个 long long，默认是小端，所以低位存在低地址中
# 因此 \x01\x00\x00\x00 表示 1，占据低 32 个位
# \x02\x00\x00\x00 表示 2，占据高 32 个位
print(struct.unpack(&quot;q&quot;, packed_data))
print((2 &lt;&lt; 32) + 1)
&quot;&quot;&quot;
(8589934593,)
8589934593
&quot;&quot;&quot;

# 如果按照大端解析的话，低位存在高地址中，那么就是相反的
# 但此时 \x01\x00\x00\x00 表示的不再是 1
# 同理 \x02\x00\x00\x00 表示也不再是 2
print(struct.unpack(&quot;&gt;q&quot;, packed_data))
print(
    (0b00000001_00000000_00000000_00000000 &lt;&lt; 32) +
    0b00000010_00000000_00000000_00000000
)
&quot;&quot;&quot;
(72057594071482368,)
72057594071482368
&quot;&quot;&quot;
</code></pre>
<p>因此 struct 模块给我们提供了自定义字节序的功能，可以显式地指定是使用大端存储、还是小端存储。而方法也很简单，只需要给格式化字符串的第一个字符指定为特定的符号即可实现这一点。</p>
<ul>
<li><code>&gt;</code> : 大端字节序（Big-endian）</li>
<li><code>&lt;</code> : 小端字节序（Little-endian）</li>
<li><code>!</code> : 网络字节序（实际上就是大端字节序）</li>
<li><code>=</code> : 本地字节序（当前系统的字节序）</li>
<li><code>@</code> : 本地字节序（和 <code>=</code> 相同，但可能有不同的对齐方式）</li>
</ul>
<h2 id="缓冲区"><a class="header" href="#缓冲区">缓冲区</a></h2>
<p>pack 方法在打包的时候，会为打包数据申请一块内存空间，也就是说每一次 pack 都需要申请内存资源，显然这是一种浪费。通过避免为每个打包数据分配一个新缓冲区，在内存开销上可以得到优化。而 pack_into 和 pack_from 可以支持我们从指定的缓冲区进行读取和写入。</p>
<pre><code class="language-python">import struct
import ctypes

# 创建一个 string 缓存, 大小为 10
buf = ctypes.create_string_buffer(10)
# raw 表示原始数据，这里都是 \0，因为 C 中是通过 \0 来标识一个字符串的结束
print(buf.raw)  # b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
# value 就是 Python 中的字符串, 显然为空
print(buf.value)  # b''

# 然后我们进行打包, 第二个参数表示缓冲区
# 第三个参数表示偏移量, 0表示从头开始写入; 然后后面的参数就是打包的数据
struct.pack_into(&quot;ii2s&quot;, buf, 0, 123, 345, b&quot;ab&quot;)

# 打包之后的数据会存在 buf 中，解包的话，使用 unpack_from
# 会从 buf 中读取数据并解析，第三个参数表示从偏移量为 0 的位置开始解析
values = struct.unpack_from(&quot;ii2s&quot;, buf, 0)
print(values)  # (123, 345, b'ab')
</code></pre>
<p>这里的 pack_into 不会产生新的内存空间，都是对 buf 进行操作。另外我们还看到了偏移量，所以可以将多个打包的数据写入到同一个 buf 中，然后也可以从同一个 buf 中进行解包，而保证数据不冲突的前提正是这里的偏移量，举个栗子：</p>
<pre><code class="language-python">import struct
import ctypes

s1 = struct.Struct(&quot;ii6si&quot;)
s2 = struct.Struct(&quot;2s&quot;)
buf = ctypes.create_string_buffer(s1.size + s2.size)
s1.pack_into(buf, 0, 1, 2, b&quot;abcdef&quot;, 3)
# 偏移量为 s1.size
s2.pack_into(buf, s1.size, b&quot;gh&quot;)

# 从 si.size 开始解析
print(s2.unpack_from(buf, s1.size))  # (b'gh',)
# 从 0 开始解析，解析 s1.size 个字节
print(s1.unpack_from(buf, 0))  # (1, 2, b'abcdef', 3)
</code></pre>
<p>以上就是 struct 模块，它定义了Python中整数、浮点数和二进制流之间的通用转换逻辑。</p>
<div style="break-before: page; page-break-before: always;"></div><p>在工作中难免会碰到这样的需求，监控指定目录，如果该目录下发生文件变更，那么进行一系列的处理。而如何监视一个目录，就是我们本次探讨的主题。</p>
<p>监视目录可以使用 watchfiles 模块，该模块不仅简单，而且性能也不错。主要原因是，和底层文件系统交互的代码是基于 Rust 编写的，所以性能是有保证的。通过 pip install watchfiles 安装之后，我们来看看它的用法。</p>
<pre><code class="language-python">from watchfiles import watch

# 当前目录为 /Users/satori/Desktop/project
for change in watch(&quot;.&quot;):
    print(change)
</code></pre>
<p>执行此程序，会处于阻塞状态，并持续监听指定目录的变化。然后我们在当前目录创建几个文件，看看效果。</p>
<p><font color="blue">创建一个 data.txt 文本文件，程序输出如下：</font></p>
<pre><code class="language-python">{(&lt;Change.added: 1&gt;, '/Users/satori/Desktop/project/data.txt')}
</code></pre>
<p>返回的是一个集合，目前只涉及一个文件的变更，所以集合里面只有一个元素。然后集合里面存储的都是元组，元组的第一个元素表示操作类型，总共有三种：分别是增加、修改和删除。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20watchfiles%20%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E5%8F%98%E6%9B%B4/./1.png" alt="" /></p>
<p>元组的第二个参数就是具体的文件路径，因此程序的输出就告诉我们，当前目录新增了一个 data.txt。</p>
<p><font color="blue">再创建一个 txt_files 目录，程序输出如下：</font></p>
<pre><code class="language-python">{(&lt;Change.added: 1&gt;, '/Users/satori/Desktop/project/txt_files')}
</code></pre>
<p>不管是目录文件还是文本文件，都属于文件，所以输出是一样的。如果想知道新增的到底是目录还是普通文件，那么还需要通过 os 模块检测一下。</p>
<p><font color="blue">然后在 txt_files 目录中创建一个 data.txt，程序输出如下：</font></p>
<pre><code class="language-python">{(&lt;Change.added: 1&gt;, '/Users/satori/Desktop/project/txt_files/data.txt')}
</code></pre>
<p>所以 watch 函数监听的不仅是指定目录，其内部的递归子目录也会一并监听。</p>
<p>问题来了，当前目录下存在一个 data.txt 文件和一个 txt_files 目录，而 txt_files 目录也存在一个 data.txt。那么如果将当前目录的 data.txt 移动到 txt_files 中，并同意覆盖，那么程序会输出什么呢？</p>
<pre><code class="language-python">{(&lt;Change.deleted: 3&gt;, '/Users/satori/Desktop/project/txt_files/data.txt'), 
 (&lt;Change.added: 1&gt;, '/Users/satori/Desktop/project/txt_files/data.txt'), 
 (&lt;Change.deleted: 3&gt;, '/Users/satori/Desktop/project/data.txt')}
</code></pre>
<p>此时输出的集合包含三个元组，因此该过程涉及到三次文件的变更。因为 txt_files 里面的文件被替换掉了，所以相当于先被删除、然后重新创建。而当前目录中的 data.txt 被移走了，因此相当于被删除了。</p>
<p><font color="blue">然后我们再通过 mkdir -p a/b/c 同时创建多级目录，程序输出如下：</font></p>
<pre><code class="language-python">{(&lt;Change.added: 1&gt;, '/Users/satori/Desktop/project/a/b/c'), 
 (&lt;Change.added: 1&gt;, '/Users/satori/Desktop/project/a/b'), 
 (&lt;Change.added: 1&gt;, '/Users/satori/Desktop/project/a')}
</code></pre>
<p>整个过程还是比较简单的，然后除了 watch 函数之外，还有一个 awatch。这两者的作用是一样的，参数也全部一样，只不过 awatch 需要和协程搭配，我们举个例子。</p>
<pre><code class="language-python">import sys
import asyncio
from asyncio import StreamReader
from watchfiles import awatch, Change

# 监视指定目录
async def watch_files(path):
    # awatch(...) 返回的是异步生成器，需要通过 async for 遍历
    async for change in awatch(path):
        print(&quot;-&quot; * 20)
        # change 是一个集合，里面可能会涉及到多个文件的变更
        for item in change:
            if item[0] == Change.added:
                operation = &quot;你增加了&quot;
            elif item[0] == Change.modified:
                operation = &quot;你修改了&quot;
            else:
                operation = &quot;你删除了&quot;
            print(f&quot;{operation} `{item[1]}`&quot;)
        print(&quot;\n&quot;)

# 读取命令行输入，但是注意：不可以使用 input 函数，因为它是同步阻塞调用
# 这种调用在协程当中是大忌，会阻塞整个线程，我们需要改造成异步模式
async def read_from_stdin():
    reader = asyncio.StreamReader()
    protocol = asyncio.StreamReaderProtocol(reader)
    loop = asyncio.get_running_loop()
    await loop.connect_read_pipe(lambda: protocol, sys.stdin)
    return reader

# read_from_stdin 函数的具体细节暂时不用太关注，只需要知道它能异步读取命令行即可
# 然后定义主协程
async def main():
    # 监视当前目录
    asyncio.create_task(watch_files(&quot;.&quot;))
    # 创建读取器
    stdin_reader = await read_from_stdin()
    while True:
        # 从命令行读取输入
        command = await stdin_reader.readline()
        # 执行命令
        procs = await asyncio.create_subprocess_shell(command)
        await procs.wait()

loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main())
finally:
    loop.close()
</code></pre>
<p>来看一下效果：</p>
<p><img src="%E4%BD%BF%E7%94%A8%20watchfiles%20%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E5%8F%98%E6%9B%B4/./2.png" alt="" /></p>
<p>结果没有问题，文件的变化都检测出来了。然后补充一点：watch 和 awatch 可以同时监听多个目录，因为第一个参数是 *paths。</p>
<p>我们同时监听多个目录来测试一下，先在当前目录创建两个子目录：boy 和 girl，然后分别监视它们。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20watchfiles%20%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E5%8F%98%E6%9B%B4/./3.png" alt="" /></p>
<p>输出正常，因此这两个函数可以监听任意多个目录。另外，由于目前监听的是当前目录的两个子目录，所以当前目录的文件变更就看不到了，因为它没有被监视。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20watchfiles%20%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E5%8F%98%E6%9B%B4/./4.png" alt="" /></p>
<p>以上就是这两个函数的基本用法，当然这两个函数还有其它参数：</p>
<p><img src="%E4%BD%BF%E7%94%A8%20watchfiles%20%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E5%8F%98%E6%9B%B4/./5.png" alt="" /></p>
<p>这里简单介绍几个。</p>
<p><strong><font color="darkblue">过滤器（watch_filter）</font></strong></p>
<p>watchfiles 会监视目录的文件变化，但不是所有的文件都会记录。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20watchfiles%20%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7%E7%9B%AE%E5%BD%95%E5%8F%98%E6%9B%B4/./6.png" alt="" /></p>
<p>watchfiles 有一个内置的过滤器，会将和业务无关的文件过滤掉，如果你还希望将其它格式的文件过滤掉，那么修改过滤器即可。</p>
<p><strong><font color="darkblue">停止事件（stop_event）</font></strong></p>
<p>监视文件的时候，迭代器是不会停止的，如果想自由控制它的结束，可以传递一个事件。</p>
<pre><code class="language-python">import asyncio
from watchfiles import awatch

async def watch_files(*paths, stop_event):
    async for _ in awatch(*paths, stop_event=stop_event):
        pass
    print(&quot;停止监视&quot;)

async def main():
    event = asyncio.Event()
    # 传递一个事件，准确的说，只要有 is_set 方法，任何对象都行
    asyncio.create_task(watch_files(&quot;.&quot;, stop_event=event))
    # 当 event.is_set() 为 True 的时候，停止监视
    print(&quot;is_set: &quot;, event.is_set())
    await asyncio.sleep(3)  # sleep 3
    event.set()
    print(&quot;三秒后, is_set: &quot;, event.is_set())
    # 等待子协程打印完毕
    await asyncio.sleep(0.1)

asyncio.run(main())
&quot;&quot;&quot;
is_set:  False
三秒后, is_set:  True
停止监视
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">是否递归监视（recursive）</font></strong></p>
<p>如果该参数为 True，那么会递归监视子目录，否则只监视顶层目录。</p>
<p>其它参数基本很少用，就不再赘述了，有兴趣可以自己了解一下。</p>
<div style="break-before: page; page-break-before: always;"></div><p>现如今的智能手机在拍摄照片时，都含有 Exif（可交换图像文件格式，Exchangeable image file format）信息，通过该信息可以获取拍照时的位置、时间，以及手机品牌等信息。那么下面就看看如何使用 Python 去获取这些信息吧。</p>
<p>Python 想要读取 Exif 信息需要安装一个第三方库，直接 pip install exifread 即可。</p>
<pre><code class="language-python">import exifread

with open(&quot;1.jpg&quot;, 'rb') as f:
    # 直接可以拿到里面的信息，内容非常多
    # 但如果无法读取，那么返回值 exif 就是 None
    exif = exifread.process_file(f)

# 这里我们选一些常用的，里面的 value 需要转成字符串
# 不转成字符串的话看起来会比较费劲
print(&quot;图片宽度:&quot;, str(exif[&quot;Image ImageWidth&quot;]))
print(&quot;图片高度:&quot;, str(exif[&quot;Image ImageLength&quot;]))
print(&quot;手机品牌:&quot;, str(exif[&quot;Image Make&quot;]))
print(&quot;手机型号:&quot;, str(exif[&quot;Image Model&quot;]))
print(&quot;拍摄时间:&quot;, str(exif[&quot;Image DateTime&quot;]))
print(&quot;经度:&quot;, str(exif[&quot;GPS GPSLongitude&quot;]))
print(&quot;东经还是西经:&quot;, str(exif[&quot;GPS GPSLongitudeRef&quot;]))
print(&quot;纬度:&quot;, str(exif[&quot;GPS GPSLatitude&quot;]))
print(&quot;南纬还是北纬:&quot;, str(exif[&quot;GPS GPSLatitudeRef&quot;]))
&quot;&quot;&quot;
图片宽度: 3968
图片高度: 2976
手机品牌: HUAWEI
手机型号: EML-AL00
拍摄时间: 2021:07:08 19:52:23
经度: [116, 28, 5973999/100000]
东经还是西经: E
纬度: [39, 59, 1255371/200000]
南纬还是北纬: N
&quot;&quot;&quot;
</code></pre>
<p>还是比较简单的，但是里面的经度和纬度比较怪，我们还需要再对其转化一下。</p>
<pre><code class="language-python">lng = str(exif[&quot;GPS GPSLongitude&quot;])  # 经度
lat = str(exif[&quot;GPS GPSLatitude&quot;])  # 纬度
print(lng)  # [116, 28, 5973999/100000]
print(lat)  # [39, 59, 1255371/200000]

# 转成列表
lng = lng[1: -1].replace(&quot;/&quot;, &quot;,&quot;).split(&quot;,&quot;)
lat = lat[1: -1].replace(&quot;/&quot;, &quot;,&quot;).split(&quot;,&quot;)
print(lat)  # ['39', ' 59', ' 1255371', '200000']
print(lng)  # ['116', ' 28', ' 5973999', '100000']

# 然后得到具体的经纬度
lng = float(lng[0]) + float(lng[1]) / 60 + float(lng[2]) / float(lng[3]) / 3600
lat = float(lat[0]) + float(lat[1]) / 60 + float(lat[2]) / float(lat[3]) / 3600
print(lng)  # 116.48326110833334
print(lat)  # 39.98507690416667
</code></pre>
<p>这里得到的经纬度永远是正数，如果是西经，那么得到的经度要乘上 -1；同理如果是南纬，那么纬度要乘上 -1。</p>
<p>另外需要注意，并非所有的照片都能够进行解析，必须是携带 Exif 信息的原始图片。如果中间进行了压缩、或者 P 图，那么就无法识别了。</p>
<p>当然像一些社交平台也会专门针对 Exif 进行处理，比如微信，你发在朋友圈的图片会自动压缩，所以是不会暴露位置信息的。</p>
<div style="break-before: page; page-break-before: always;"></div><p>相信大家在做爬虫的时候，都有过被反爬的经历，一旦网站识别是爬虫，就会拒绝请求。反爬机制有很多，最常见的便是通过请求头里的 User-Agent，举个例子。</p>
<pre><code class="language-python">import requests
import httpx

response = requests.get(&quot;http://www.baidu.com&quot;)
print(response.request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
python-requests/2.28.0
&quot;&quot;&quot;

response = httpx.get(&quot;http://www.baidu.com&quot;)
print(response.request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
python-httpx/0.23.3
&quot;&quot;&quot;
</code></pre>
<p>如果 User-Agent 不符合浏览器的格式，那么一定不是浏览器发出的，于是网站便可认定这属于爬虫。当然通过 User-Agent 识别属于最低级的方式，因为爬虫可以伪造自己的 User-Agent。</p>
<pre><code class="language-python">import requests
import httpx

response = requests.get(&quot;http://www.baidu.com&quot;,
                        headers={&quot;User-Agent&quot;: &quot;Chrome User-Agent&quot;})
print(response.request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
Chrome User-Agent
&quot;&quot;&quot;

response = httpx.get(&quot;http://www.baidu.com&quot;,
                     headers={&quot;User-Agent&quot;: &quot;IE User-Agent&quot;})
print(response.request.headers[&quot;User-Agent&quot;])
&quot;&quot;&quot;
IE User-Agent
&quot;&quot;&quot;
</code></pre>
<p>除了 User-Agent 之外，还可以通过请求头中的 Refer 字段判断是否为爬虫。比如你在 A 页面点击某个标签跳转到 B 页面，那么 Refer 就是 A 页面的地址。如果你直接访问的 B 页面，那么 Refer 就是空。如果 B 页面必须通过点击 A 页面的标签才能跳转，那么网站便可以通过 Refer 来判断是否为爬虫。</p>
<p>当然啦，反爬机制还有很多，不同网站使用的策略不一样。但现在大部分的网站都使用了 HTTPS，在建立 HTTPS 连接的时候要先进行 TLS 握手，在握手的过程中会协商加密算法、交换密钥和验证双方的身份。而将 TLS 握手产生的信息收集起来，并使用 JA3 算法生成一个哈希值，便得到了 TLS 指纹，基于该指纹可以标识、分类和跟踪使用特定 TLS 配置的客户端。</p>
<p>因此通过 JA3 哈希生成指纹便可以确定哪些是恶意流量，从而将其拒绝掉。换句话说，通过 TLS 指纹可以识别哪些是浏览器发出的正常请求，哪些是爬虫。</p>
<p>那么 TLS 指纹如何查看呢？可以通过以下几个网站。</p>
<blockquote>
<p>https://tls.browserleaks.com/json </p>
<p>https://tls.peet.ws/ </p>
<p>https://kawayiyi.com/tls</p>
</blockquote>
<p><img src="%E6%A8%A1%E6%8B%9F%20TLS%20%E6%8C%87%E7%BA%B9%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%8F%8D%E7%88%AC/./1.png" alt="" /></p>
<p>这是我基于浏览器访问的，它的字段都不是空。但如果使用爬虫，那么多次请求时的 ja3_hash 是不变的，并且 akamai_hash 和 akamai_text 均是空，基于该特征很容易识别是不是爬虫。即使我们更换代理，设置请求头，也无法改变这一点。</p>
<p>于是为了完美模拟浏览器，国外大佬开发出了 curl-impersonate，将 curl 底层依赖的库全部换成了浏览器使用的库，并且版本也是一致的，这样生成的指纹就和浏览器完全一样了。而 curl_cffi 正是 curl-impersonate 的 Python binding，我们直接使用 pip 安装即可。</p>
<pre><code class="language-python"># 和 requests 接口是一致的
from curl_cffi import requests

# 但是多了一个 impersonate 参数，用于指定模拟哪个浏览器
response = requests.get(&quot;https://tls.browserleaks.com/json&quot;,
                        impersonate=&quot;chrome101&quot;)

print(response.json())
&quot;&quot;&quot;
{'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36...', 
 'ja3_hash': 'cd08e31494f9531f560d64c695473da9', 
 'ja3_text': '771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-491...', 
 'ja3n_hash': 'aa56c057ad164ec4fdcb7a5a283be9fc', 
 'ja3n_text': '771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-491...', 
 'ja4': 't13d1516h2_8daaf6152771_e5627efa2ab1', 
 'ja4_r': 't13d1516h2_002f,0035,009c,009d,1301,1302,1303,c013,c014,c02b,c02c,c02f...', 
 'ja4_o': 't13d1516h2_acb858a92679_2d79a7d73c2f', 
 'ja4_ro': 't13d1516h2_1301,1302,1303,c02b,c02f,c02c,c030,cca9,cca8,c013,c014,009c...', 
 'akamai_hash': '4f04edce68a7ecbe689edce7bf5f23f3', 
 'akamai_text': '1:65536;3:1000;4:6291456;6:262144|15663105|0|m,a,s,p'}
&quot;&quot;&quot;

# 当然也可以先创建 session
session = requests.Session()
# 然后基于 session 发请求
</code></pre>
<p>总共支持如下版本的浏览器：</p>
<p><img src="%E6%A8%A1%E6%8B%9F%20TLS%20%E6%8C%87%E7%BA%B9%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%8F%8D%E7%88%AC/./2.png" alt="" /></p>
<p>我们选择 chrome110 即可，然后 curl_cffi 还支持异步发请求，可以和 asyncio 轻松集成。</p>
<pre><code class="language-python">import asyncio
from curl_cffi import requests

async def send_req():
    async with requests.AsyncSession() as session:
        response = await session.get(
            &quot;https://tls.browserleaks.com/json&quot;,
            impersonate=&quot;chrome101&quot;
        )
    print(response.json())
    
asyncio.run(send_req())
</code></pre>
<p>由于指纹特征很难更改，因此通过指纹可以防御一大批爬虫，而通过 curl_cffi 模拟指纹则可以绕过这道防线。</p>
<div style="break-before: page; page-break-before: always;"></div><p>什么是词云？在网络上我们经常可以看到一张图片，上面有一大堆大小不一的文字，这便是词云。词云一般是根据输入的大量词语生成的，如果某个词语出现的次数越多，那么相应的大小就会越大。</p>
<p>Python 中有一个专门用来生成词云的模块：wordcloud，直接 pip 安装即可，然后我们来看看它的用法。</p>
<pre><code class="language-python"># 导入模块
from wordcloud import WordCloud
# 准备文本数据，是一个字符串，单词之间用空格分隔
sentence = &quot;hello satori hello mashiro hello satori&quot;
# 创建词云对象
wc = WordCloud()
# 根据文本生成词云
wc.generate(sentence)
# 保存为图片
wc.to_file(&quot;word.png&quot;)
</code></pre>
<p>打开图片看看效果：</p>
<p><img src="%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/./1.png" alt="" /></p>
<p>我们看到单词就显示在了图片上，如果单词一多就像天空的云彩一样漂浮着，并且单词出现的频率越高，那么该单词在图片上大小就越大。</p>
<p>虽然词云生成了，但是风格是固定的，我们可不可以调整呢，显然是可以的。WordCloud 里面支持很多参数用来调整风格，我们看一下这些参数。</p>
<ul>
<li>width：词云的宽，默认是400像素；</li>
<li>height：词云的高，默认是200像素；</li>
<li>background_color：词云的背景颜色，默认是黑色；</li>
<li>font_path：生成的词云所使用的字体，传入一个字体名称；</li>
<li>mask：词云背景图片，接收一个 Numpy 数组。可以使用 PIL 或者 cv2 读取图片，然后生成数组；</li>
<li>stopwords：要屏蔽的词语，接收一个集合，生成词云的时候会忽略掉屏蔽的词语；</li>
<li>max_font_size：字体的最大大小，默认为 None；</li>
<li>min_font_size：字体的最小大小，默认为 None；</li>
<li>max_words：最多显示多少个单词，默认为200。比如文本数据有 10000 个不重复单词，肯定不可能全部显示，而是按照出现的频率高低排序，选择出现频率最高的 N 个单词，默认是 200 个；</li>
<li>contour_width：轮廓粗细；</li>
<li>contour_color：轮廓颜色；</li>
<li>scale：用来控制生成的图片大小，默认为 1。如果我们改成了 10，那么生成的图片大小会扩大 10 倍。这个参数不用管，没太大用，默认为 1 即可；</li>
</ul>
<p>我们举例说明：</p>
<pre><code class="language-python">from wordcloud import WordCloud
sentence = &quot;i do not need sex, because life fucks me every every single day&quot;
wc = WordCloud(
    width=500,  # 设置宽度为500px
    height=300,  # 设置高度为300px
    background_color='pink',  # 设置背景为粉色
    stopwords={&quot;sex&quot;, &quot;fucks&quot;},  # 设置禁用词
    max_font_size=100,  # 设置最大的字体大小，所有词都不会超过 100px
    min_font_size=10,  # 设置最小的字体大小，所有词都会超过 10px
    max_words=10  # 最多生成 10 个词，当然这里单词比较少，看不出来什么
)

wc.generate(sentence)
wc.to_file(&quot;word.png&quot;)
</code></pre>
<p>看看生成的图片：</p>
<p><img src="%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/./2.png" alt="" /></p>
<p>可以看到图片变宽了、变高了，背景变成粉色了，并且也没有出现禁用词。但这个图片是正方形的，而我们平常见到的词云是有形状的，比如一个圆形、或者一个人的形状等等。显然这是根据图片生成的，而 wordcloud 也支持这么做，下面来演示一下。</p>
<pre><code class="language-python">from wordcloud import WordCloud
from PIL import Image
import numpy as np

# 一篇英文文章
with open(&quot;article.txt&quot;) as f:
    sentence = f.read()
# 加载一张图片，转化成numpy中的数组
mask = np.array(Image.open(&quot;哆啦A梦.png&quot;))
# 传入mask
wc = WordCloud(mask=mask)
wc.generate(sentence)
wc.to_file(&quot;word.png&quot;)
</code></pre>
<p>看一下生成的结果：</p>
<p><img src="%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/./3.png" alt="" /></p>
<p>下面是原始的图片，&quot;多啦A梦.png&quot;</p>
<p><img src="%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/./4.png" alt="" /></p>
<p>会自动将周围的白色区域给忽略掉，因此选择的图片建议最好是白底的。</p>
<p>然后目前生成词云所使用的单词都是英文的，那中文可不可以呢？我们来看一下。</p>
<pre><code class="language-python">from wordcloud import WordCloud

wc = WordCloud()
wc.generate(&quot;古明地觉的编程教室&quot;)
wc.to_file(&quot;word.png&quot;)
</code></pre>
<p>生成的结果如下：</p>
<p><img src="%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/./5.png" alt="" /></p>
<p>显然默认是不支持中文的，此时我们需要指定一个中文字体。</p>
<pre><code class="language-python">from wordcloud import WordCloud

# 传入本机支持中文的字体名称
wc = WordCloud(font_path=&quot;Arial Unicode.ttf&quot;)
wc.generate(&quot;古明地觉的编程教室&quot;)
wc.to_file(&quot;word.png&quot;)
</code></pre>
<p>看看效果：</p>
<p><img src="%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/./6.png" alt="" /></p>
<p>中文正常显示了，但显示的是一整句话。因为 wordcloud 默认是以空格分隔单词的，所以对于英文我们不需要做什么处理，因为英文单词之间就是以空格分隔的。但中文则是所有的汉字都连在一起，因此整体被当成了一个词。</p>
<p>这个时候推荐使用 jieba 分词，将单词进行分隔。</p>
<pre><code class="language-python">from wordcloud import WordCloud
import jieba

with open(&quot;出师表.txt&quot;) as f:
    sentence = f.read()
# 分词得到列表，手动使用空格拼接
sentence = &quot; &quot;.join(jieba.cut(sentence))
wc = WordCloud(font_path=&quot;Arial Unicode.ttf&quot;)
wc.generate(sentence)
wc.to_file(&quot;word.png&quot;)
</code></pre>
<p>我们基于出师表的内容生成词云：</p>
<p><img src="%E7%94%9F%E6%88%90%E8%AF%8D%E4%BA%91/./7.png" alt="" /></p>
<p>结果没有问题，当然这里图片有点小了，你也可以调整它的宽高。</p>
<p>另外我们一直都是将词云保存成图片，除了图片，还可以保存成其它格式。</p>
<pre><code class="language-python">from io import BytesIO
from wordcloud import WordCloud
import jieba

with open(&quot;出师表.txt&quot;) as f:
    sentence = f.read()

sentence = &quot; &quot;.join(jieba.cut(sentence))
wc = WordCloud(font_path=&quot;Arial Unicode.ttf&quot;)
wc.generate(sentence)

# 将词云保存为 PIL 的 Image 对象
im = wc.to_image()
buf = BytesIO()
# 将词云的字节流保存在 buf 中，这样可以直接交给客户端进行渲染
im.save(buf, &quot;png&quot;)
print(buf.getvalue())

# 当然也可以保存为文件，im.save(filename)
# wc.to_file() 底层也是先转成 Image 对象、然后调用 im.save() 实现的

# 或者还可以保存为 SVG 格式
svg = wc.to_svg()
# 将 svg 的内容保存成文件，就得到 SVG 图片了
print(svg)
</code></pre>
<p>以上就是 Python 中词云生成相关的内容，快来试试吧。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="dbm"><a class="header" href="#dbm">dbm</a></h2>
<p>DBM（DataBase Manager）是一种文件系统，专门用于键值对的存储，最初是在 Unix 平台实现，现在其它平台也可以用。对于 KV 模型，DBM 提供了一个轻量级、高效的存储解决方案。</p>
<p>总的来说，DBM 具有如下特点：</p>
<ul>
<li>简单快速：非常简单易用，读取和写入操作都很快，适合存储少量数据。</li>
<li>键值对存储：数据是以键值对形式存储的，你可以像操作 Python 字典一样。</li>
<li>文件存储：数据存在具体的文件中，可以轻松地备份和转移。</li>
<li>不支持复杂查询：如果需要执行复杂查询或需要关系型数据库的功能，DBM 可能不是一个好选择。</li>
</ul>
<p>而 Python 标准库提供了一个 dbm 模块，它实现了 DBM 文件系统的功能，来看一下它的用法。</p>
<pre><code class="language-python">import dbm

# 第一个参数是文件名
# 第二个参数是模式，有以下几种
#     r：只读，要求文件必须存在，默认就是这个模式
#     w：可读可写，要求文件必须存在
#     c：可读可写，文件不存在会创建，存在则追加
#     n：可读可写，文件不存在会创建，存在则清空
# 第三个参数是权限，用八进制数字表示，默认 0o666，即可读可写不可执行
db = dbm.open(&quot;store&quot;, &quot;c&quot;)

# 打开文件就可以存储值了，key 和 value 必须是字符串或 bytes 对象
db[&quot;name&quot;] = &quot;S せんせい&quot;
db[&quot;age&quot;] = &quot;18&quot;
db[b&quot;corporation&quot;] = &quot;小摩&quot;.encode(&quot;utf-8&quot;)

# 关闭文件，将内容写到磁盘上
db.close()
</code></pre>
<p>非常简单，就像操作字典一样，并且 key 是唯一的，如果存在则替换。执行完后，当前目录会多出一个 store.db 文件。我们打开它，然后读取刚才写入的键值对。</p>
<pre><code class="language-python">import dbm

db = dbm.open(&quot;store&quot;, &quot;c&quot;)

# 获取所有的 key，直接返回一个列表
print(db.keys())
&quot;&quot;&quot;
[b'corporation', b'name', b'age']
&quot;&quot;&quot;
# 判断一个 key 是否存在，key 可以是字符串或 bytes 对象
print(&quot;name&quot; in db, &quot;NAME&quot; in db)
&quot;&quot;&quot;
True False
&quot;&quot;&quot;
# 获取一个 key 对应的 value，得到的是 bytes 对象
print(db[&quot;name&quot;].decode(&quot;utf-8&quot;))
print(db[b&quot;corporation&quot;].decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
S せんせい
小摩
&quot;&quot;&quot;
# key 如果不存在，会抛出 KeyError，我们可以使用 get 方法
print(db.get(&quot;NAME&quot;, b&quot;unknown&quot;))
&quot;&quot;&quot;
b'unknown'
&quot;&quot;&quot;
# 当然也可以使用 setdefault 方法，key 不存在时，自动写进去
print(db.setdefault(&quot;gender&quot;, b&quot;female&quot;))
&quot;&quot;&quot;
b'female'
&quot;&quot;&quot;
print(db[&quot;gender&quot;])
&quot;&quot;&quot;
b'female'
&quot;&quot;&quot;
</code></pre>
<p>非常简单，当你需要存储的数据量不适合放在内存中，但又没必要引入数据库，那么不妨试试使用 dbm 模块吧。</p>
<p>当然啦，dbm 虽然很方便，但它只能持久化 bytes 对象，字符串也是转成 bytes 对象之后再存储的。所以除了 dbm 之外，还有一个标准库模块 shelve，它可以持久化任意对象。</p>
<h2 id="shelve"><a class="header" href="#shelve">shelve</a></h2>
<p>shelve 的使用方式和 dbm 几乎是一致的，区别就是 shelve 的序列化能力要更强，当然速度自然也就慢一些。</p>
<pre><code class="language-python">import shelve

# 第二个参数表示模式，默认是 c
# 因此文件不存在会创建，存在则追加
sh = shelve.open(&quot;shelve&quot;)

sh[&quot;name&quot;] = [&quot;S 老师&quot;, &quot;高老师&quot;, &quot;电烤🐔架&quot;]
sh[&quot;age&quot;] = {18}
sh[&quot;job&quot;] = {&quot;tutu&quot;: &quot;大学生&quot;, &quot;xueer&quot;: &quot;医生&quot;}

# 关闭文件，刷到磁盘中
sh.close()
</code></pre>
<p>执行完之后，本地会多出一个 shelve.db 文件，下面来读取它。</p>
<pre><code class="language-python">import shelve

sh = shelve.open(&quot;shelve&quot;)

print(sh[&quot;name&quot;])
print(sh[&quot;name&quot;][2] == &quot;电烤🐔架&quot;)
&quot;&quot;&quot;
['S 老师', '高老师', '电烤🐔架']
True
&quot;&quot;&quot;
print(sh[&quot;age&quot;])
&quot;&quot;&quot;
{18}
&quot;&quot;&quot;
print(sh[&quot;job&quot;])
&quot;&quot;&quot;
{'tutu': '大学生', 'xueer': '医生'}
&quot;&quot;&quot;

sh.close()
</code></pre>
<p>读取出来的就是原始的对象，我们可以直接操作它。然后自定义类的实例对象也是可以的。</p>
<pre><code class="language-python">import shelve

class People:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @property
    def print_info(self):
        return f&quot;name is {self.name}, age is {self.age}&quot;

sh = shelve.open(&quot;shelve&quot;)

p = People(&quot;群主&quot;, 58)
# 将类、和该类的实例对象存储进去
sh[&quot;People&quot;] = People
sh[&quot;p&quot;] = p
sh.close()
</code></pre>
<p>执行完之后，我们打开它。</p>
<pre><code class="language-python">import shelve

sh = shelve.open(&quot;shelve&quot;)

# 需要注意的是，People 是我们自己定义的类
# 如果你想要将其还原出来，那么该类必须要出现在当前的命名空间中
try:
    sh[&quot;People&quot;]
except AttributeError as e:
    print(e)
    &quot;&quot;&quot;
    Can't get attribute 'People' on &lt;module ...&gt;
    &quot;&quot;&quot;

class People:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @property
    def print_info(self):
        return f&quot;name is {self.name}, age is {self.age}&quot;

print(sh[&quot;People&quot;] is People)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
print(sh[&quot;p&quot;].print_info)
&quot;&quot;&quot;
name is 群主, age is 58
&quot;&quot;&quot;
print(sh[&quot;People&quot;](&quot;群主&quot;, 38).print_info)
&quot;&quot;&quot;
name is 群主, age is 38
&quot;&quot;&quot;
</code></pre>
<p>这就是 shelve 模块，非常强大，当然它底层也是基于 pickle 实现的。如果你不需要存储复杂的 Python 对象，只需要存储字符串的话，那么还是推荐 dbm。</p>
<p>然后在使用 shelve 的时候，需要注意里面的一个坑。</p>
<pre><code class="language-python">import shelve

# 打开文件，设置键值对
sh = shelve.open(&quot;shelve&quot;)
sh[&quot;name&quot;] = &quot;古明地觉&quot;
sh[&quot;score&quot;] = [80, 80, 80]
sh.close()

# 重新打开文件，修改键值对
sh = shelve.open(&quot;shelve&quot;)
sh[&quot;name&quot;] = &quot;芙兰朵露&quot;
sh[&quot;score&quot;].append(90)
sh.close()

# 再次重新打开文件，查看键值对
sh = shelve.open(&quot;shelve&quot;)
print(sh[&quot;name&quot;])
print(sh[&quot;score&quot;])
&quot;&quot;&quot;
芙兰朵露
[80, 80, 80]
&quot;&quot;&quot;
sh.close()
</code></pre>
<p>第一次打开文件创建两个键值对，第二次打开文件将键值对修改，第三次打开文件查看键值对。但是我们发现 sh[&quot;name&quot;] 变了，而 sh[&quot;score&quot;] 却没变，这是什么原因？</p>
<p>当我们修改 name 时，采用的是直接赋值的方式，会将原本内存里的值给替换掉。而修改 score 时，是在原有值的基础上做 append 操作，它的内存地址并没有变。所以可变对象在本地进行修改，shelve 默认是不会记录的，除非创建新的对象，并把原有的对象给替换掉。所以sh[&quot;score&quot;].append(90) 之后，sh[&quot;score&quot;] 仍是 [80, 80, 80]，而不是 [80, 80, 80, 90]。</p>
<p>因为 shelve 没有记录对象自身的修改，如果想得到期望的结果，一种方法是把对象整体换掉。也就是让 sh[&quot;score&quot;] = [80, 80, 80, 90]，这样等于是创建了一个新的对象并重新赋值，是可行的。</p>
<p>或者你在打开文件的时候，多指定一个参数 writeback。</p>
<pre><code class="language-python">import shelve

# 打开文件，设置键值对
sh = shelve.open(&quot;shelve&quot;)
sh[&quot;name&quot;] = &quot;古明地觉&quot;
sh[&quot;score&quot;] = [80, 80, 80]
sh.close()

# 重新打开文件，修改键值对
sh = shelve.open(&quot;shelve&quot;, writeback=True)
sh[&quot;name&quot;] = &quot;芙兰朵露&quot;
sh[&quot;score&quot;].append(90)
sh.close()

# 再次重新打开文件，查看键值对
sh = shelve.open(&quot;shelve&quot;)
print(sh[&quot;name&quot;])
print(sh[&quot;score&quot;])
&quot;&quot;&quot;
芙兰朵露
[80, 80, 80, 90]
&quot;&quot;&quot;
sh.close()
</code></pre>
<p>可以看到都发生改变了，但这个参数会导致额外的内存消耗。当指定 writeback=True 的时候，shelve 会将读取的对象都放到一个内存缓存当中。比如我们操作了 20 个持久化的对象，但只修改了一个，剩余的 19 个只是查看并没有做修改，但当 sh.close() 的时候，会将这 20 个对象都写回去。</p>
<p>因为 shelve 不知道你会对哪个对象做修改，所以不管你是查看还是修改，都会放到缓存当中，然后再一次性都写回去。这样就会造成两点影响：</p>
<ul>
<li>shelve 会把我们使用的对象放到内存的另一片空间中，等于是额外拷贝了一份。</li>
<li>虽然操作了 N 个对象，但只修改了 1 个，而 shelve 会把 N 个对象都重新写回去，从而造成性能上的问题，导致效率降低。</li>
</ul>
<p>因此加不加这个参数，由具体情况决定。</p>
<p>综上所述，Python 算是自带了小型数据库，看看能不能在合适的场景中把它用上。</p>
<div style="break-before: page; page-break-before: always;"></div><p>Python 里面可以通过换行来标识一行语句的结束，当你在一行的末尾敲击 Enter 键时，便可开始新的一行语句。</p>
<pre><code class="language-python">name = &quot;高老师&quot;
print(name)  # 高老师
</code></pre>
<p>这段代码很简单，因为 <code>name = &quot;高老师&quot;</code> 后面已经没有内容了，是一个换行，那么就代表这个语句结束了。但是在 Python 中我们还可以指定分号，表示该语句结束了。</p>
<pre><code class="language-python">name = &quot;高老师&quot;; print(name); age = 18; print(age)
&quot;&quot;&quot;
高老师
18
&quot;&quot;&quot;
</code></pre>
<p>可以看到当我们在 <code>name = &quot;高老师&quot;</code> 后面指定了分号之后，就代表该语句结束了。但是 Python 的语法解析并不会直接跳到下一行，而是继续向后寻找，即便当中出现了空格。由于都在一行，所以解释器会找到 print(name)，然后继续向后寻找。尽管这么做是可以的，但不推荐这种写法，这种写法纯属在恶作剧，当然我们这里演示就不算了。</p>
<p>再比如 if 语句，有时候会出现写在一行的情况。</p>
<pre><code class="language-python">a = 123
if a &gt; 100: print(&quot;a &gt; 100&quot;); print(&quot;两个 print 具有相同的缩进&quot;)
&quot;&quot;&quot;
a &gt; 100
两个 print 具有相同的缩进
&quot;&quot;&quot;
</code></pre>
<p>如果 if 语句写在了一行，那么语句块的代码就应该只有一句，像我们这里的两个 print 就不应该写在同一行。并且这两个 print 的缩进层级是一样的，即：</p>
<pre><code class="language-python">a = 123

if a &gt; 100: print(&quot;a &gt; 100&quot;); print(&quot;两个 print 具有相同的缩进&quot;)
# 等价于
if a &gt; 100:
    print(&quot;a &gt; 100&quot;)
    print(&quot;两个 print 具有相同的缩进&quot;)
</code></pre>
<p>关于 Python 中的语句，根据交互式界面的表现形式我们可以分为两种：</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./1.png" alt="" /></p>
<p>我们看到当输入 num = 123 按下回车的时候，下一行的开始出现的是 &gt;&gt;&gt;，这表示上一行语句已经结束了。但是当输入 <code>if num &gt; 100:</code> 按下回车的时候，下一行出现的是 ...，这表示这行语句还没有结束。</p>
<p>像 <code>if xx:</code>，<code>for xx:</code>，<code>while xx:</code>，<code>def xx():</code>，<code>class xx:</code> 等等这样带有 <strong>:</strong> 的语句，一般是需要多行来表达的，一旦按下回车，就意味着下面肯定还有内容，而且还会带有缩进，在交互式界面中就会出现 <strong>...</strong>。而这样的语句我们在一行中只能出现一次，比如：</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./2.png" alt="" /></p>
<p>这样写是无法通过语法检测的，因为当中出现了两个 <strong>:</strong>，我们说这样的语句一行只能出现一次。当然肯定也不会有人这么做，所以这些知道就好。</p>
<p><strong>说完了换行，我们再来聊一聊反斜杠。</strong></p>
<p>如果一行代码比较长，我们需要分开多行来写该怎么办呢？答案是使用反斜杠 \，反斜杠在 Python 中表示转义。</p>
<pre><code class="language-python">a = \
    123456
# \ 表示转义，意思就是使后面的换行符失去效果
# 这样 Python 就不会认为这条语句结束了
# 因为 123456 前面还有一些空格，因此等价于 a =     123456

a = \
123456
# 这行代码就等价于 a = 123456 了
</code></pre>
<p>再比如字符串：</p>
<pre><code class="language-python">s = &quot;这是一段很&quot;   &quot;长的字符串&quot;  &quot;具体有多长我也不知道&quot;
print(s)  # 这是一段很长的字符串具体有多长我也不知道
</code></pre>
<p>Python 的字符串比较特别的是，不需要显式的使用加号。如果使用了加号，像这段代码就会先创建 3 个字符串，然后再拼接在一起。如果不使用加号，那么 Python 在语法解析的时候就会知道这是一个字符串，只不过分开写了。</p>
<pre><code class="language-python">s = &quot;这是一段很&quot; \
    &quot;长的字符串&quot; \
    &quot;具体有多长我也不知道&quot;
</code></pre>
<p>当然我们也可以分开写，但是要使用 \ 将换行符转义掉，而下面的做法则不行。</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./3.png" alt="" /></p>
<p>如果把 <strong>\</strong> 改成 <strong>+</strong> 就不行了，这个在 Go 里面可以，但是不同语言的语法检测不一样。因为 <strong>+</strong> 后面没有内容了，直接换行语句结束，那么这是无法通过语法检测的，所以 <strong>+</strong> 后面出现了红色波浪线。而且我们看到第三行字符串也出现了红色波浪线，这是缩进不对造成的，因为上面的语句已经结束，所以这是一条单独的语句，应该靠左对齐。这里显然没有对齐，而是出现了缩进。</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./4.png" alt="" /></p>
<p>这样写是可以的，此时就等价于<code>&quot;这是一段很长的字符串&quot; + &quot;具体有多长我也不知道&quot;</code>。</p>
<p>然后还有一个特殊情况，那就是出现了括号。</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./5.png" alt="" /></p>
<p>这样写也是没有问题的，因为 Python 在检测代码的时候发现了小括号的左半部分，那么即便出现了换行，Python 也不会认为语句结束了。只有当再找到小括号的右半部分，Python 才会认为语句结束，所以此时是不需要 <strong>\</strong> 的。</p>
<p>再来看几个需要动点脑筋的：</p>
<pre><code class="language-python">s = &quot;这是一段很&quot;
&quot;长的字符串&quot;
&quot;具体有多长我也不知道&quot;
print(s)
# 会打印什么呢？
</code></pre>
<p>只会打印<code>这是一段很</code>，因为遇到换行符语句结束了，下面两行只是创建两个字符串对象，而且还没有赋值，因此创建完之后就被销毁了。</p>
<pre><code class="language-python">s = &quot;这是一段很&quot; \
    &quot;长的字符串&quot;; \
    &quot;具体有多长我也不知道&quot;
print(s)
# 会打印什么呢？注意第二行出现了;
</code></pre>
<p>会打印<code>这是一段很长的字符串</code>，因为我们手动指定了 <code>;</code>，表示结束这段语句。后面出现的<code>&quot;具体有多长我也不知道&quot;</code>只是创建了一个字符串对象，没有赋值，创建完毕直接销毁。</p>
<p>因此上面的代码就等价于：</p>
<pre><code class="language-python">s = &quot;这是一段很长的字符串&quot;; &quot;具体有多长我也不知道&quot;

# 或者等价于

s = &quot;这是一段很长的字符串&quot;
&quot;具体有多长我也不知道&quot;
</code></pre>
<p>要是我们将第二行结尾的 <strong>\</strong> 给去掉，会怎么样？</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./6.png" alt="" /></p>
<p>可以看到如果把第二行的 <strong>\</strong> 去掉了，这里又出现了红色波浪线，这个问题我们上面说过了。因为第二行出现了 <strong>;</strong>，那么第三行就是单独的语句，所以应该要靠在左边。</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./7.png" alt="" /></p>
<p>这样写是没问题的，但第三行还是如我们之前所说，只是创建了一个字符串对象。</p>
<hr />
<p>再来说说 Python 的转义，这也是一个老生常谈的问题了，它是通过反斜杠来实现的。但 <strong>\</strong> 有两个作用：</p>
<ul>
<li>和一些特定的字符组合，从而具备特殊意义（\n, \t, \r 等等）</li>
<li>使 Python 的一些本来就具有特殊意义的字符失去其意义。</li>
</ul>
<pre><code class="language-python">s = &quot;my name is \nVan&quot;
print(s)
&quot;&quot;&quot;
my name is 
Van
&quot;&quot;&quot;

s = &quot;my name is \&quot;Van&quot;
print(s)
&quot;&quot;&quot;
my name is &quot;Van
&quot;&quot;&quot;
</code></pre>
<p>我们看到 <code>\</code> 和字符 <code>n</code> 组合，整体形成了换行。而 <code>\</code> 和 <code>&quot;</code> 组合则并不是变成新的什么东西，而是使 <code>&quot;</code> 失去其本来的意义。因为遇到 <code>&quot;</code> 表示字符串结束了，但是前面出现了 <code>\</code>，使得 <code>&quot;</code> 失去了其具有的意义，遇到下一个 <code>&quot;</code> 才表示字符串结束。而中间那个 <code>&quot;</code> 则是正常输出了出来，但是 <code>\</code> 却不见了，因为 <code>\</code> 和 <code>&quot;</code> 组合就等于 <code>&quot;</code>。</p>
<p>说到这儿，再补充一下 Python 字符串的几种表示方式：</p>
<pre><code class="language-python">print(hex(97), hex(98), hex(99))
&quot;&quot;&quot;
0x61 0x62 0x63
&quot;&quot;&quot;
# 在字符串中，每个字符还可以使用 \x 加两个 16 进制数字表示
print(&quot;\x61\x62\x63&quot;)
&quot;&quot;&quot;
abc
&quot;&quot;&quot;
# 或者使用 \ 加上三个 8 进制数字表示
print(oct(97), oct(98), oct(99))
&quot;&quot;&quot;
0o141 0o142 0o143
&quot;&quot;&quot;
print(&quot;\141\142\143&quot;)
&quot;&quot;&quot;
abc
&quot;&quot;&quot;

# 不过上面只能表示 ASCII 字符串，因为一个汉字占三个字节
# 所以当包含一个字节无法表示的字符时，解析就会出现乱码
print(&quot;\xe9\xab\x98\xe8\x80\x81\xe5\xb8\x88&quot;)
&quot;&quot;&quot;
é«èå¸
&quot;&quot;&quot;
print(b&quot;\xe9\xab\x98\xe8\x80\x81\xe5\xb8\x88&quot;.decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
高老师
&quot;&quot;&quot;
</code></pre>
<p>当然，在 Python 里面每个字符还可以使用 \u 或者 \U 来表示。</p>
<pre><code class="language-python"># \u 表示 unicode，后面跟 4 个十六进制数表示的 unicode 码点
print(hex(97), hex(98), hex(99))
&quot;&quot;&quot;
0x61 0x62 0x63
&quot;&quot;&quot;
print(&quot;\u0061 \u0062 \u0063&quot;)
&quot;&quot;&quot;
a b c
&quot;&quot;&quot;

print(ord(&quot;高&quot;), ord(&quot;老&quot;), ord(&quot;师&quot;))
&quot;&quot;&quot;
39640 32769 24072
&quot;&quot;&quot;
print(hex(39640), hex(32769), hex(24072))
&quot;&quot;&quot;
0x9ad8 0x8001 0x5e08
&quot;&quot;&quot;
print(&quot;\u9ad8 \u8001 \u5e08&quot;)
&quot;&quot;&quot;
高 老 师
&quot;&quot;&quot;

# 如果是 emoji，它的码点超出了 FFFF
# 此时 4 个 16 进制数无法表示，因此需要 8 个十六进制数
print(hex(ord(&quot;🤣&quot;)), hex(ord(&quot;🤡&quot;)))
&quot;&quot;&quot;
0x1f923 0x1f921
&quot;&quot;&quot;
# 如果是 4 个十六进制数，那么可以使用 \u 或者 \U
# 如果是 8 个十六进制数，那么只能使用 \U
print(f&quot;\U0001f923 -&gt; \U0001f921&quot;)
&quot;&quot;&quot;
🤣 -&gt; 🤡
&quot;&quot;&quot;
</code></pre>
<p>还是蛮有趣的，Python 字符串的表示方式还挺丰富。</p>
<hr />
<p>最后是 Python 的 r 前缀，如果字符串的开头出现了 r，会是什么情况呢？</p>
<pre><code class="language-python">s1 = &quot;my name is \nVan&quot;
s2 = r&quot;my name is \nVan&quot;
print(s1)
&quot;&quot;&quot;
my name is 
Van
&quot;&quot;&quot;
print(s2)
&quot;&quot;&quot;
my name is \nVan
&quot;&quot;&quot;
</code></pre>
<p>如果是 <strong>r&quot;&quot;</strong> 这种形式，表示这个字符串是原生的，这里的 r 表示 raw。里面出现的任何东西都当成普通字符串，什么 \n 啊，\t 啊，就是普通的字符串。但是我们说过，<strong>\</strong> 具有两个作用：</p>
<ul>
<li>和某些特殊字符组合，从而具备一些特殊意义</li>
<li>使得某些本来就具有特殊意义的字符，失去其意义</li>
</ul>
<p>而 <strong>r&quot;&quot;</strong> 这种形式，只会限制 <strong>\</strong> 的第一个作用，却不会限制其第二个作用。</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./8.png" alt="" /></p>
<p>我们看到即使加上了前缀 r，第一行语句依旧是不合法的，因为 <strong>&quot;</strong> 表示字符串的边界，即使加上了 r，对于 <strong>&quot;</strong> 依旧是无能为力的，这时候还是需要 <strong>\</strong> 进行转义。</p>
<pre><code class="language-python">s1 = &quot;my name is \&quot;Van&quot;
s2 = r&quot;my name is \&quot;Van&quot;
print(s1)
print(s2)
&quot;&quot;&quot;
my name is &quot;Van
my name is \&quot;Van
&quot;&quot;&quot;
</code></pre>
<p>然后我们又观察到了一个奇特的现象，当不加 r 的时候，<strong>\&quot;</strong> 会表示 <strong>&quot;</strong>，而加上了 r，<strong>\&quot;</strong> 则表示 <strong>\&quot;</strong>，因为 r 表示原生的，<strong>\</strong> 会原原本本的输出出来。但我们说了，r 不会限制 <strong>\</strong> 的第二个作用，所以 <strong>\</strong> 不仅输出了出来，还使得 <strong>&quot;</strong> 失去了其原本的意义。</p>
<p>最后引出 Python 中一个比较让人费解的问题，估计已经有人猜到了，那就是字符串结尾出现了 <strong>\</strong>。</p>
<p><img src="%E8%81%8A%E4%B8%80%E8%81%8A%20Python%20%E7%9A%84%E6%8D%A2%E8%A1%8C%E4%BB%A5%E5%8F%8A%E8%BD%AC%E4%B9%89/./9.png" alt="" /></p>
<p>两行代码都是不合法的。</p>
<p>第一行代码不合法是因为右边的 <strong>&quot;</strong> 表示字符串的结尾，现在我们使用 <strong>\</strong> 让其失去了本来的意义，而后面又是空行导致相当于写了一半的语句结束了，所以不合法能够理解。第二行同样不合法，因为 r 限制不了 <strong>\</strong> 的第二个作用，也就是第二行的 <strong>\</strong> 依旧会使得 <strong>&quot;</strong> 失去其意义，导致同样是写了一半的语句强行结束了。因此解决办法就是再来一个 <strong>\</strong>，形成 <strong>\\</strong>。</p>
<pre><code class="language-python">s1 = &quot;my name is Van\\&quot;
s2 = r&quot;my name is Van\\&quot;
print(s1)
print(s2)
&quot;&quot;&quot;
my name is Van\
my name is Van\\
&quot;&quot;&quot;
</code></pre>
<p>第二行代码的输出多了一个 <strong>\</strong>，因为不加 r 的话，<strong>\\</strong> 等价于 <strong>\</strong>，因为第一个 <strong>\</strong> 在使第二个 <strong>\</strong> 失去意义的时候，其使命也就结束了，因此只会输出一个 <strong>\</strong>。</p>
<p>但是对于有 r 前缀的字符串来说，<strong>\</strong> 就表示普通的字符，所以是什么就输出什么，只不过即便它是普通字符，依旧具备第二个功能。因此对于第二行有前缀 r 的字符串来说，第一个 <strong>\</strong> 不仅让第二个 <strong>\</strong> 失去了意义，使得它不能再干扰结尾的 <strong>&quot;</strong>，而且两个 <strong>\</strong> 都会原本的输出出来。</p>
<p>如果 \ 出现在其他位置呢？</p>
<pre><code class="language-python">s1 = &quot;my nam\e is Van&quot;
s2 = r&quot;my nam\e is Van&quot;
print(s1)
print(s2)
&quot;&quot;&quot;
my nam\e is Van
my nam\e is Van
&quot;&quot;&quot;
</code></pre>
<p>输出是一样的，因为 <strong>\</strong> 和字符 <strong>e</strong> 无法形成具有特殊意义的字符，而且 <strong>e</strong> 也是一个普通的字符，不具备什么特殊意义。所以对于 s1 来说，就直接把 <strong>\</strong> 完整的输出了，但是不推荐这种写法。</p>
<p>对于 s1 来说，应该指定两个 <strong>\</strong>。如果就只想写一个 <strong>\</strong> 的话，那么应该指定前缀 r，所以 s2 是没问题的。</p>
<div style="break-before: page; page-break-before: always;"></div><p>本次来分享一个处理音频的库 pydub，当然这个库本身无法操作音频，它只是对 ffmpeg 进行的一个封装。既然是封装，那就说明实际处理音频的还是 ffmpeg，所以 pip install pydub 之后，我们还要安装 ffmpeg，直接去官网下载即可。</p>
<p><img src="%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%20Python%20%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91%E7%9A%84%E5%BA%93/./1.png" alt="" /></p>
<p>然后将这些可执行文件所在的目录配置到环境变量中就可以了。</p>
<p><font color="darkblue"><strong>打开音频文件</strong></font></p>
<p>音频有很多种格式，比如 wav、mp3、ogg 等等，只要是 ffmpeg 支持的文件格式都可以打开，而 ffmpeg 基本支持所有主流的音频格式。</p>
<pre><code class="language-Python">from pydub import AudioSegment

# 打开 mp3 文件
AudioSegment.from_mp3(&quot;1.mp3&quot;)
# 打开 wav 文件
AudioSegment.from_wav(&quot;1.wav&quot;)
# 打开 ogg 文件
AudioSegment.from_ogg(&quot;1.ogg&quot;)

# 以上所有方法都调用了 from_file，等价于
AudioSegment.from_file(&quot;1.mp3&quot;, &quot;mp3&quot;)
AudioSegment.from_file(&quot;1.wav&quot;, &quot;wav&quot;)
AudioSegment.from_file(&quot;1.ogg&quot;, &quot;ogg&quot;)
# 由于 mp3、wav、ogg 文件很常见，所以有单独的方法
# 但还有不常见的音频格式，比如苹果手机自带的录音软件导出的就是 m4a 格式
# 此时就只能使用 from_file 打开了
AudioSegment.from_file(&quot;1.m4a&quot;, &quot;m4a&quot;)
</code></pre>
<p>注意：在读取文件的时候，格式一定要匹配，否则报错。举个例子：</p>
<pre><code class="language-Python">from pydub import AudioSegment

try:
    AudioSegment.from_wav(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
except Exception as e:
    print(e)
&quot;&quot;&quot;
Decoding failed. ffmpeg returned error code: 1

Output from ffmpeg/avlib:

b'...Invalid data found when processing input\r\n
&quot;&quot;&quot;
</code></pre>
<p>我们的音频是 mp3 格式的，但是却调用了 from_wav，所以会报错。当然也不要觉得将文件扩展名改成 wav 就万事大吉了，因为文件的类型取决于它存储的字节流，而不是扩展名。</p>
<pre><code class="language-Python">from pydub import AudioSegment

song = AudioSegment.from_mp3(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
print(song) 
&quot;&quot;&quot;
&lt;pydub.audio_segment.AudioSegment object at 0x0000021782910C40&gt;
&quot;&quot;&quot;
</code></pre>
<p>返回的是一个 AudioSegment 对象，它就是音频读取之后的结果，通过该对象我们可以对音频进行各种操作，比如增加音量、淡入淡出等等。</p>
<p>并且这些操作都是链式的，每一个操作都会返回一个新的对象，不会修改原来的对象。所以我们在操作的时候，可以一直写下去，比如 song.xxx.xxx，不用每一次操作都重新赋值一个变量。</p>
<blockquote>
<p>注意：pydub 做的任何操作，只要和时间相关，那么单位都是毫秒。</p>
</blockquote>
<p>下面我们来看看它都支持哪些操作。</p>
<p><font color="darkblue"><strong>截取某一个片段</strong></font></p>
<p>对音频进行切片，这是一个非常常用的操作，一个长音频，我们可能只要前 5 秒，或者后 5 秒等等。</p>
<pre><code class="language-Python"># 截取前 5 秒
first_5_seconds = song[: 5 * 1000]

# 截取后 5 秒
last_5_seconds = song[-5000:]
</code></pre>
<p>返回的都是新的 AudioSegment 对象，保存之后正好是原始音频文件的前 5 秒和后 5 秒，关于保存文件后面会说。</p>
<p><font color="darkblue"><strong>音量增加和减小</strong></font></p>
<p>我们可以让音量放大和缩小，并且实现起来也非常简单。</p>
<pre><code class="language-python"># 声音增大 9 分贝
first_5_seconds = first_5_seconds + 9

# 声音减小 7 分贝
last_5_seconds = last_5_seconds - 7
</code></pre>
<p>怎么样，是不是非常简单呢？</p>
<p><font color="darkblue"><strong>音频拼接</strong></font></p>
<p>估计有人猜到做法了，没错，直接相加即可。</p>
<pre><code class="language-Python">song_first_last = first_5_seconds + last_5_seconds
</code></pre>
<p>此时 song_first_last 就是由原始音频的前 5 秒放大 9 分贝，和原始音频的后 5 秒减小 7 分贝组合而成的新的音频（AudioSegment 对象）。</p>
<p><font color="darkblue"><strong>淡入淡出</strong></font></p>
<pre><code class="language-Python">song_first_last = first_5_seconds.append(last_5_seconds, crossfade=1500)
</code></pre>
<p>调用 append 也相当于将音频组合在一起，但是这种方式可以增加一些淡入淡出的效果。当然我们也可以手动实现：</p>
<pre><code class="language-Python">song_first_last = first_5_seconds.fade_in(2000) + last_5_seconds.fade_out(3000)
</code></pre>
<p>前 5 秒和后 5 秒拼接起来得到 10 秒钟的音频，并且前 2 秒淡入，后 3 秒淡出。</p>
<p><font color="darkblue"><strong>重复</strong></font></p>
<p>将一个片段重复 n 遍。</p>
<pre><code class="language-Python">repeat_5 = song[: 3000] * 5
</code></pre>
<p>将前 3 秒重复了 5 遍，等于把 song[: 3000] 重复相加 5 次。</p>
<p><font color="darkblue"><strong>反转音频</strong></font></p>
<p>说白了就是倒放。</p>
<pre><code class="language-Python">song_reverse = song.reverse()
</code></pre>
<p><font color="darkblue"><strong>两个音频重叠播放</strong></font></p>
<p>比如你有两个音频，一个是台词，一个是背景音乐，你需要将它们合并为一个音频。</p>
<pre><code class="language-Python">from pydub import AudioSegment

song1 = AudioSegment.from_ogg(&quot;台词.ogg&quot;)
song2 = AudioSegment.from_ogg(&quot;背景音乐.ogg&quot;)
# 将 song1 和 song2 合并在一起
# 并且在 song1 的 5 秒后，开始播放 song2，position 默认为 0
song1.overlay(song2, position=5000)
</code></pre>
<p><font color="darkblue"><strong>声道分离</strong></font></p>
<p>关于声道，我们一会儿解释。</p>
<pre><code class="language-Python">from pydub import AudioSegment

song = AudioSegment.from_ogg(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
# 声道的分离，得到两个不同声道对应的 AudioSegment 对象
left_channel, right_channel = song.split_to_mono()
</code></pre>
<p><font color="darkblue"><strong>获取音频的某一帧</strong></font></p>
<pre><code class="language-Python">song.get_frame(1)  # 获取第一帧
</code></pre>
<p><font color="darkblue"><strong>获取音频属性</strong></font></p>
<p>下面我们来获取音频的一些属性，不过在获取之前，先介绍一下音频属性的一些细节。</p>
<p>采样频率：又被称作取样频率，是单位时间内的采样次数，决定了数字化音频的质量。采样频率越高，数字化音频的质量越好，还原的波形越完整，播放的声音越真实，当然所占的大小也就越大。根据奎特采样定理，要从采样中完全恢复原始信号的波形，采样频率要高于声音中最高频率的两倍。人耳可听到的声音的频率范围是在 16 赫兹到 20 千赫兹之间，因此要将听到的原声音真实地还原出来，采样频率必须大于 40千赫兹。而 44千赫兹 的音频可以达到 CD 的音质，当然可以更高，只不过高于 48 千赫兹 的采样频率人耳很难分别，没有实际意义。</p>
<p>采样位数：也叫量化位数（单位：比特），是存储每个采样值所用的二进制位数，采样值反映了声音的波动状态，采样位数决定了量化精度。采样位数越长，量化的精度就越高，还原的波形曲线越真实，产生的量化噪音越小，回放的效果越真实。常用的量化位数有 4、8、12、16、24等等，量化位数与声卡的位数和编码有关。</p>
<p>声道数：使用的声音通道的个数，也是采样时所产生的声音波形个数。播放声音时，单声道的 wav 一般使用一个喇叭发声，立体声的 wav 可以使用两个喇叭发声。记录声音时，单声道每次产生一个波形的数据；双声道每次产生两个波形的数据，当然最终音频所占的存储空间也会增加一倍。</p>
<p>比特率：比特率是指每秒传送的比特（bit）数，单位为 bps（Bit Per Second），比特率越高，传送的数据越大。在音频、视频领域，比特率又被称为码率、位率、位速（这四个老铁是同一个东西，只是不同领域、不同翻译造就了这么多的名词）。比特率表示经过编码（压缩）后的音、视频数据每秒钟需要用多少个比特来表示。比特率与音、视频压缩的关系，简单来说就是比特率越高，音频、视频的质量就越好，但编码后的文件就越大；如果比特率越少则情况刚好相反，<code>比特率 = 采样频率 * 采样位数 * 声道数</code>。</p>
<pre><code class="language-python">from pydub import AudioSegment

song = AudioSegment.from_mp3(&quot;高梨康治 - 百鬼夜行.mp3&quot;)

# 声道数, 1 表示单声道, 2 表示双声道
print(song.channels)  # 2

# 采样宽度, 采样位数除以 8 就是采样宽度了, 因为一个字节有 8 位
# 同理采样宽度乘以 8 就是采样位数，当前音频是 16 位的
print(song.sample_width)  # 2
print(song.sample_width * 8)  # 16

# 采样频率, 采样频率等于帧速率
print(song.frame_rate)  # 44100

# 块对齐之后的大小, 或者一帧的字节数
# 等于 通道数 * 采样位数 / 8, 或者 通道数 * 采样宽度
print(song.frame_width)  # 4
print(song.channels * song.sample_width)  # 4

# 字节率, 等于 采样频率 * 声道数量 * 采样宽度(采样位数 / 8), 可以直接计算得到
print(song.frame_rate * song.channels * song.sample_width)  # 176400

# 时长(单位秒)
print(song.duration_seconds)  # 87.8225850340136

# 帧数目
print(song.frame_count())  # 3872976.0

# 原始的音频数据, 不打印了
song.raw_data
</code></pre>
<p><font color="darkblue"><strong>音频导出</strong></font></p>
<p>我们对音频进行了一些操作之后，怎么保存到本地呢？这也是关键的一部分，不然你处理完了没有用啊。很简单，直接调用 AudioSegment 对象的 export 方法即可。</p>
<pre><code class="language-Python">from pydub import AudioSegment

song = AudioSegment.from_mp3(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
song.export(&quot;百鬼夜行.wav&quot;, &quot;wav&quot;)
</code></pre>
<p>指定文件名和保存的类型即可，注意：第二个参数表示保存的音频的类型，必须要指定正确。如果不指定那么默认是 mp3，即便我们第一个参数的文件名结尾是 .wav，但是保存的时候仍是 mp3。</p>
<p>所以基于 pydub 可以很容易地实现音频格式转换。</p>
<p><font color="darkblue"><strong>修改属性</strong></font></p>
<p>有时我们需要改变文件的格式，但有时也需要改变文件的属性。比如某个 MP3 文件的采样频率有点高，我们需要降低一些，或者双声道变成单声道等等，这个时候该怎么做呢？</p>
<pre><code class="language-Python">from pydub import AudioSegment

song = AudioSegment.from_mp3(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
print(song.channels)  # 2

# 将通道设置为 1, 然后导出
song.set_channels(1).export(&quot;高梨康治 - 百鬼夜行_1.mp3&quot;, &quot;mp3&quot;)

# 重新读取, 查看通道
print(
    AudioSegment.from_mp3(r&quot;高梨康治 - 百鬼夜行_1.mp3&quot;).channels
)  # 1
</code></pre>
<p>1 表示单声道，2 表示双声道，从单声道转成双声道不会有任何的改变，但从双声道转成单声道可能会导致质量损失（当左右声道不同时）。</p>
<p>单声道：只用一条音频通道记录声音，是最古老、最基础的声音记录方式。单声道因为只有一条音频通道，所以我们的大脑接收的左右耳的信息没有差异，听觉系统就不会产生心理声学的定位，所以不会有宽度及深度的差异。只能感受到声音、音乐的前后位置及音色、音量的大小，而不能感受到声音从左到右等横向的移动。效果相对于真实的自然声来说，是简单化的，是失真了的。所以听出来的声音干涩，没有层次感，没有现场感，一般用来听新闻广播，因为单声道信号简单不易丢失。原理是把来自不同方位的音频信号混合后统一由录音器材把它记录下来，再由一只音箱进行重放。</p>
<p>双声道：人们听到声音时可以根据左耳和右耳对声音的相位差来判断声源的具体位置，在电路上它们往往各自传递的电信号是不一样的。相当于实现立体声的原理，在空间放置两个互成一定角度的扬声器，每个扬声器单独由一个声道提供信号。而每个声道的信号在录制的时候就经过了处理，有些音乐就跟气流一样，从左到右再从右到左，因为是两个不同的声道，当一个声道的响度比另一个声道大的时候，我们就感觉声音好像有了方向一样。双声道立体感强，有音场，多用于音乐、CD 等专辑。基本上音乐都是双声道，如果是单声道的音乐，只能说明音质非常非常差。</p>
<p><strong>注意：设置的话不要通过下面这种方式来设置。</strong></p>
<pre><code class="language-Python">from pydub import AudioSegment

song = AudioSegment.from_mp3(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
song.channels = 1
</code></pre>
<p>因为一个属性变了，可能会影响其它的属性，比如：帧大小，它等于 通道数 乘上 采样宽度（采样位数 / 8），如果通道变了，那么帧大小也会受到影响。所以我们应该通过 pydub 提供的 API 来设置，内部会自动帮我们处理。</p>
<pre><code class="language-Python">from pydub import AudioSegment

song = AudioSegment.from_mp3(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
print(song.frame_rate)  # 44100

# 更改采样频率, 一般都是 44100, 我们可以修改为其它的值
# 注意: 并不是任意值都可以, 只能是 8000 12000 16000 24000 32000 44100 48000 之一
# 如果不是这些值当中的一个, 那么会当中选择与设置的值最接近的一个
# 比如我们设置 18000, 那么会自动变成 16000
song.set_frame_rate(18000).export(&quot;高梨康治 - 百鬼夜行_1.mp3&quot;, &quot;mp3&quot;)
print(AudioSegment.from_mp3(r&quot;高梨康治 - 百鬼夜行_1.mp3&quot;).frame_rate)  # 16000
</code></pre>
<p>采样频率等于帧速率，以赫兹为单位。增大这个值通常不会导致质量的下降，但降低这个值一定会导致质量的下降，因为更高的帧速率意味着更大的频响特征（即可以表示更高的频率）。</p>
<p>除了通道数、采样频率之外，我们还可以设置采样宽度（采样位数除以 8），对于一个音频而言能设置这些属性已经足够了。像很多大厂提供的音频识别服务，也会对音频属性有严格的限制，而限制的属性也基本上就这些。无非是通道、采样频率、采样位数等等。</p>
<pre><code class="language-Python">from pydub import AudioSegment

song = AudioSegment.from_mp3(&quot;高梨康治 - 百鬼夜行.mp3&quot;)
print(song.sample_width)  # 2
song.set_sample_width(3).export(&quot;高梨康治 - 百鬼夜行_1.mp3&quot;, &quot;mp3&quot;)
print(AudioSegment.from_mp3(r&quot;高梨康治 - 百鬼夜行_1.mp3&quot;).sample_width)  # 2
</code></pre>
<p>从打印的结果上来看，我们似乎没有设置成功，因为这和音频本身也是有相应关系的。可能音频本身的采样宽度就只能是 2，不过绝大部分音频的采样宽度都是 2，即采样位数为 16。</p>
<p><font color="darkblue"><strong>export 的其它参数</strong></font></p>
<p>我们导出音频的时候使用的是 export 方法，这里面还可以接收其它参数，先来看看我们导出的音频的原始的音频之间的差异。</p>
<p><img src="%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%20Python%20%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91%E7%9A%84%E5%BA%93/./2.png" alt="" /></p>
<p>我们看到原始的音频有很多其它信息，比如作曲人、专辑等等，但是我们导出的没有，那么可不可以设置呢。答案是可以的，在导出的时候加上一个 tags 参数即可。</p>
<pre><code class="language-python">from pydub import AudioSegment

song = AudioSegment.from_mp3(r&quot;高梨康治 - 百鬼夜行.mp3&quot;)
song.export(&quot;高梨康治 - 百鬼夜行_1.mp3&quot;, &quot;mp3&quot;,
            tags={&quot;artist&quot;: &quot;古明地觉&quot;, &quot;album&quot;: &quot;地灵殿专辑&quot;,
                  &quot;title&quot;: &quot;好听的百鬼夜行&quot;, &quot;comments&quot;: &quot;妈耶, 真好听&quot;})
</code></pre>
<p>再来看看效果。</p>
<p><img src="%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%20Python%20%E5%A4%84%E7%90%86%E9%9F%B3%E9%A2%91%E7%9A%84%E5%BA%93/./3.png" alt="" /></p>
<p>其它的属性可以单击右键，然后点击属性查看。对了还有图片，如果在导出的时候想要自定义封面的话，可以通过 cover 参数，传递一个图片文件地址即可。</p>
<p>另外，我们这里导出的文件要比原始文件小很多，原因在于比特率不一样。原始的音频的比特率是 320kbps，而我们导出的音频的比特率要小很多。因为比特率表示音频一秒所需的比特数，比特率越小，显然文件就越小。而我们在导出的时候也是可以修改比特率的：</p>
<pre><code class="language-python">song.export(&quot;高梨康治 - 百鬼夜行_1.mp3&quot;, &quot;mp3&quot;, bitrate=&quot;320k&quot;)
</code></pre>
<p>以上就是 pydub 对音频的一些常见操作，总的来说支持的功能还是比较多的。如果你对音视频处理感兴趣，可以在这一领域深耕下去，因为涉足该领域的人确实不多。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-15"><a class="header" href="#楔子-15">楔子</a></h2>
<p>在工作中难免会遇到解析 HTML 的场景，比如将网页下载下来之后，要解析出里面图片的路径、指定标签里的文本等等。而 pyquery 专门负责做这件事，它是仿照 jquery 设计的，用起来非常方便。并且 pyquery 底层基于 lxml，而 lxml 是使用 Cython 实现的，所以 pyquery 的速度也有保证。</p>
<pre><code class="language-python">from pyquery import PyQuery

html = &quot;&quot;&quot;
&lt;body&gt;
    &lt;p&gt;
        古明地觉的编程教室
    &lt;/p&gt;
&lt;/body&gt;
&quot;&quot;&quot;
p = PyQuery(html)
print(type(p))
&quot;&quot;&quot;
&lt;class 'pyquery.pyquery.PyQuery'&gt;
&quot;&quot;&quot;
# 打印 PyQuery 对象会直接显示 HTML 内容
print(p)
&quot;&quot;&quot;
&lt;body&gt;
    &lt;p&gt;
        古明地觉的编程教室
    &lt;/p&gt;
&lt;/body&gt;
&quot;&quot;&quot;
</code></pre>
<p>我们在获取 HTML 之后，直接传递 PyQuery 中，然后通过属性选择器即可获取指定的内容。</p>
<p>另外除了传递 HTML 文本之外，还可以传递一个 URL，或者 HTML 文件。</p>
<pre><code class="language-python">from pyquery import PyQuery

# 传递一个 url, 会自动调用 urlopen 下载内容
p1 = PyQuery(url=&quot;https://www.baidu.com&quot;, encoding=&quot;utf-8&quot;)
# 传递一个 html 文件, 会自动打开并读取
p2 = PyQuery(filename=&quot;1.html&quot;)
</code></pre>
<p>后两种方式其实不是很常用，我们一般还是会搭配 requests 或者 httpx，下载完页面之后直接丢给 PyQuery。</p>
<p>接下来我们看看如何筛选指定的标签，多说一句，我个人非常喜欢这个库，在解析 HTML 的时候首先想到的就是它。</p>
<h2 id="css-选择器"><a class="header" href="#css-选择器">CSS 选择器</a></h2>
<p>pyquery 是模仿 jquery 设计的，显然它也是通过类似于 CSS 选择器的方式进行筛选，下面介绍一些常用的选择器。</p>
<pre><code class="language-Python">from pyquery import PyQuery

html = &quot;&quot;&quot;
&lt;body&gt;
    &lt;div class=&quot;div_cls1 div_cls2&quot;&gt;
        &lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
        &lt;div class=&quot;div_cls3&quot;&gt;
            &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div&gt;
        &lt;a href=&quot;http://www.me.org/bento/1.png&quot;&gt;&lt;/a&gt;
        &lt;p&gt;
            &lt;a href=&quot;http://www.me.org/image/2.png&quot;&gt;&lt;/a&gt;
        &lt;/p&gt;
    &lt;/div&gt;

    &lt;div class=&quot;div_cls1&quot;&gt;
        &lt;span&gt;嘿嘿嘿&lt;/span&gt;
    &lt;/div&gt;
&lt;/body&gt;
&quot;&quot;&quot;
p = PyQuery(html)
</code></pre>
<p>我们以上面这个 HTML 为例，来看看相关操作。</p>
<p><font color="blue"><strong>基于标签进行选择</strong></font></p>
<pre><code class="language-Python"># 选择所有的 p 标签
print(p(&quot;p&quot;))
&quot;&quot;&quot;
&lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
        &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;p&gt;
            &lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
        &lt;/p&gt;
    
&quot;&quot;&quot;
</code></pre>
<p>会选择所有指定的标签，并且包含标签里面的内容。</p>
<p><font color="blue"><strong>同时选择多个标签</strong></font></p>
<p>在基于标签选择时，也可以同时选择多个标签。</p>
<pre><code class="language-Python"># 选择所有的 p 标签和 a 标签
print(p(&quot;p,a&quot;))
&quot;&quot;&quot;
&lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
        &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;a href=&quot;http://www.me.org/bento/1.png&quot;/&gt;
        &lt;p&gt;
            &lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
        &lt;/p&gt;
    &lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
    
&quot;&quot;&quot;
</code></pre>
<p>多个标签之间使用逗号分隔，会将多个标签都筛选出来。</p>
<p>注意：筛选的标签之间是独立的，比如第二个 a 标签，它在 p 标签里面。我们筛选 p 标签的时候，已经将它内部的 a 标签筛选出来了，但在筛选 a 标签的时候又筛选出来一次，因此标签之间是独立的。</p>
<p><font color="blue"><strong>选择指定标签下的子标签</strong></font></p>
<pre><code class="language-Python"># 选择所有的 div 标签下的所有 a 标签
print(p(&quot;div a&quot;))
&quot;&quot;&quot;
&lt;a href=&quot;http://www.me.org/bento/1.png&quot;/&gt;
        &lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
        
&quot;&quot;&quot;
</code></pre>
<p>多个标签使用空格分隔，表示筛选层级，比如 tag1 tag2 tag3，表示筛选所有 tag1 标签下的所有 tag2 标签下的所有 tag3 标签。</p>
<p>div a 表示从所有 div 的子孙节点中选择 a 标签，如果只希望从儿子节点中选择呢？</p>
<pre><code class="language-Python"># 选择所有的 div 标签下的所有 a 标签，但只从儿子节点中选择
# 第二个 a 标签的外部套了个 p 标签，所以不符合筛选条件
print(p(&quot;div&gt;a&quot;))
&quot;&quot;&quot;
&lt;a href=&quot;http://www.me.org/bento/1.png&quot;/&gt;
        
&quot;&quot;&quot;
</code></pre>
<p>当标签之间是空格，那么会从子孙节点当中选择；当标签之间是大于号，那么只会从儿子节点当中选择。</p>
<p><font color="blue"><strong>按照 id 选择标签</strong></font></p>
<pre><code class="language-Python"># 选择 id = &quot;six_six_six&quot; 的标签
print(p(&quot;#six_six_six&quot;))
&quot;&quot;&quot;
&lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
&quot;&quot;&quot;
</code></pre>
<p>id 在一个 html 中具有唯一性，所以有 id 属性的话，那么会非常好定位。</p>
<p><font color="blue"><strong>按照 class 选择标签</strong></font></p>
<pre><code class="language-Python">p = PyQuery(html)
# 选择 class 等于 &quot;p_cls1&quot; 的标签
print(p(&quot;.p_cls1&quot;))
&quot;&quot;&quot;
&lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
&quot;&quot;&quot;
</code></pre>
<p>选择所有 class 属性等于 p_cls1 的标签，但是注意，一个标签可以同时拥有多个 class。</p>
<pre><code class="language-Python">print(p(&quot;.div_cls1&quot;))
&quot;&quot;&quot;
&lt;div class=&quot;div_cls1 div_cls2&quot;&gt;
        &lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
        &lt;div class=&quot;div_cls3&quot;&gt;
            &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class=&quot;div_cls1&quot;&gt;
        &lt;span&gt;嘿嘿嘿&lt;/span&gt;
    &lt;/div&gt;
        
&quot;&quot;&quot;
</code></pre>
<p>我们看到两个 div 都应用了 div_cls1 这个 class，因此它们都被筛选了出来。而第一个 div 除了 div_cls1，还应用了 div_cls2 这个 class。</p>
<p>那么问题来了，如果我们希望选择同时应用了 div_cls1 和 div_cls2 的标签该怎么做呢？</p>
<pre><code class="language-Python">print(p(&quot;.div_cls1.div_cls2&quot;))
&quot;&quot;&quot;
&lt;div class=&quot;div_cls1 div_cls2&quot;&gt;
        &lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
        &lt;div class=&quot;div_cls3&quot;&gt;
            &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
        
&quot;&quot;&quot;
</code></pre>
<p>我们看到此时就只获取了第一个 div，注意：.div_cls1 和 .div_cls2 之间不可以有空格，如果加上了空格，那么含义就变成了选择 .div_cls1 标签下面的 .div_cls2 标签。</p>
<p>所以 id、class、标签等选择器，它们可以搭配使用。比如说：</p>
<p><img src="pyquery%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%81%B5%E6%B4%BB%E6%96%B9%E4%BE%BF%E7%9A%84%20HTML%20%E8%A7%A3%E6%9E%90%E5%BA%93/./1.png" alt="" /></p>
<p>实际举例说明：</p>
<pre><code class="language-python"># 找到所有 class 包含 div_cls1、div_cls2 的标签
# 再从其儿子节点中找到所有 class 包含 .div_cls3 的 div 标签
print(p(&quot;div.div_cls1.div_cls2&gt;div.div_cls3&quot;))
&quot;&quot;&quot;
&lt;div class=&quot;div_cls3&quot;&gt;
            &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;/div&gt;
        
&quot;&quot;&quot;
</code></pre>
<p>综上所述，pyquery 还是很强大的。</p>
<p><font color="blue"><strong>选择是否具有指定属性的标签</strong></font></p>
<pre><code class="language-python"># 选择具有 class 属性的 p 标签
print(p(&quot;p[class]&quot;))
&quot;&quot;&quot;
&lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
&quot;&quot;&quot;

# 选择具有 id 属性的 p 标签
print(p(&quot;p[id]&quot;))
&quot;&quot;&quot;
&lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
&quot;&quot;&quot;

# 选择 class=&quot;div_cls1&quot; 的 div 标签
# 等号右面可以是双引号，也可以是单引号，也可以不加引号
print(p(&quot;div[class='div_cls1']&quot;))
&quot;&quot;&quot;
&lt;div class=&quot;div_cls1&quot;&gt;
        &lt;span&gt;嘿嘿嘿&lt;/span&gt;
    &lt;/div&gt;
&quot;&quot;&quot;
# 注意：div[class='div_cls1'] 和 div.div_cls1 不同
# 前者要求 class 属性必须为 div_cls1
# 而后者要求 class 属性只要包含 div_cls1 即可


# 这些属性除了 id、class 之外, 也可以是其它的任意属性（随便写一个也可以）
# 下面选择所有具有 href 属性的 a 标签
print(p(&quot;a[href]&quot;))
&quot;&quot;&quot;
&lt;a href=&quot;http://www.me.org/bento/1.png&quot;/&gt;
        &lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
&quot;&quot;&quot;

# 选择 href 等于某个 url 的 a 标签, 这里的 url 必须要使用引号包起来
print(p(&quot;a[href='http://www.me.org/bento/1.png']&quot;))
&quot;&quot;&quot;
&lt;a href=&quot;http://www.me.org/bento/1.png&quot;/&gt;
&quot;&quot;&quot;

# 还可以指定以 ... 开头
print(p(&quot;a[href^='http://www.me.org/image']&quot;))
&quot;&quot;&quot;
&lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
&quot;&quot;&quot;

# 指定以 ... 结尾
print(p(&quot;a[href$='2.png']&quot;))
&quot;&quot;&quot;
&lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
&quot;&quot;&quot;

# 包含 ...
print(p(&quot;a[href*='bento']&quot;))
&quot;&quot;&quot;
&lt;a href=&quot;http://www.me.org/bento/1.png&quot;/&gt;
&quot;&quot;&quot;
# 当然其它属性也可以，选择 class 包含 div_cls1 的 a 标签
# 此时 div[class*='div_cls1'] 和 div.div_cls1 是等价的
print(p(&quot;div[class*='div_cls1']&quot;) == p(&quot;div.div_cls1&quot;))
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<p><font color="blue"><strong>选择指定位置的标签</strong></font></p>
<pre><code class="language-python"># 先选择所有 class 包含 div_cls1、div_cls2 的标签
# 然后从它的儿子节点中选择所有的 p 标签
print(p(&quot;.div_cls1.div_cls2&gt;p&quot;))
&quot;&quot;&quot;
&lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
&quot;&quot;&quot;
# 先选择所有 class 包含 div_cls1、div_cls2 的标签
# 然后从它的儿子节点中选择所有 class 等于 p_cls1 的 p 标签
print(p(&quot;.div_cls1.div_cls2&gt;p[class='p_cls1']&quot;))
&quot;&quot;&quot;
&lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
&quot;&quot;&quot;

# 然后也可以按照位置进行选择，比如这里选择符合条件的第一个 p 标签
print(p(&quot;.div_cls1.div_cls2&gt;p:nth-child(1)&quot;))
&quot;&quot;&quot;
&lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
&quot;&quot;&quot;
# 选择符合条件的第二个 p 标签
print(p(&quot;.div_cls1.div_cls2&gt;p:nth-child(2)&quot;))
&quot;&quot;&quot;
&lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
&quot;&quot;&quot;
</code></pre>
<p><font color="blue"><strong>选择兄弟标签</strong></font></p>
<pre><code class="language-python"># 选择 class 包含 p_cls1 的所有 p 标签，然后选择它的兄弟标签
print(p(&quot;p.p_cls1&quot;).siblings())
&quot;&quot;&quot;
&lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;div class=&quot;div_cls3&quot;&gt;
            &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;/div&gt;
&quot;&quot;&quot;
</code></pre>
<p>以上就是一些常见的 CSS 选择器，在工作中一般是够用了。</p>
<h2 id="获取标签属性"><a class="header" href="#获取标签属性">获取标签属性</a></h2>
<p>基于 CSS 选择器，我们可以拿到指定的标签，然后就是获取属性了，比如获取文本。</p>
<pre><code class="language-python">print(p(&quot;p&quot;).text())
&quot;&quot;&quot;
S 老师不想你们为了她两败俱伤 高老师总能分享出好东西 我也退了，都怪我说了不该说的
&quot;&quot;&quot;
</code></pre>
<p>返回的是字符串，里面包含了所有的 p 标签里的文本。但这样我们就不知道，哪个文本是哪个 p 标签里面的了，因此我们可以进行遍历。</p>
<p>PyQuery 这个类继承 list，因为基于选择器筛选到的标签可能会有多个，因此提供了用于遍历的方法。但遍历得到依旧是 PyQuery 对象，只不过此时里面就只有一个标签了。</p>
<pre><code class="language-python"># 可以对选择的标签进行遍历
for tag in p(&quot;p&quot;).items():
    print(tag.text())
&quot;&quot;&quot;
S 老师不想你们为了她两败俱伤
高老师总能分享出好东西
我也退了，都怪我说了不该说的
&quot;&quot;&quot;
</code></pre>
<p>text 方法用于获取文本，至于其它属性则通过 attr 方法获取。</p>
<pre><code class="language-python">for tag in p(&quot;a&quot;).items():
    print(tag.attr(&quot;href&quot;))
&quot;&quot;&quot;
http://www.me.org/bento/1.png
http://www.me.org/image/2.png
&quot;&quot;&quot;

for tag in p(&quot;div&quot;).items():
    print(tag.attr(&quot;class&quot;))
&quot;&quot;&quot;
div_cls1 div_cls2
div_cls3
None
div_cls1
&quot;&quot;&quot;

# 遍历所有的标签，获取 id 的值
for tag in p(&quot;*&quot;).items():
    if tag.attr(&quot;id&quot;) is not None:
        print(tag.attr(&quot;id&quot;))
&quot;&quot;&quot;
six_six_six
&quot;&quot;&quot;

# 通过 attr 可以获取所有的属性，甚至自定义的也可以
</code></pre>
<p>是不是很方便呢？基于 CSS 选择器和 attr 方法，我们就能获取所有想要的属性。</p>
<h2 id="find-和-filter"><a class="header" href="#find-和-filter">find 和 filter</a></h2>
<p>PyQuery 对象还有两个很重要的方法，分别是 find 和 filter。</p>
<p>先来看看 find：</p>
<pre><code class="language-python"># p(&quot;div .div_cls3 p&quot;) 等价于 p.find(&quot;div&quot;).find(&quot;.div_cls3&quot;).find(&quot;p&quot;)
# 或者也等价于 p.find(&quot;div&quot;).find(&quot;.div_cls3 p&quot;)
# 也等价于 p.find(&quot;div .div_cls3&quot;).find(&quot;p&quot;)
print(p(&quot;div .div_cls3 p&quot;) ==
      p.find(&quot;div&quot;).find(&quot;.div_cls3&quot;).find(&quot;p&quot;) ==
      p.find(&quot;div&quot;).find(&quot;.div_cls3 p&quot;) ==
      p.find(&quot;div .div_cls3&quot;).find(&quot;p&quot;))
&quot;&quot;&quot;
True
&quot;&quot;&quot;

# 相信你应该明白 find 方法是做什么的了，它是基于指定条件继续向内筛选
# 比如我们成功筛选了指定的标签
tag = p(&quot;div .div_cls3&quot;)
# 这时候想在 tag 的基础上继续获取它内部的 p 标签，那么可以调用 find
print(tag.find(&quot;p&quot;))
&quot;&quot;&quot;
&lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
&quot;&quot;&quot;
</code></pre>
<p>tag.find 是在 tag 的基础上继续向内筛选，而 tag.filter 则是对 tag 进行过滤。</p>
<pre><code class="language-python">tag = p(&quot;div p&quot;)
# 在 tag 的基础上向内筛选，获取 class 包含 p_cls1 的标签
# 但 div p 内部没有 class 包含 p_cls1 的标签
print(tag.find(&quot;.p_cls1&quot;))
&quot;&quot;&quot;
&quot;&quot;&quot;
# 对 tag 进行过滤，从已获取的 tag 中过滤出 class 包含 p_cls1 的标签
print(tag.filter(&quot;.p_cls1&quot;))
&quot;&quot;&quot;
&lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
&quot;&quot;&quot;
</code></pre>
<p>所以当你筛选了指定的 div 之后，你想从它的内部继续筛选，那么就使用 find 方法。如果你想按照指定条件对 div 进行过滤，那么就使用 filter。</p>
<p>另外 filter 还有一个用法，就是可以根据文本进行过滤。</p>
<pre><code class="language-python">print(p(&quot;p&quot;))
&quot;&quot;&quot;
&lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
        &lt;p id=&quot;six_six_six&quot;&gt;
                我也退了，都怪我说了不该说的
            &lt;/p&gt;
        &lt;p&gt;
            &lt;a href=&quot;http://www.me.org/image/2.png&quot;/&gt;
        &lt;/p&gt;
&quot;&quot;&quot;
# 对筛选到 p 标签进行过滤，只保留文本包含 &quot;老师&quot; 的 p 标签
print(
    p(&quot;p&quot;).filter(lambda _, this: &quot;老师&quot; in PyQuery(this).text())
)
&quot;&quot;&quot;
&lt;p&gt;S 老师不想你们为了她两败俱伤&lt;/p&gt;
        &lt;p class=&quot;p_cls1&quot;&gt;高老师总能分享出好东西&lt;/p&gt;
&quot;&quot;&quot;
</code></pre>
<p>以上就是 find 和 filter 的用法，当你的解析需求不复杂时，直接调用 PyQuery 对象即可，否则可以搭配这两个方法。</p>
<h2 id="小结-11"><a class="header" href="#小结-11">小结</a></h2>
<p>总的来说，pyquery 还是相当方便的，相比 bs4 多了更多的灵活性，而且速度也更快一些。</p>
<p>当然 pyquery 还有一些功能我们没有说，比如追加节点等等，但这些不常用，所以不再赘述。因为我们只是解析 HTML，能基于选择器获取想要的标签以及属性就足够了。</p>
<p>虽然 pyquery 是仿照 jquery 设计的，但我们不会像 jquery 操作 DOM 那样，对节点进行新增修改啥的。我们要做的只有查询，基于选择器获取指定标签，并且选择器也不止我们上面介绍的那些，不过基本上够用了。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-16"><a class="header" href="#楔子-16">楔子</a></h2>
<p>本次来分享一个关于验证码的知识，在登录网站时，为了确保是人在操作，一般会要求输入图片上的验证码。那么这个验证码要怎么生成呢？以及在做爬虫的时候，怎么用机器来识别呢？</p>
<p>围绕着这两个问题，我们开始今天的内容。</p>
<h2 id="生成验证码"><a class="header" href="#生成验证码">生成验证码</a></h2>
<p>所谓验证码就是一张图片，图片上有一些数字和字母。所以我们只要生成一张图片，然后在图片上写一些内容即可。</p>
<p>使用 PIL 模块可以非常方便做到这一点，没有安装的话，需要执行 pip install pillow。</p>
<pre><code class="language-python">from random import randint, sample
import string
from PIL import Image, ImageFont, ImageDraw


# 随机生成画板颜色
bg_color = randint(0, 255), randint(0, 255), randint(0, 255)
# 定义画板的宽和高
width, height = 200, 80
# 创建画板对象
im = Image.new(&quot;RGB&quot;, (width, height), bg_color)
# 创建画笔对象，接收画板对象
# 这样一来，画笔所画的内容都会显示在画板上
draw = ImageDraw.Draw(im)
# 绘制噪点，噪点的数量一般为 width * height * 0.1
for _ in range(int(width * height * 0.1)):
    # 噪点的横纵坐标
    point_pos = randint(0, width), randint(0, height)
    # 噪点的颜色，尽量也是随机的
    point_color = randint(0, 255), randint(0, 255), randint(0, 255)
    # 绘制
    draw.point(point_pos, point_color)

# 查看绘制的图片
im.show()
</code></pre>
<p>执行代码，会生成图片，我们看一下长什么样子。</p>
<p><img src="%E7%94%9F%E6%88%90%E5%B9%B6%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/./1.png" alt="" /></p>
<p>可以看到噪点此刻绘制出来了，再为其绘制几条直线和曲线。</p>
<pre><code class="language-python"># 直线的长度要从画板的左边到画板的右边
# 因此左端点要在画板左侧上下变化，右端点要在画板右侧上下变化
for _ in range(5):
    left_pos = 0, randint(0, height)
    right_pos = width, randint(0, height)
    line_color = randint(0, 255), randint(0, 255), randint(0, 255)
    # 绘制直线
    draw.line([left_pos, right_pos], line_color)

# 绘制曲线，这里绘制的是一个超出画板的大圆
# 这样在画板上显示的部分只是大圆的一条弧，看起来就像是一条曲线
for _ in range(5):
    left_pos = (-100, -100)
    right_pos = (width * 5, randint(0, height))
    arc_color = randint(0, 255), randint(0, 255), randint(0, 255)
    draw.arc([left_pos, right_pos], 0, 360, arc_color)

# 查看一下，绘制的图形长什么样子
im.show()
</code></pre>
<p>直线和曲线也绘制好了，看下效果。</p>
<p><img src="%E7%94%9F%E6%88%90%E5%B9%B6%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/./2.png" alt="" /></p>
<p>效果还是不错的，最后我们来绘制文字。</p>
<pre><code class="language-python"># 验证码是由文字和数字组成，先来获取所有的数字和字母
alpha_digit = string.ascii_letters + string.digits
# 验证码一般是四个字符，从里面随机选取4个
verify_code = sample(alpha_digit, 4)
# 生成字体对象
font = ImageFont.truetype(&quot;/System/Library/Fonts/Courier.ttc&quot;, 40)
# 为四个字符创建四种颜色
text_color = [(randint(0, 255), randint(0, 255), randint(0, 255))
              for _ in range(4)]
# 绘制文字
# 注意：坐标加上字体的宽度不要超出画板，否则显示不全
draw.text((10, 10), verify_code[0], fill=text_color[0], font=font)
draw.text((60, 25), verify_code[1], fill=text_color[1], font=font)
draw.text((110, 15), verify_code[2], fill=text_color[2], font=font)
draw.text((150, 25), verify_code[3], fill=text_color[3], font=font)

# 绘制完成，最后再查看一下
im.show()
</code></pre>
<p>到此我们的验证码就生成完毕了，那么效果如何呢？我们查看一下。</p>
<p><img src="%E7%94%9F%E6%88%90%E5%B9%B6%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/./3.png" alt="" /></p>
<p>整体来看还凑合，你也可以对背景色，以及文字的颜色进行调整。如果觉得背景里的噪点、线段不太好，也可以将它们去掉。</p>
<p>最后再来说说保存，代码中的 im.show() 实际上是打开了一个临时文件，我们如何将它保存下来呢？</p>
<pre><code class="language-python"># 可以输入一个路径，然后保存成指定的文件
# 不过更常见的做法是拿到图片的字节流，然后直接对字节流进行渲染
from io import BytesIO
buf = BytesIO()
im.save(buf, &quot;png&quot;)
# 此时图片内容就保存在了 buf 中
print(buf.getvalue()[: 6] == b&quot;\x89PNG\r\n&quot;)  # True
</code></pre>
<p>以上就是绘制验证码的过程，代码是分块展示的，你可以将它们合在一起，测试一下。</p>
<h2 id="识别验证码"><a class="header" href="#识别验证码">识别验证码</a></h2>
<p>说完了生成验证码，那么如何识别验证码呢？Python 有一个第三方库 ddddocr，可以帮我们识别，直接 pip install ddddocr 安装即可。</p>
<p>我们目前已经生成了一张验证码：</p>
<p><img src="%E7%94%9F%E6%88%90%E5%B9%B6%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81/./4.png" alt="" /></p>
<p>这里补充一句，我们上面生成的验证码图片，在颜色上设计的不太好，因为背景色和文字颜色都是随机的，这就导致当颜色相近时，看不清文字内容。</p>
<p>而当文字颜色和背景色比较接近时，ddddocr 识别的准确率就会降低很多，特别是背景中还有噪点和线段作为干扰。不过一般来说网站的验证码图片都是经过设计的，背景色和文字颜色区别还是比较大的，所以不用担心。</p>
<p>我们测试一下：</p>
<pre><code class="language-python">import ddddocr

with open(&quot;code.png&quot;, &quot;rb&quot;) as f:
    data = f.read()

# show_ad 默认为 True，执行时会输出一些广告，我们不让它输出
ocr = ddddocr.DdddOcr(show_ad=False)
code = ocr.classification(data)
print(code)  # 7abf
</code></pre>
<p>结果没有问题，识别出来了。</p>
<p>以上就是关于图片验证码的一些内容。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
