<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python 实用技巧</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="如何优雅地遍历可迭代对象？/doc.html">如何优雅地遍历可迭代对象？</a></li><li class="chapter-item expanded "><a href="解密可迭代对象的排序问题/doc.html">解密可迭代对象的排序问题</a></li><li class="chapter-item expanded "><a href="通过 TOP K 问题，探究堆和优先队列的秘密/doc.html">通过 TOP K 问题，探究堆和优先队列的秘密</a></li><li class="chapter-item expanded "><a href="如何优雅地对数据进行分组？/doc.html">如何优雅地对数据进行分组？</a></li><li class="chapter-item expanded "><a href="全方位解析 f-string/doc.html">全方位解析 f-string</a></li><li class="chapter-item expanded "><a href="最好的日期处理库：pendulum/doc.html">最好的日期处理库：pendulum</a></li><li class="chapter-item expanded "><a href="你知道创建模块都有哪些方式吗？/doc.html">你知道创建模块都有哪些方式吗？</a></li><li class="chapter-item expanded "><a href="exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？/doc.html">exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？</a></li><li class="chapter-item expanded "><a href="文件处理的一些最佳实践/doc.html">文件处理的一些最佳实践</a></li><li class="chapter-item expanded "><a href="使用 os 模块更高效地读写文件/doc.html">使用 os 模块更高效地读写文件</a></li><li class="chapter-item expanded "><a href="将文件映射到内存，像数组一样访问/doc.html">将文件映射到内存，像数组一样访问</a></li><li class="chapter-item expanded "><a href="使用 psutil 获取硬件、网络以及进程信息/doc.html">使用 psutil 获取硬件、网络以及进程信息</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 实用技巧</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/python-tech" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>本篇文章来介绍如何优雅地遍历可迭代对象，举个例子：</p>
<pre><code class="language-Python">data = [&quot;古明地觉&quot;, &quot;芙兰朵露&quot;, &quot;雾雨魔理沙&quot;]

for item in data:
    print(item)
&quot;&quot;&quot;
古明地觉
芙兰朵露
雾雨魔理沙
&quot;&quot;&quot; 
</code></pre>
<p>遍历一个可迭代对象，可以使用 for 循环，每次会从可迭代对象中迭代出一个元素。当迭代完毕时，抛出 StopIteration，然后 for 循环捕获，终止循环。</p>
<p>当然，可迭代对象对内部的元素没有要求，可以指向任意的对象。</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

for item in data:
    print(item)
&quot;&quot;&quot;
('古明地觉', '女', '地灵殿')
('琪露诺', '女', '雾之湖')
('芙兰朵露', '女', '红魔馆')
&quot;&quot;&quot;
</code></pre>
<p>此时迭代出来的元素就是一个个的元组，如果想获取元组里面的元素，那么可以通过索引的方式获取，比如 item[0]。但是基于索引的话，代码可读性不高，于是你可能会这么做。</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

for item in data:
    name, gender, address = item
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>通过这种方式，代码的可读性变得更高了一些。但实际上，这段代码有点冗余，我们可以简化一下：</p>
<pre><code class="language-Python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

# name, gender, address 周围的小括号可以省略
for (name, gender, address) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>for 后面可以跟一个循环变量，也可以跟多个循环变量组成的元组。如果 for 后面跟的是一个普通的变量，那么可迭代对象里面的元素迭代出来之后会直接赋值给该变量。</p>
<p>如果 for 后面跟的是多个变量组成的元组，那么可迭代对象里迭代出来的元素必须仍是一个可迭代对象，并且迭代出来的每一个可迭代对象里面的元素个数，都必须和 for 后面的元组里的变量个数相同。最后进行解包，按照顺序将值分别赋给 for 后面的变量，这里就是 name, gender, address。</p>
<p>那么问题来了，这两种迭代方式有什么不同呢？</p>
<pre><code class="language-Python"># 第一种迭代方式
for item in data:
    name, gender, address = item
    print(name, gender, address)

# 第二种迭代方式
for name, gender, address in data:
    print(name, gender, address)
</code></pre>
<p>我们看一下字节码就清楚了，字节码面前没有秘密：</p>
<pre><code class="language-Python"> # 第一种迭代方式对应的字节码
 
 # 加载变量 data
 0 LOAD_NAME                0 (data)
 # 获取可迭代对象对应的迭代器
 2 GET_ITER
 # 将元素迭代出来
 4 FOR_ITER                13 (to 32)
 # 赋值给变量 item
 6 STORE_NAME               1 (item)
 # 加载变量 item，item 一定也指向一个可迭代对象
 8 LOAD_NAME                1 (item)
 # 解包
10 UNPACK_SEQUENCE          3
 # 按照顺序将里面的值赋给变量 name, gender, address
12 STORE_NAME               2 (name)
14 STORE_NAME               3 (gender)
16 STORE_NAME               4 (address)


 # 第二种迭代方式对应的字节码

 0 LOAD_NAME                0 (data)
 2 GET_ITER
 4 FOR_ITER                11 (to 28)
 6 UNPACK_SEQUENCE          3
 # 前面三条字节码没有区别
 # 但是这里将元素迭代出来之后，直接就解包了
 8 STORE_NAME               1 (name)
10 STORE_NAME               2 (gender)
12 STORE_NAME               3 (address)
</code></pre>
<p>所以这两种方式没有本质上的区别，只是第一种方式在将元素迭代出来之后需要单独用一个变量保存，然后加载变量，最后进行解包；而第二种方式在将元素迭代出来之后，直接就解包了。因此虽然效果是一样的，但是第二种方式要稍微快一点点，因为它少执行了两条指令。</p>
<p>另外，还有一种特殊情况：</p>
<pre><code class="language-python">data = [[1], [2], [3], [4]]
# for 后面是一个变量
for item in data:
    print(item)
&quot;&quot;&quot;
[1]
[2]
[3]
[4]
&quot;&quot;&quot;    

# for 后面是包含一个变量的元组
for item, in data:
    print(item)
&quot;&quot;&quot;
1
2
3
4
&quot;&quot;&quot;
</code></pre>
<p>由于 data 里面的元素也是列表，所以 for 后面仍然可以跟一个元组，迭代的时候会自动解包。只是当元组里面只有一个元素的时候，需要在第一个元素的后面加上一个逗号，什么意思呢？举个例子：</p>
<pre><code class="language-python">data = [[1], [2], [3], [4]]
# 这里虽然给 item 加上了括号，但它仍然不是一个元组
for (item) in data:
    print(item)
&quot;&quot;&quot;
[1]
[2]
[3]
[4]
&quot;&quot;&quot;    

# 如果元组里面只有一个元素
# 那么第一个元素后面必须要有一个逗号
# 否则解释器会认为这个括号只是起到一个限定优先级的作用
for (item,) in data:
    print(item)
&quot;&quot;&quot;
1
2
3
4
&quot;&quot;&quot;

# 再举个栗子
a, b, c = 3, 2, 4
# 此时 a + b 周围的括号只是起到了一个限定作用
# 用于提高 a + b 的优先级
print((a + b) * c)  # 20

# 但如果是这样的话，就不同了
# 此时和 c 相乘的不再是整数，而是一个元组
print((a + b,) * c)  # (5, 5, 5, 5)
</code></pre>
<p>当然啦，变量赋值也是同样的道理，因为每一次 for 循环本质上也是一次变量赋值。</p>
<pre><code class="language-Python">numbers = (99, 96, 100)

a, b, c = numbers
print(a, b, c)  # 99 96 100

# 也可以显式地使用括号括起来
(a, b, c) = (99, 96, 100)
print(a, b, c)  # 99 96 100

# 如果变量名字比较长，那么还可以换行写
(
    a,
    b,
    c
) = numbers
print(a, b, c)  # 99 96 100

# 当可迭代对象只包含一个元素时，也是同理
numbers = (88,)
(a,) = numbers
print(a)  # 88
# 赋值的时候，元组周围的小括号可以不要 
a, = numbers
print(a)  # 88
</code></pre>
<p>最后还有一个神奇的地方，在赋值的时候，多个变量不仅可以组成一个元组，还可以组成一个列表，举个例子：</p>
<pre><code class="language-python">numbers = (99, 96, 100)

[a, b, c] = numbers
print(a, b, c)  # 99 96 100

# 如果是列表的话，当只有一个元素的时候，就不需要逗号了
numbers = [88]
[a] = numbers
print(a)  # 88

# for 循环的时候也是同理
data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]
for [name, gender, place] in data:
    print(name, gender, place)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>当然啦，无论多个变量组成的是元组还是列表，字节码都没有区别。只是我们更习惯写成元组，并且将元组周围的小括号省略掉。</p>
<p>另外可迭代对象也是可以嵌套的，举个例子：</p>
<pre><code class="language-Python">data = [(&quot;古明地觉&quot;, (&quot;女&quot;, &quot;地灵殿&quot;)),
        (&quot;琪露诺&quot;, (&quot;女&quot;, &quot;雾之湖&quot;)),
        (&quot;芙兰朵露&quot;, (&quot;女&quot;, &quot;红魔馆&quot;))]

# 每个可迭代对象内部只有两个元素，所以在迭代的时候
# for 后面的元组或列表里面也只能有两个变量
for name, gender_address in data:
    print(name, gender_address)
&quot;&quot;&quot;
古明地觉 ('女', '地灵殿')
琪露诺 ('女', '雾之湖')
芙兰朵露 ('女', '红魔馆')
&quot;&quot;&quot;

# 于是聪明的你可能想到了
for name, (gender, address) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

# 使用列表也是可以的
for [name, (gender, address)] in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;    

# 以下几种方式也是可以的
&quot;&quot;&quot;
for [name, [gender, address]] in data:
    print(name, gender, address)

for (name, [gender, address]) in data:
    print(name, gender, address)

for (name, (gender, address)) in data:
    print(name, gender, address)
&quot;&quot;&quot;
</code></pre>
<p>并且嵌套的可迭代对象的数量也是任意的，举个例子：</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, (&quot;女&quot;,), (&quot;地灵殿&quot;,)),
        (&quot;琪露诺&quot;, (&quot;女&quot;,), (&quot;雾之湖&quot;,)),
        (&quot;芙兰朵露&quot;, (&quot;女&quot;,), (&quot;红魔馆&quot;,))]

for name, gender, address in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 ('女',) ('地灵殿',)
琪露诺 ('女',) ('雾之湖',)
芙兰朵露 ('女',) ('红魔馆',)
&quot;&quot;&quot;

for name, [gender], [address] in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

for name, (gender,), (address,) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

# 变量赋值也是同理
numbers = [[[3]]]
a = numbers
print(a)  # [[[3]]]

a, = numbers
print(a)  # [[3]]

((a,),) = numbers
print(a)  # [3]

(((a,),),) = numbers
print(a)  # 3
[[[a]]] = numbers
print(a)  # 3

# 再来一个恶心人的，当然啦，这个做法没啥意义
# 只是想表明可迭代对象之间的嵌套是非常自由的
numbers = [[[3], [[[[4]], 5], 6]], 7]
(((a,), ((((b,),), c), d)), e) = numbers
print(a, b, c, d, e)  # 3 4 5 6 7
</code></pre>
<p>最后再来介绍一个高级特性，不过介绍之前先来看看上面的迭代方式有什么缺陷：</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
</code></pre>
<p>如果是这种情况的话，那么 for 循环在遍历的时候，要使用几个变量去遍历呢？两个、三个、还是四个呢？我们先用三个变量看看：</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for a, b, c in data:
    print(a, b, c)
&quot;&quot;&quot;
Traceback (most recent call last):
  File &quot;...&quot;, line 6, in &lt;module&gt;
    for a, b, c in data:
ValueError: too many values to unpack (expected 3)
&quot;&quot;&quot;
</code></pre>
<p>很明显它报错了，所以这种方式有一个缺陷，就是它除了要求可迭代对象里面的元素也是可迭代对象之外，还要满足它们内部的值的个数都相等，并且个数已知。</p>
<p>但是问题来了，如果我在遍历的时候，只想拿到里面的第一个值和最后一个值，该怎么办呢？</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for item in data:
    print(item[0], item[-1])
&quot;&quot;&quot;
1 4
5 6
7 9
&quot;&quot;&quot;
</code></pre>
<p>首先上面这种方式肯定是可以的，但还有没有另外的方式呢？显然是有的。</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for first, *middle, last in data:
    print(first, middle, last)
&quot;&quot;&quot;
1 [2, 3] 4
5 [] 6
7 [8] 9
&quot;&quot;&quot;
</code></pre>
<p>在迭代的时候，第一个值会赋给 first，这没有问题。然后是 middle，它的前面加上了一个 *，那么 middle 就会变成一个列表，这个类似正则的贪婪匹配，会不断地匹配值。而 *middle 后面还有一个 last，因此 *middle 就会匹配到倒数第二个值为止，最后一个值留给 last。</p>
<p>我们再举几个例子：</p>
<pre><code class="language-python">data = [
    (1, 2, 3, 4, 5),
    (6, 7, 8, 9, 10),
    (11, 12, 13, 14, 15)
]

# 第 1 个值给 a、剩余的 4 个值给 b
for a, *b in data:
    print(a, b)
&quot;&quot;&quot;
1 [2, 3, 4, 5]
6 [7, 8, 9, 10]
11 [12, 13, 14, 15]
&quot;&quot;&quot;

# 第 1 个值给 a、第 2 个值给 b，剩余的 3 个值给 c
for a, b, *c in data:
    print(a, b, c)
&quot;&quot;&quot;
1 2 [3, 4, 5]
6 7 [8, 9, 10]
11 12 [13, 14, 15]
&quot;&quot;&quot;

# 第 1 个值给 a、第 2 个值给 b
# 倒数第 1 个值给 d，剩余的值给 c
for a, b, *c, d in data:
    print(a, b, c, d)
&quot;&quot;&quot;
1 2 [3, 4] 5
6 7 [8, 9] 10
11 12 [13, 14] 15
&quot;&quot;&quot;

# 倒数第 1 个值给 b，前面的值给 a
for *a, b in data:
    print(a, b)
&quot;&quot;&quot;
[1, 2, 3, 4] 5
[6, 7, 8, 9] 10
[11, 12, 13, 14] 15
&quot;&quot;&quot;    

# 每次迭代的元素内部只有 5 个值，所以 b 是一个空列表
for a, *b, c, d, e, f in data:
    print(a, b, c, d, e, f)
&quot;&quot;&quot;
1 [] 2 3 4 5
6 [] 7 8 9 10
11 [] 12 13 14 15
&quot;&quot;&quot;

# 所有的值都给 a，但是需要注意：
# 如果出现了 *，那么 for 后面的变量必须组成一个元组或列表
# 所以如果是 for *a in data: 会报出语法错误
# 必须是 for *a, in data: 或者 for [*a] in data:
for *a, in data:
    print(a)
&quot;&quot;&quot;
[1, 2, 3, 4, 5]
[6, 7, 8, 9, 10]
[11, 12, 13, 14, 15]
&quot;&quot;&quot;    
</code></pre>
<p>另外还有一个约定或者说规范，如果在遍历的时候，有一部分的值我们不需要，那么可以使用下划线代替。比如我们只需要第一个值和倒数第二个值，那么遍历的时候就可以像下面这么做：</p>
<pre><code class="language-python">for a, *_, b, _ in data:
    pass
</code></pre>
<p>当然啦，* 不仅可以在 for 循环的时候用，普通的变量赋值也是可以使用的，一样的道理。</p>
<blockquote>
<p>在赋值的时候， * 最多只能出现一次，否则会报出语法错误。</p>
</blockquote>
<p>以上就是可迭代对象的遍历，是不是很有趣呢？</p>
<div style="break-before: page; page-break-before: always;"></div><p>假设有一个可迭代对象，现在想要对它内部的元素进行排序，我们一般会使用内置函数 sorted，举个例子：</p>
<pre><code class="language-python">data = (3, 4, 1, 2, 5)
print(sorted(data))  # [1, 2, 3, 4, 5]

data = (3.14, 2, 1.75)
print(sorted(data))  # [1.75, 2, 3.14]

data = [&quot;satori&quot;, &quot;koishi&quot;, &quot;marisa&quot;]
print(sorted(data))  # ['koishi', 'marisa', 'satori']
</code></pre>
<p>如果可迭代对象里面的元素是数值，那么会按照数值的大小进行排序；如果是字符串，那么会按照字符串的字典序进行排序，并且 sorted 函数会返回一个新的列表。</p>
<blockquote>
<p>sorted 函数默认是升序排序，如果想要降序，那么可以传递一个关键字参数 reverse=True。</p>
</blockquote>
<pre><code class="language-python">data = [
    (3, 4), (3, 1), (2, 3)
]
print(sorted(data))  # [(2, 3), (3, 1), (3, 4)]
</code></pre>
<p>如果可迭代对象里面都是元组的话，也是可以的，元组在比较大小的时候，会先按照元组的第一个元素比较；第一个元素相等，再按照第二个元素比较，依次类推。</p>
<p>因此在使用 sorted 函数的时候，可迭代对象内部的元素，要满足彼此之间都是可比较的，否则报错。</p>
<pre><code class="language-Python">data = [123, 456, &quot;123&quot;]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'str' and 'int'

data = [{&quot;a&quot;: 1}, {&quot;b&quot;: 2}, {&quot;c&quot;: 3}]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'

</code></pre>
<p>我们看到，由于 data 里面存在不可比较的元素，因此报错了。那么问题来了，假设有这样一个列表：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 字典是不可比较大小的，因此直接使用 sorted 会报错
# 我们希望按照字典内部的 &quot;age&quot; 字段进行排序，得到下面的结果

[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
</code></pre>
<p>如果是你的话，你会怎么做呢？很明显，我们将每个 &quot;age&quot; 字段的值取出来，和所在的字典拼接成一个元组（或列表）不就行了，然后对元组进行排序，举个例子：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 由于 data 内部的元素是一个元组
# 所以排序的时候会按照元组的第一个元素排序
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16}), 
 (17, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时顺序就排好了，然后再把字典取出来
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>显然这样就实现了基于字典内部某个字段的值，来对字典进行排序，只不过上面的代码还有一点点缺陷。我们说元组在比较的时候会先比较第一个元素，第一个元素相同的话，会比较第二个元素。</p>
<p>而我们上面 data 里面的元组，由于第一个元素都不相等，所以直接就比较出来了。但如果是下面这种情况呢？</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (16, {'name': 'marisa', 'age': 16}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;
try:
    sorted_data = sorted(data)
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'
</code></pre>
<p>此时就报错了，因为第二个元组和第三个元组内部的第一个元素都是 16，所以第一个元素相等，那么会比较第二个元素。而第二个元素是字典，字典之间无法比较，所以报错了。</p>
<p>但我们只是希望让字典的 &quot;age&quot; 字段的值参与比较，如果相等的话，那么就不用再比较了，相对顺序就保持现状。所以我们可以这么做：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 将索引也加进去
data = [(d[&quot;age&quot;], i, d) for i, d in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, {'name': 'satori', 'age': 17}), 
 (16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 如果 &quot;age&quot; 字段的值、或者说元组的第一个元素相等
# 那么就按照索引比较，而索引一定是不重复的
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16}), 
 (17, 0, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时就成功排好序了，并且 &quot;age&quot; 字段的值相等的字典之间的相对顺序
# 在排序之前和排序之后都保持一致，这正是我们想要的结果
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>再比如，我们想要对元组排序，但我们希望按照元组的第二个元素进行排序：</p>
<pre><code class="language-python">data = [(&quot;satori&quot;, 17), 
        (&quot;marisa&quot;, 15), 
        (&quot;koishi&quot;, 16)]

data = [(item[1], i, item) for i, item in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, ('satori', 17)), 
 (15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16))]
&quot;&quot;&quot;

sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16)), 
 (17, 0, ('satori', 17))]
&quot;&quot;&quot;

sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[('marisa', 15), 
 ('koishi', 16), 
 ('satori', 17)]
&quot;&quot;&quot;
</code></pre>
<p>所以当可迭代对象内部的元素无法进行排序，或者说我们不希望基于整个元素进行排序，那么就可以使用上面这个方法。将用来排序的值、索引、原始值放在一个元组里面，然后对元组排序，排完了再把最后一个值（也就是原始值）筛出来即可。</p>
<p>或者我们还可以做的再复杂一些：</p>
<pre><code class="language-python">data = [-3, -2, 3, 2, -1, 1, 0]
&quot;&quot;&quot;
对 data 进行排序，排序规则如下
先按照内部元素的正负进行排序，排序之后正数在后面
如果符号一样，再按照绝对值的大小进行排序
也就是说，排完之后是下面这样一个结果

[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

# 如果只按照正负排序
data1 = [(n &gt;= 0, i, n) for i, n in enumerate(data)]
sorted_data = sorted(data1)
print(sorted_data)
&quot;&quot;&quot;
[(False, 0, -3), (False, 1, -2), (False, 4, -1), 
 (True, 2, 3), (True, 3, 2), (True, 5, 1), (True, 6, 0)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 此时正数就排在了负数的后面
print(sorted_data)
&quot;&quot;&quot;
[-3, -2, -1, 3, 2, 1, 0]
&quot;&quot;&quot;

# 如果只按照绝对值排序
data2 = [(abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data2)
print(sorted_data)
&quot;&quot;&quot;
[(0, 6, 0), (1, 4, -1), (1, 5, 1), 
 (2, 1, -2), (2, 3, 2), (3, 0, -3), (3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[0, -1, 1, -2, 2, -3, 3]
&quot;&quot;&quot;

# 同时按照正负和绝对值排序
data3 = [(n &gt;= 0, abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data3)
print(sorted_data)
&quot;&quot;&quot;
[(False, 1, 4, -1), (False, 2, 1, -2), 
 (False, 3, 0, -3), (True, 0, 6, 0), 
 (True, 1, 5, 1), (True, 2, 3, 2), (True, 3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 大功告成
print(sorted_data)
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;
</code></pre>
<p>那么接下来，我们就可以封装一个属于我们自己的 my_sorted 函数了。</p>
<pre><code class="language-python">def my_sorted(data, *, key=None, reverse=False):
    &quot;&quot;&quot;
    :paramdata: 可迭代对象
    :paramkey: callable
    :paramreverse: 是否逆序
    :return:
    &quot;&quot;&quot;
    if key is not None:
        data = [(key(item), i, item) for i, item in enumerate(data)]
    sorted_data = sorted(data)
    if key is not None:
        sorted_data = [item[-1] for item in sorted_data]
    if reverse:
        sorted_data = sorted_data[:: -1]
    return sorted_data

# 下面来测试一下
data = [-3, -2 ,3, 2, -1, 1, 0]
print(my_sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(my_sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>结果一切正常，当然啦，实际工作中我们肯定不会专门封装一个 my_sorted 函数，因为内置的 sorted 已经包含了我们上面的所有功能。</p>
<pre><code class="language-python">data = [-3, -2 ,3, 2, -1, 1, 0]
print(sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>内置函数 sorted 除了接收一个可迭代对象之外，还接收两个关键字参数 key 和 reverse，含义就是我们介绍的那样。在 sorted 的内部，它的处理方式和我们上面是一致的，如果指定了 key，也就是自定义排序规则，那么在底层会将可迭代对象内部的值封装成元组，然后对元组排序。排完序之后，再将元组的最后一个值、也就是原始值取出来，并返回。</p>
<p>所以这就是 sorted 函数的全部秘密，它里面的参数 key 赋予了 sorted 函数强大的能力，有了这个参数，我们想怎么排序，就怎么排序。</p>
<pre><code class="language-python">class A:
    
    def __init__(self, a):
        self.a = a
    
    def __repr__(self):
        return f&quot;self.a = {self.a}&quot;
    
    def __hash__(self):
        return self.a
    
a1 = A(1)
a2 = A(2)
a3 = A(3)
a4 = A(4)

data = [a2, a3, a1, a4]
print(data)
&quot;&quot;&quot;
[self.a = 2, self.a = 3, self.a = 1, self.a = 4]
&quot;&quot;&quot;

# A 的实例对象无法比较，我们希望按照内部的属性 a 进行比较
print(sorted(data, key=lambda x: x.a))
&quot;&quot;&quot;
[self.a = 1, self.a = 2, self.a = 3, self.a = 4]
&quot;&quot;&quot;

# 或者按照哈希值比较，此时仍相当于按照 self.a 比较
print(sorted(data, key=lambda x: hash(x), reverse=True))
&quot;&quot;&quot;
[self.a = 4, self.a = 3, self.a = 2, self.a = 1]
&quot;&quot;&quot;
</code></pre>
<p>因此我们想怎么比就怎么比，参数 key 赋予了我们极大的自由，key 接收一个函数（当然其它 callable 也可以，但大部分场景都是匿名函数），此函数接收一个参数，该参数会对应可迭代对象里面的每一个元素。而函数的返回值，决定了 sorted 的比较逻辑。</p>
<p>比如，我们不光可以对元组、列表排序，还可以对字典内部的键值对排序。</p>
<pre><code class="language-Python">data = {&quot;satori&quot;: 17, &quot;marisa&quot;: 15, &quot;koishi&quot;: 16}

# 对字典调用 sorted，针对的是字典里面的键，所以返回的也是键
print(sorted(data))  # ['koishi', 'marisa', 'satori']

# 匿名函数里面的参数 x 对应可迭代对象里面的每一个元素
# 这里就是字典的键，函数返回 d[x] 表示按照值来排序，但排序之后得到的仍然是键
print(sorted(data, key=lambda x: data[x]))  # ['marisa', 'koishi', 'satori']

# 此时的 x 就是键值对组成的元组，这里按照值来排序
print(
    sorted(data.items(), key=lambda x: x[1])
)  # [('marisa', 15), ('koishi', 16), ('satori', 17)]
</code></pre>
<p>当然啦，还有很多其它排序方式，比如按照数量排序：</p>
<pre><code class="language-python">string = &quot;a&quot; * 4 + &quot;b&quot; * 3 + &quot;c&quot; * 5 + &quot;d&quot; * 2
data = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

print(
    sorted(data, key=lambda x: string.count(x))
)  # ['d', 'b', 'a', 'c']
</code></pre>
<p>最后再来介绍一个知识点，sorted 在对可迭代对象内部的元素进行排序的时候，肯定要有大小比较的过程，这是肯定的。但问题是比较的时候，用的什么方式呢？举个例子，我想判断 a 和 b 的大小关系（假设不相等），无论是执行 a &gt; b 还是 a &lt; b，根据结果我都能得出它们谁大谁小。</p>
<p>而 sorted 在比较的时候是怎么做的呢，这里给出结论：每次在比较两个对象的时候，都会调用左边对象的 __lt__ 方法。其实关于 sorted 内部是怎么比的，我们无需太关注，但之所以说这一点，是因为在极端场景下可能会遇到。举个例子：</p>
<pre><code class="language-python"># 第一个元素表示 &quot;商品名称&quot;
# 第二个元素表示 &quot;销量&quot;
data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

# 我们需要先按照 &quot;销量&quot; 的大小降序排序
# 如果 &quot;销量&quot; 相同，则按照 &quot;商品名称&quot; 的字典序升序排序
# 该怎么做呢？

# 由于一部分升序，一部分降序
# 我们无法直接使用 reverse 参数，所以就默认按照升序排
# 虽然 &quot;销量&quot; 要求降序排，但可以对它取反
# 这样值越大，取反之后的值就越小，从而实现降序效果
print(
    sorted(data, key=lambda x: (~x[1], x[0]))
)
&quot;&quot;&quot;
[('apple', 200), 
 ('banana', 200), 
 ('cherry', 150), 
 ('orange', 150), 
 ('peach', 150)]
&quot;&quot;&quot;
</code></pre>
<p>可能有小伙伴觉得这也没什么难的，那么我们将问题稍微换一下。如果让你先按照 &quot;销量&quot; 升序排序，如果 &quot;销量相同&quot;，再按照 &quot;商品名称&quot; 的字典序降序排序，你要怎么做呢？</p>
<p>显然这个问题的难点就在于字符串要怎么降序排，整数可以取反，但字符串是无法取反的。所以我们可以自定义一个类，实现它的 __lt__ 方法。</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

class STR(str):
    def __lt__(self, other):
        # 调用 str 的 __lt__，得到布尔值，然后再取反
        # 当然，把 not 换成 ~ 也是可以的
        # 因此：&quot;apple&quot; &lt; &quot;banana&quot; 为 True
        # 但是：STR(&quot;apple&quot;) &lt; STR(&quot;banana&quot;) 为 False
        return not super().__lt__(other)

# 销量升序排，直接 x[1] 即可
# 但是商品名称降序排，需要使用类 STR 将 x[0] 包起来
print(sorted(data, key=lambda x: (x[1], STR(x[0]))))
&quot;&quot;&quot;
[('peach', 150), 
 ('orange', 150), 
 ('cherry', 150), 
 ('banana', 200), 
 ('apple', 200)]
&quot;&quot;&quot;

# 事实上，如果你的思维够灵活，你会发现
# &quot;销量&quot;降序排、&quot;商品名称&quot;升序排，排完之后再整体取反
# 就是这里 &quot;销量&quot;升序排、&quot;商品名称&quot;将序排 的结果
print(
    sorted(data, key=lambda x: (~x[1], x[0]), reverse=True)
    ==
    sorted(data, key=lambda x: (x[1], STR(x[0])))
)  # True
# 当然这个思路也很巧妙
</code></pre>
<p>由于默认是调用 __lt__ 进行比较的，因此我们需要实现 __lt__。</p>
<p>以上就是 Python 中如何对可迭代对象进行排序，还是很有意思的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>在工作中我们经常会遇到这样一个需求，就是获取可迭代对象中的前 K 个最大或最小的元素。我们之前介绍过排序，所以一个最简单的办法就是先排序，排完了再选择前 K 个元素即可。</p>
<pre><code class="language-Python">data = [3, 1, 2, 5, 4]

# 选择前 3 个最大的元素，和前 3 个最小的元素
sorted_data = sorted(data)
print(f&quot;TOP 3 MAX：{sorted_data[-3:]}&quot;)
print(f&quot;TOP 3 MIN：{sorted_data[: 3]}&quot;)
&quot;&quot;&quot;
TOP 3 MAX：[3, 4, 5]
TOP 3 MIN：[1, 2, 3]
&quot;&quot;&quot;

# 或者这么做
sorted_data = sorted(data, reverse=True)
print(f&quot;TOP 3 MAX：{sorted_data[: 3]}&quot;)
print(f&quot;TOP 3 MIN：{sorted_data[-3:]}&quot;)
&quot;&quot;&quot;
TOP 3 MAX：[5, 4, 3]
TOP 3 MIN：[3, 2, 1]
&quot;&quot;&quot;
</code></pre>
<p>显然这是一种解决办法，但如果列表的长度非常大，排序就会带来不小的开销。而且有时我们只要前几个元素即可，比如长度为 10000 的列表，我们只想要前三个最大或最小的元素，那么此时对整个列表进行排序显然会存在性能上的浪费。</p>
<blockquote>
<p>sorted 函数的时间复杂度是 O(NlogN)</p>
</blockquote>
<p>所以接下来我们要介绍一个模块叫 heapq，通过该模块我们能快速地获取前 K 个元素。</p>
<pre><code class="language-Python">import random
import heapq

data = [random.randint(10, 10000) for _ in range(1000)]

# 选择前 3 个最大的元素
print(heapq.nlargest(3, data))
print(sorted(data, reverse=True)[: 3])
&quot;&quot;&quot;
[9997, 9995, 9984]
[9997, 9995, 9984]
&quot;&quot;&quot;

# 选择前 3 个最小的元素
print(heapq.nsmallest(3, data))
print(sorted(data)[: 3])
&quot;&quot;&quot;
[23, 39, 52]
[23, 39, 52]
&quot;&quot;&quot;
</code></pre>
<p>得到的结果是一样的，但是性能差异如何呢？我们来测一下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./1.png" alt="" /></p>
<p>可以看到性能差异还是蛮大的，并且列表长度越大，性能差距越明显。而根本原因就在于 sorted 会对列表进行全局排序，而 heapq 没有。因此在获取前 K 个元素、并且 K 和列表长度差距比较大的时候，不妨使用 heapq 的 nsmallest 和 nlargest 函数，性能会有明显提升。</p>
<blockquote>
<p>但如果 K 和列表长度相差不大，那么先 sorted 排序，再使用切片的方式会更好一些。</p>
</blockquote>
<p>nsmallest 和 nlargest 这两个函数都接收 3 个参数，第一个参数表示要获取前多少个元素、第二个参数表示可迭代对象（一般是列表）、第三个参数是 key（和 sorted 函数里面的 key 含义相同）。</p>
<pre><code class="language-python">import random
import heapq

data = [{&quot;number&quot;: random.randint(10, 10000)} for _ in range(1000)]

# data 内部都是字典
# 获取前 3 个 number 字段的值最大的字典
print(heapq.nlargest(3, data, key=lambda x: x[&quot;number&quot;]))
print(sorted(data, key=lambda x: x[&quot;number&quot;], reverse=True)[: 3])
&quot;&quot;&quot;
[{'number': 9998}, {'number': 9963}, {'number': 9956}]
[{'number': 9998}, {'number': 9963}, {'number': 9956}]
&quot;&quot;&quot;
</code></pre>
<p>特别提示，如果 K 为 1，那么使用内置函数 min 和 max 是最佳选择。</p>
<pre><code class="language-Python">import random
import heapq

data = [{&quot;number&quot;: random.randint(10, 10000)} for _ in range(1000)]

# data 内部都是字典
# 获取前 3 个 number 字段的值最大的字典
print(heapq.nlargest(1, data, key=lambda x: x[&quot;number&quot;]))
print(sorted(data, key=lambda x: x[&quot;number&quot;], reverse=True)[0])
print(max(data, key=lambda x: x[&quot;number&quot;]))
&quot;&quot;&quot;
[{'number': 9997}]
{'number': 9997}
{'number': 9997}
&quot;&quot;&quot;
</code></pre>
<p>所以结论如下，当获取最大或最小元素的个数为 K，列表（可迭代对象）长度为 L 时：</p>
<ul>
<li>K 等于 1，使用内置函数 max 或 min；</li>
<li>K 不等于 1、且远小于 L，使用 heapq 模块的 nlargest 或 nsmallest 函数；</li>
<li>K 和 L 差别不大，使用 sorted 先全局排序、然后再通过切片方式截取；</li>
</ul>
<p>当然啦，以上都属于基础知识，比较简单。其实选择前 K 个元素就是我们常说的 TOP K 问题，如果只是单纯地想解决 TOP K 问题的话，上面已经给出了方案。这里我主要是想通过 TOP K 来引出一种数据结构，也就是堆。</p>
<p>堆是一种非常高效的数据结构，我们可以用它实现优先队列，堆实现的优先队列在元素入队、出队的时间复杂度上均为 O(logN)。</p>
<h2 id="什么是堆"><a class="header" href="#什么是堆">什么是堆？</a></h2>
<p>首先堆本身是一棵树，如果这棵树是二叉树，那么实现的堆就被称为二叉堆。当然除了二叉堆，还有三叉堆等等，只不过二叉堆是一种最主流的堆的实现方式。因此，堆（二叉堆）就是一棵满足一些特殊性质的二叉树，那么问题来了，它都满足哪些性质呢？</p>
<ul>
<li>堆是一棵完全二叉树；</li>
<li>堆里的每一个节点都大于等于（或小于等于）它的孩子节点；
<ul>
<li>如果每个节点都大于等于它的孩子节点，或者说每个节点都不大于它的父节点，那么这个堆就是大根堆；</li>
<li>如果每个节点都小于等于它的孩子节点，或者说每个节点都不小于它的父节点，那么这个堆就是小根堆；</li>
</ul>
</li>
</ul>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./2.png" alt="" /></p>
<p>注意：堆要求的是每个节点和其孩子节点之间要满足相应的大小关系，如果两个节点之间没有父子关系，那么它们谁大谁小无关紧要。比如图上的大根堆，第三层的最后一个节点是 13，可第四层的节点却都比它大，但它们之间没有父子关系，所以当前这个堆是成立的。</p>
<p>正是因为堆的这个性质，我们可以使用数组来表示堆，直接按照层序遍历的方式将每一层的元素放在数组中即可，比如：</p>
<p><code>[62, 41, 30, 28, 16, 22, 13, 19, 17, 15]</code></p>
<p>很明显，堆顶（数组索引为 0）的元素永远是值最大或最小的元素，如果构建的是大根堆，堆顶元素最大；构建的是小根堆，堆顶元素最小。</p>
<p>但是问题来了，如果我有一个节点，要如何找到它的父节点或者孩子节点呢？结论如下，假设当前节点所在的索引为 i。</p>
<ul>
<li>父节点的索引：(i - 1) / 2</li>
<li>左孩子节点的索引：2 * i + 1</li>
<li>右孩子节点的索引：2 * i + 2</li>
</ul>
<p>我们以索引为 3 这个元素（值为 28）为例，它父节点的索引是 (3 - 1) / 2 = 1，也就是 41 这个元素。左孩子节点的索引是 2 * 3 + 1 = 7，也就是 19 这个元素。右孩子节点的索引显然是 8，也就是 17 这个元素。可以对照上图，检验一下是否有误，或者你也可以创建一个更大的堆，自己测试一下，但前提必须是完全二叉树才具备这个性质。</p>
<p>显然通过这种方式，我们就不需要两个指针来维持节点之间的父子关系了，使用数组索引即可，并且通过索引定位元素的速度也会更快。</p>
<h2 id="向堆中添加元素sift-up"><a class="header" href="#向堆中添加元素sift-up">向堆中添加元素（Sift Up）</a></h2>
<p>我们来看看如何往堆中添加元素，首先堆是一个完全二叉树，往堆中添加一个元素，从树的层面来看，就是往最后一层的最右端添加一个元素，如果最后一层已经满了，那么就新加一层。如果从数组的层面来看，就相当于 append 一个元素。</p>
<p>假设我们往刚才的堆中添加一个 52，那么堆的示意图就会变成如下这样：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./3.png" alt="" /></p>
<p>添加的过程非常简单，因为往堆里面添加一个节点，就是往数组里面 append 一个元素，但显然还没有结束。因为堆有两个性质，虽然我们添加元素之后仍然满足是一棵完全二叉树，但是不满足子节点都不大于它的父节点（这里我们构建的是大根堆），因为 52 明显大于它的父节点 16。</p>
<p>因此还要进行调整，将新添加的节点放到属于它的位置，具体过程也很简单：将该节点和它的父节点进行比较，如果比它的父节点大，那么就进行交换；交换之后再和它新的父节点进行比较，如果还大于新的父节点则继续交换，直到不大于为止。</p>
<p>所以从尾部添加的节点，一直向上浮动，直到找到属于它的位置，因此这个过程也被称为 Sift Up（上浮），具体示意图如下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./4.png" alt="" /></p>
<p>当交换之后，发现不大于它的父节点，那么该节点就可以停下来了。可能有人问，它父节点之上的节点该怎么办？比如爷爷节点。答案是不需要关心，因为大根堆的性质就是每个子节点不大于父节点。所以当新添加的节点不大于它的父节点时，也更不可能大于父节点之上的爷爷节点。</p>
<p>下面我们就编写代码实现一下：</p>
<pre><code class="language-python">class BinaryHeap:
    &quot;&quot;&quot;
    大根堆
    &quot;&quot;&quot;
    def __init__(self):
        # 通过数组来模拟堆，为避免直接修改堆
        # 这个数组不对外暴露，而是专门提供一个接口
        self.__data = []
    
    def show_heap(self):
        return self.__data
    
    @staticmethod
    def get_parent(i: int) -&gt; int:
        # 根据节点的索引找到其父节点的索引
        return (i - 1) // 2

    def heappush(self, item: int):
        # 往堆中添加一个节点，对于数组而言，直接 append 即可
        self.__data.append(item)
        # 但是还没有结束，添加完之后不满足堆的性质
        # 我们还要对堆进行调整，由 sift_up 函数负责，它接收一个索引
        # 表示对指定索引的节点进行上浮，显然这里是最后一个
        self.sift_up(len(self.__data) - 1)
    
    def sift_up(self, i: int):
        # 对指定索引位置的节点进行上浮
        while i &gt; 0:
            parent = self.get_parent(i)
            # 当该元素不是根节点的时候，将其和父节点进行比较
            # 如果大于父节点，两者进行交换
            if self.__data[i] &gt; self.__data[parent]:
                self.__data[i], self.__data[parent] = self.__data[parent], self.__data[i]
                # 交换之后该节点成为了父节点，然后将 parent 赋值为 i
                # 因为它还要继续作为新的子节点和新的父节点比较
                i = parent
            else:
                # 如果不大于父节点，说明该元素已经找到属于它的位置了
                # 直接将循环结束掉即可
                break
        
heap = BinaryHeap()
for item in [62, 41, 30, 28, 16, 22, 13, 19, 17, 15]:
    heap.heappush(item)
print(heap.show_heap())
&quot;&quot;&quot;
[62, 41, 30, 28, 16, 22, 13, 19, 17, 15]

                        62
            41                       30
      28          16           22          13
  19      17  15
&quot;&quot;&quot;

# 这个时候再添加一个元素 52
heap.heappush(52)
print(heap.show_heap())
&quot;&quot;&quot;
[62, 52, 30, 28, 41, 22, 13, 19, 17, 15, 16]

                        62
            52                       30
      28          41           22          13
  19      17  15      16
&quot;&quot;&quot;
</code></pre>
<p>可以看到结果是没有问题的，以上我们添加元素就成功了，下面我们再来看看如何从堆中取出元素。</p>
<h2 id="从堆中取出元素sift-down"><a class="header" href="#从堆中取出元素sift-down">从堆中取出元素（Sift Down）</a></h2>
<p>正如添加节点从堆底添加，取出节点只能从堆顶取出（也就是只能取根节点），不能取其它位置的节点。</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./5.png" alt="" /></p>
<p>但问题是，如果直接将堆顶的节点取走的话，就会形成两个独立的堆，两个堆的根节点分别是它的左右节点。我们还要手动将两个堆合并在一起，会比较麻烦，因此可以换个思路，将堆顶和堆底的元素进行交换。交换之后，弹出堆底的元素，这样就得到了最大值。</p>
<p>但该做法同时也破坏了堆的第二个性质，因为之前的堆底元素现在跑到了堆顶，肯定不满足父节点和子节点之间的大小关系，所以还要进行调整。</p>
<p>对于大根堆而言，将该节点和左右子节点中大的那一个进行比较，如果比子节点小，那么进行交换。交换之后再和它新的子节点进行比较，如果还小于新的子节点则继续交换，直到不小于为止。</p>
<p>所以从顶部的节点，一直向下沉，直到找到属于它的位置，因此这个过程也被称为 Sift Down（下沉），具体示意图如下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./6.png" alt="" /></p>
<p>注意：堆顶节点和堆底节点交换之后，就被弹出了，所以图中的 62 不再是堆节点，因此我们刻意画的淡了一些。</p>
<p>下面完善一下之前的代码：</p>
<pre><code class="language-python">class BinaryHeap:
    &quot;&quot;&quot;
    大根堆
    &quot;&quot;&quot;
    def __init__(self):
        self.__data = []
    
    def show_heap(self):
        return self.__data
    
    @staticmethod
    def get_parent(i: int) -&gt; int:
        # 根据节点的索引找到其父节点的索引
        return (i - 1) // 2
    
    @staticmethod
    def get_left_child(i: int) -&gt; int:
        # 根据节点的索引找到左孩子节点的索引
        return 2 * i + 1
    
    @staticmethod
    def get_right_child(i: int) -&gt; int:
        # 根据节点的索引找到右孩子节点的索引
        return 2 * i + 2

    def heappush(self, item: int):
        self.__data.append(item)
        self.sift_up(len(self.__data) - 1)
    
    def sift_up(self, i: int):
        while i &gt; 0:
            parent = self.get_parent(i)
            if self.__data[i] &gt; self.__data[parent]:
                self.__data[i], self.__data[parent] = self.__data[parent], self.__data[i]
                i = parent
            else:
                break
            
    def heappop(self):
        # 弹出堆顶元素
        if len(self.__data) == 0:
            raise IndexError(&quot;pop from empty heap&quot;)
        # 将第一个元素和最后一个元素进行交换
        self.__data[0], self.__data[-1] = self.__data[-1], self.__data[0]
        # 弹出最后一个元素
        item = self.__data.pop()
        # 不过在返回之前，记得调整一下堆，由 sift_down 函数负责
        # 此函数接收一个索引，表示对指定节点的索引进行下沉
        # 显然这里是第一个
        self.sift_down(0)
        return item
    
    def sift_down(self, i: int):
        # 对索引为 i 的节点进行下沉，这里需要判断孩子节点是否存在的情况
        # 如果左孩子节点的索引越界，说明该节点已经是叶子节点了
        while self.get_left_child(i) &lt; len(self.__data):
            left_child = self.get_left_child(i)
            right_child = self.get_right_child(i)
            # 获取子节点大的那一个，注意：需要考虑右节点是否存在的情况
            if right_child &lt; len(self.__data) and self.__data[right_child] &gt; self.__data[left_child]:
                child = right_child
            else:
                child = left_child
            # 将该节点和孩子节点进行比较，如果比孩子节点小，那么交换位置
            # 并继续和新的孩子节点进行比较
            if self.__data[i] &lt; self.__data[child]:
                self.__data[i], self.__data[child] = self.__data[child], self.__data[i]
                i = child
            # 否则直接跳出循环
            else:
                break

heap = BinaryHeap()
data = [4, 8, 1, 5, 3, 9, 2, 7, 6]
# 依次添加到堆中
for item in data:
    heap.heappush(item)
# 从堆中弹出，由于每次都会弹出最大值
# 所以得到的新列表是降序排序的    
print([heap.heappop() for _ in range(len(data))])
&quot;&quot;&quot;
[9, 8, 7, 6, 5, 4, 3, 2, 1]
&quot;&quot;&quot;
</code></pre>
<p>显然是没有问题的，因此我们这里就实现了一个堆排序，只不过这个堆排序还不太完美，不完美之处有两个地方：</p>
<ul>
<li>默认是从大到小排序的，应该提供一个参数供外界选择究竟是从大到小还是从小到大；</li>
<li>开辟了一个额外的数组，合适的做法应该是接收一个数组，然后原地排序；</li>
</ul>
<p>那么下面我们完善一下堆排序。</p>
<pre><code class="language-python">def get_left_child(i: int):
    return 2 * i + 1

def get_right_child(i: int):
    return 2 * i + 2

def sift_down_large(data: list, i: int, length: int):
    # 大根堆下沉，但是参数多了一个 length，这是为啥呢？
    # 因为之前是将堆顶和堆底的元素交换之后，就将堆底的元素弹出去了
    # 以至于我们需要单独开辟一个数组去接收
    # 但很明显，我们这里要求原地排序，那么交换之后的元素在堆底不可以动
    # 因此每 sift_down 一次，length 要减去 1
    while get_left_child(i) &lt; length:
        left_child = get_left_child(i)
        right_child = get_right_child(i)
        # 判断是否有右孩子，如果有右孩子，那么选择值较大的那一个孩子节点
        if right_child &lt; length and data[right_child] &gt; data[left_child]:
            child = right_child
        else:
            child = left_child
        # 如果比孩子节点的值小，那么两者进行交换，因为大根堆要求父节点不小于子节点
        if data[i] &lt; data[child]:
            data[i], data[child] = data[child], data[i]
            i = child
        else:
            break


def sift_down_small(data: list, i: int, length: int):
    # 小根堆下沉
    while get_left_child(i) &lt; length:
        left_child = get_left_child(i)
        right_child = get_right_child(i)
        # 判断是否有右孩子，如果有右孩子，那么选择值较小的那一个孩子节点
        if right_child &lt; length and data[right_child] &lt; data[left_child]:
            child = right_child
        else:
            child = left_child
        # 如果比孩子节点的值大，那么两者进行交换，因为小根堆要求父节点不大于子节点
        if data[i] &gt; data[child]:
            data[i], data[child] = data[child], data[i]
            i = child
        else:
            break

def heapify_large(data: list):
    # 将一个数组整理成大根堆的形状
    # 从最后一个非叶子节点进行 sift_down 即可
    for i in range((len(data) - 1) &gt;&gt; 1, -1, -1):
        sift_down_large(data, i, len(data))

def heapify_small(data: list):
    # 将一个数组整理成小根堆的形状
    for i in range((len(data) - 1) &gt;&gt; 1, -1, -1):
        sift_down_small(data, i, len(data))
        
def heap_sort(data: list, reverse: bool = False):
    # 堆排序，首先将 data 整理成堆的形状
    if reverse:
        heapify_small(data)
    else:
        heapify_large(data)
    # i 从最后一个元素开始
    for i in range(len(data) - 1, -1, -1):
        # 交换完之后的元素就不可以动了
        data[0], data[i] = data[i], data[0]
        # 并且也不能再参与后续的 sift_down，因此依旧调整堆，但是范围变了
        # 比如第一次交换，那么最后一个元素为最大值
        # sift_down 的时候，整个范围就是 [0: len(data) - 1]
        # 同理第二次 sift_down 的时候，范围就是 [0: len(data) - 2]
        if reverse:
            sift_down_small(data, 0, i)
        else:
            sift_down_large(data, 0, i)


import random
data = [random.randint(0, 100) for _ in range(10)]
print(data)
&quot;&quot;&quot;
[51, 4, 38, 31, 87, 18, 39, 8, 98, 61]
&quot;&quot;&quot;
heap_sort(data)
print(data)
&quot;&quot;&quot;
[4, 8, 18, 31, 38, 39, 51, 61, 87, 98]
&quot;&quot;&quot;

data = [random.randint(0, 100) for _ in range(10)]
print(data)
&quot;&quot;&quot;
[78, 11, 83, 30, 99, 61, 45, 63, 17, 81]
&quot;&quot;&quot;
heap_sort(data, reverse=True)
print(data)
&quot;&quot;&quot;
[99, 83, 81, 78, 63, 61, 45, 30, 17, 11]
&quot;&quot;&quot;
</code></pre>
<p>以上我们就实现了堆排序，那么问题来了，你觉得 heapq 模块里的 nlargest 和 nsmallest 是怎么实现的呢？</p>
<p>很简单，假设我们要选取 k 个最小的元素，那么首先可以从数组中截取前 k 个元素，构建一个大根堆。然后从第 k + 1 个元素开始遍历数组，如果当前元素大于等于堆顶元素，那么它肯定就不是前 k 小的元素，如果当前元素小于堆顶的元素，那么两者进行交换，然后进行一次 Sift Down 操作。当数组遍历完毕之后，堆中的 k 个元素就是最小的前 k 个元素。同理，如果想选择前 k 个最大的元素，那么就构建一个小根堆。</p>
<blockquote>
<p>或者将整个数组构建成一个堆，然后heappop k 次即可，这样也能选择前 k 个元素。</p>
</blockquote>
<h2 id="优先队列"><a class="header" href="#优先队列">优先队列</a></h2>
<p>其实在排序的时候，堆排序不是效率最高的排序，它比三路快排要慢一些。但是堆存在的目的绝不仅仅是为了排序，由于它可以动态添加元素、删除元素，并且时间复杂度都为 O(logN) 级别，所以堆的强大之处就在于非常适合实现优先队列。</p>
<p>事实上 heapq 也已经为我们提供了堆的相关操作：</p>
<pre><code class="language-Python">&quot;&quot;&quot;
heapq.heapify(data)
    将数组 data 整理成堆的形状，只支持小根堆

heapq.heappush(data, item)
    向堆中添加元素，并维护堆的形状
    要求 data 已经是一个小根堆

heapq.heappop(data, item)
    从堆中弹出元素，并维护堆的形状
    要求 data 已经是一个小根堆
&quot;&quot;&quot;
</code></pre>
<p>而 Python 的优先队列，底层就是借助于 heapq 实现的，我们看一下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./7.png" alt="" /></p>
<p>里面的 item 是一个元组，第一个元素是优先级（值越小、优先级越高），第二个元素是具体的数据，这就是优先队列，是不是比你想象中的要简单许多呢？</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>堆是一种非常高效的数据结构，它可以动态地添加、删除元素，并且时间复杂度均为 O(logN) 级别。这个特性就决定了它非常适合实现优先队列，维护一个堆，在往堆中添加元素的时候，只需要加一个优先级即可，也就是将优先级和数据组合成一个元组添加到堆中。如果构建的是小根堆，值越小、优先级越高；构建的是大根堆，值越大，优先级越高。</p>
<p>另外我们说，当获取最大值或最小值时，推荐使用内置函数 max 和 min。但如果数组 data 一直在动态变化，并且要随时获取里面的最大值或最小值，那么相比使用内置函数 max、min，更好的做法是将 data 维护成一个堆。然后添加元素使用 heappush，获取元素直接 data[0] 即可。因为这整体是一个 O(logN) 的操作，而是 min、max 是一个 O(N) 的操作。</p>
<p>最后，堆可以用来实现排序，效率也很高，但相比三路快排还差了那么一点。但堆存在的目的不在于排序，而在于它的动态性。优先队列就不必说了，还有 TOP K。虽然三路快排和堆都可以实现 TOP K，但前者要求数据必须一次性全部给出，而堆则没有这个要求，换句话说堆可以满足对流式数据的处理。</p>
<p>比如 1T 的文件，一行就是一串数字，如果想在 16G 内存的机器上查找最大的 100 个数字，用快排是无法实现的，因为无法将文件一次性加载到内存中。但堆可以实现这个需求，先读取 100 行维护一个小根堆，然后从 101 行继续读取，依次和堆顶进行比较。如果小于堆顶元素，那么它一定不是前 100 个最大的数字；如果大于堆顶元素，那么就替换掉，然后 sift_down，维护堆的形状。这样总有一刻，能够选出最大的 100 个数字。</p>
<p>所以当数组 data 不断变化时，将其维护成一个堆，然后通过 heappush 添加元素、heappop 弹出堆顶元素、data[0] 获取堆顶元素，往往是最佳选择。并且添加和弹出都是 logN 级别的时间复杂度，也正是这个特性，它适合优先队列以及流式数据（数据无法一次性全部给出）的处理。</p>
<div style="break-before: page; page-break-before: always;"></div><p>假设有这样一种数据：</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

# 我们需要变成如下格式
&quot;&quot;&quot;
[('apple', [30, 35, 32]),
 ('pear', [60, 32, 60]),
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>如果是你的话，你会怎么做呢？很容易想到的一种解决方案是构造一个字典：</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

data_dict = {}
for name, count in data:
    if name not in data_dict:
        data_dict[name] = []
    data_dict[name].append(count)

print(data_dict)
&quot;&quot;&quot;
{'apple': [30, 35, 32], 
 'pear': [60, 32, 60], 
 'banana': [102, 104]}
&quot;&quot;&quot;
print(list(data_dict.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]), 
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>这种方案完全没有问题，不过我们还可以写的更优雅一些，也就是使用字典的 setdefault 方法：</p>
<pre><code class="language-Python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

data_dict = {}
for name, count in data:
    # setdefault(k, v) 含义如下
    # 当 k 不存在时，将 k: v 设置在字典中，并返回 v
    # 当 k 存在时，直接返回 k 对应值
    data_dict.setdefault(name, []).append(count)

print(list(data_dict.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]), 
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>setdefault 是一个非常方便的方法，但是使用频率却不怎么高，或者说该方法不太让人喜欢。主要是每次调用都要给一个初始值，比如代码中的空列表 []。另外这里的初始值可以任意，如果你希望添加的时候还能实现去重效果，那么就将空列表换成空集合即可。</p>
<p>或者我们还可以使用 defaultdict，它位于 collections 模块中。</p>
<pre><code class="language-Python">from collections import defaultdict

data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

# 里面接收一个 callable
# 当访问的 k 不存在时，返回 callable 调用之后的值
data_dict1 = defaultdict(list)
for name, count in data:
    data_dict1[name].append(count)

print(list(data_dict1.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]),
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;

# 也可以指定为 set
data_dict2 = defaultdict(set)
for name, count in data:
    data_dict2[name].add(count)

print(list(data_dict2.items()))
&quot;&quot;&quot;
[('apple', {32, 35, 30}), 
 ('pear', {32, 60}), 
 ('banana', {104, 102})]
&quot;&quot;&quot;
</code></pre>
<p>总的来说，defaultdict 和字典的 setdefault 方法非常类似，我们使用 setdefault 即可，因为 setdefault 其实更加方便。我们不妨再看个更复杂的例子。</p>
<pre><code class="language-Python">data = [
    (&quot;a&quot;, &quot;x&quot;, 1),
    (&quot;a&quot;, &quot;x&quot;, 2),
    (&quot;a&quot;, &quot;x&quot;, 3),
    (&quot;a&quot;, &quot;y&quot;, 4),
    (&quot;a&quot;, &quot;y&quot;, 5),
    (&quot;a&quot;, &quot;z&quot;, 6),
    
    (&quot;b&quot;, &quot;x&quot;, 7),
    (&quot;b&quot;, &quot;x&quot;, 8),
    (&quot;b&quot;, &quot;y&quot;, 9),
    (&quot;b&quot;, &quot;z&quot;, 10),
]
# 如果我想得到下面的结果，怎么做呢？
&quot;&quot;&quot;
{'a': {'x': [1, 2, 3], 'y': [4, 5], 'z': [6]}, 
 'b': {'x': [7, 8], 'y': [9], 'z': [10]}}
&quot;&quot;&quot;
# 使用 setdefault 会非常方便
data_dict = {}
for first, second, value in data:
    data_dict.setdefault(first, {}).setdefault(second, []).append(value)

print(data_dict)
</code></pre>
<p>以上就是数据分组，比较简单，setdefault 这个方法非常方便，但总是容易被遗忘。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-1"><a class="header" href="#楔子-1">楔子</a></h2>
<p>在 Python3.6 之前，格式化字符串一般会使用百分号占位符或者 format 函数，举个例子：</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;

# 使用百分号占位符格式化字符串
print(
    &quot;我是 %s, 来自 %s&quot; % (name, address)
)  # 我是 古明地觉, 来自 地灵殿

# 使用format函数格式化字符串
print(
    &quot;我是 {}, 来自 {}&quot;.format(name, address)
)  # 我是 古明地觉, 来自 地灵殿

# format 函数还支持关键字参数
print(
    &quot;我是 {name}, 来自 {address}&quot;.format(address=address, name=name)
)  # 我是 古明地觉, 来自 地灵殿
</code></pre>
<p>但是从 3.6 开始，Python 新增了一个格式化字符串的方法，称之为 f-string。f-string 的功能非常强大，可以说是一把 &quot;瑞士军刀&quot;。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;

print(
    f&quot;我是 {name}, 来自 {address}&quot;
)  # 我是 古明地觉, 来自 地灵殿
</code></pre>
<p>使用 f-string 需要给字符串增加一个前缀 f，此时 <strong>{}</strong> 和它里面的内容则不再表示字符串，而是整体作为一个需要单独计算的值或者表达式、或者变量。我们再举个例子：</p>
<pre><code class="language-Python">print(f&quot;1 + 1 = {1 + 1}&quot;)  # 1 + 1 = 2
print(f&quot;sum([1, 2, 3]) = {sum([1, 2, 3])}&quot;)  # sum([1, 2, 3]) = 6
print(f&quot;{'--'.join(['a', 'b', 'c', 'd'])}&quot;)  # a--b--c--d

try:
    print(f&quot;{a}&quot;)
except Exception as e:
    print(e)  # name 'a' is not defined

# 在f-string中，{} 里面的内容是需要单独计算的
# 可以是常量，比如 {123}、{'hello'} 等等。可以是表达式，比如 {1 + 1}、{2 &gt; 1} 等等
# 可以是变量，比如 {a}、{name}，但是变量要定义好，而上面的 a 没有定义，所以报错

# 或者定义一个变量
a = lambda x: x + 100
print(f&quot;{a}&quot;)  # &lt;function &lt;lambda&gt; at 0x000...&gt;
print(f&quot;{a(1)}&quot;)  # 101
</code></pre>
<p>我们看到 f-string 还是很方便的，并且和 format 功能类似，但是性能要优于 format 函数。当然 f-string 的功能远没有目前介绍的这么简单，它支持的操作非常多，下面就来逐一介绍。</p>
<h2 id="实现-repr-打印"><a class="header" href="#实现-repr-打印">实现 repr 打印</a></h2>
<p>有时候我们在打印的时候需要带上引号。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

print(name)  # 古明地觉
print(&quot;%s&quot; % name)  # 古明地觉
# 如果使用 %r 打印，会带上单引号
print(&quot;%r&quot; % name)  # '古明地觉'

# 上面类似于 str 和 repr 的区别
print(str(name))  # 古明地觉
print(repr(name))  # '古明地觉'

# 等价于调用 __str__ 和 __repr__
print(name.__str__())  # 古明地觉
print(name.__repr__())  # '古明地觉'
</code></pre>
<p>如果在交互式环境下，不使用 print，而是直接输入变量 name、然后回车，那么会调用 __repr__ 方法。如果使用 print(name)，那么不管在什么环境，都会调用 __str__ 方法。</p>
<p>那么在字符串周围带上一层单引号，有什么意义呢？</p>
<pre><code class="language-python">birthday = &quot;1995-07-05&quot;
print(&quot;select name from where birthday &gt; %s&quot; % birthday)  
print(&quot;select name from where birthday &gt; %r&quot; % birthday)  
&quot;&quot;&quot;
select name from where birthday &gt; 1995-07-05
select name from where birthday &gt; '1995-07-05'
&quot;&quot;&quot;
</code></pre>
<p>看到区别了吗？如果是第一个查询，那么肯定是会报错的。重点来了，如何通过 f-string 实现这种效果呢？</p>
<pre><code class="language-Python">birthday = &quot;1995-07-05&quot;

# 我们只需要在打印的内容后面加上一个!r即可
print(f&quot;{birthday!r}&quot;)  # '1995-07-05'
print(f&quot;{birthday}&quot;)  # 1995-07-05

# &quot;{name}&quot; &lt;==&gt; str(name) &lt;==&gt; name.__str__()
# &quot;{name!r}&quot; &lt;==&gt; repr(name) &lt;==&gt; name.__repr__()

print(f&quot;{'.'.join(['a', 'b', 'c'])}&quot;)  # a.b.c
print(f&quot;{'.'.join(['a', 'b', 'c'])!r}&quot;)  # 'a.b.c'

# 注意：!r 针对的是字符串
# 虽然也可以作用于其它对象，不过没有效果
print(f&quot;{123!r}&quot;)  # 123
print(f&quot;{3.14!r}&quot;)  # 3.14

# 另外除了 !r，还有 !s 和 !a，只有这三种
# !a 和 !r 类似，!s是默认选择、加不加均可
print(f&quot;{birthday}&quot;)  # 1995-07-05
print(f&quot;{birthday!s}&quot;)  # 1995-07-05
print(f&quot;{birthday!a}&quot;)  # '1995-07-05'
print(f&quot;{birthday!r}&quot;)  # '1995-07-05'
</code></pre>
<p>以上就是字符串的 repr 打印。</p>
<h2 id="整数的进制转换"><a class="header" href="#整数的进制转换">整数的进制转换</a></h2>
<p>我们在打印整数的时候，有时候需要转成某个进制之后再打印。</p>
<pre><code class="language-Python">i = 123
# 打印 2 进制
print(f&quot;{i:b}&quot;)  # 1111011
# 打印 8 进制
print(f&quot;{i:o}&quot;)  # 173
# 打印 10 进制
# 默认是 10 进制，也可以直接使用 {i}
print(f&quot;{i:d}&quot;)  # 123
# 打印 16 进制
print(f&quot;{i:x}&quot;)  # 7b

# 类似于内置函数 bin、oct、hex
# 但是这些内置函数调用之后会带上一个前缀
print(bin(i))  # 0b1111011
print(oct(i))  # 0o173
print(hex(i))  # 0x7b

# f-string 可不可以实现呢？答案是可以的
print(f&quot;{i:#b}&quot;)  # 0b1111011
print(f&quot;{i:#o}&quot;)  # 0o173
print(f&quot;{i:#x}&quot;)  # 0x7b
# 对于表示 16 进制的 x，我们还可以将 x 大写
# 此时输出的内容也是大写格式的
print(f&quot;{i:#X}&quot;)  # 0X7B
</code></pre>
<p>另外除了 # 号，还可以使用 +、-、以及空格，功能如下：</p>
<ul>
<li>+：显示正负号；</li>
<li>-：负数显示符号、正数不显示；</li>
<li>空格：正数显示空格、负数不显示，只能是一个空格；</li>
<li>#：显示前缀，比如 0b、0o、0x</li>
</ul>
<p>注意：这几个符号不可混用，并且最多只能出现一次。</p>
<pre><code class="language-Python">print(f&quot;{123:+x}, {-123:+x}&quot;)  # +7b, -7b
print(f&quot;{123:-x}, {-123:-x}&quot;)  # 7b, -7b
print(f&quot;{123: x}, {-123: x}&quot;)  #  7b, -7b
print(f&quot;{123:#x}, {-123:#x}&quot;)  # 0x7b, -0x7b
</code></pre>
<p>另外，Python 在创建整数的时候，还支持使用 _ 进行分隔，但打印的时候不会将 _ 显示出来。</p>
<pre><code class="language-Python">num = 100_000_000
print(num)  # 100000000

# 但如果是 f-string 的话
print(f&quot;{num:_d}&quot;)
&quot;&quot;&quot;
100_000_000
&quot;&quot;&quot;
print(f&quot;{num:_b}&quot;)
print(f&quot;{num:#_b}&quot;)
&quot;&quot;&quot;
101_1111_0101_1110_0001_0000_0000
0b101_1111_0101_1110_0001_0000_0000
&quot;&quot;&quot;
print(f&quot;{num:_o}&quot;)
print(f&quot;{num:#_o}&quot;)
&quot;&quot;&quot;
5_7536_0400
0o5_7536_0400
&quot;&quot;&quot;
print(f&quot;{num:_x}&quot;)
print(f&quot;{num:#_x}&quot;)
&quot;&quot;&quot;
5f5_e100
0x5f5_e100
&quot;&quot;&quot;

# 只需要在 b、d、o、x 前面加上一个 _ 即可
# 这样打印出来的字符串也会带上 _ 分隔符
# 另外分隔符还可以使用逗号
print(f&quot;{num:,d}&quot;)
&quot;&quot;&quot;
100,000,000
&quot;&quot;&quot;
</code></pre>
<p>注意：b、o、d、x 这些只能用于整数，不能是其它类型的对象。</p>
<pre><code class="language-Python">print(f&quot;{'aaa':b}&quot;)
&quot;&quot;&quot;
    print(f&quot;{'aaa':b}&quot;)
ValueError: Unknown format code 'b' for object of type 'str'
&quot;&quot;&quot;
</code></pre>
<p>最后再来补充一个字符，整数除了可以使用 b、o、d、x 之外， 还可以使用一个字符，也就是 c。</p>
<pre><code class="language-Python">num = 97

print(chr(num))  # a
print(f&quot;{num:c}&quot;)  # a
</code></pre>
<p>以上就是整数的进制转换。</p>
<h2 id="整数的填充"><a class="header" href="#整数的填充">整数的填充</a></h2>
<p>很多时候，打印出来的整数都会进行位数的填充，比如 1 的话，就打印 001，18 则打印 018，123 则打印本身的 123。这种需求，要怎么去处理它呢？</p>
<pre><code class="language-Python">num = 1
# 还记得这个 d 吗？
# 我们说直接打印的话，有它没它无影响
# 但是对于填充的话，它就派上用场了
print(f&quot;{num:03d}&quot;)  # 001
print(f&quot;{num:013d}&quot;)  # 0000000000001
</code></pre>
<p>填充只能用 0 或者空格来填充，比如 0123d，表示打印出来要占 123 个字符，够的话不管了，不够则使用 0 在左边填充。</p>
<p>如果是 123d，它代表的可不是占 23 个字符、不够用 1 填充，它代表的还是占 123 个字符，但是由于我们没有指定 0，所以默认使用空格在左边填充。</p>
<pre><code class="language-Python"># 长度 23，不够使用空格填充
print(f&quot;{1:23d}&quot;)   #                       1
# 长度 23，不够使用 0 填充
print(f&quot;{1:023d}&quot;)  # 00000000000000000000001

# 当然我们同样可以结合 +、-、空格、#
print(f&quot;{1:+08d}&quot;)  # +0000001
# 可以的话，再将分隔符包含进来
print(f&quot;{1:+023_d}&quot;)  # +00_000_000_000_000_001
print(f&quot;{1:+023,d}&quot;)  # +00,000,000,000,000,001
</code></pre>
<p>当然，以上规则除了适用于十进制的 d，也同样适用于二进制的 b、八进制的 o、十六进制的 x。</p>
<pre><code class="language-Python">print(f&quot;{123:x}&quot;)
print(f&quot;{123:016x}&quot;)
&quot;&quot;&quot;
7b
000000000000007b
&quot;&quot;&quot;

# 打印显示正负号，然后占 8 个字符
print(f&quot;{123:+08d}&quot;)
print(f&quot;{123:+8d}&quot;)
&quot;&quot;&quot;
+0000123
    +123
&quot;&quot;&quot;

# 打印的时候带上前缀，占 18 个字符
print(f&quot;{123:#018b}&quot;)
print(f&quot;{123:#18b}&quot;)
# 打印的时候带上前缀和分隔符，占 18 个字符
print(f&quot;{123:#18_b}&quot;)
&quot;&quot;&quot;
0b0000000001111011
         0b1111011
        0b111_1011
&quot;&quot;&quot;
</code></pre>
<p>我们看到填充的时候，如果用 0 填充，那么会填充在 0b、+ 等前缀的后面；如果用空格填充，那么会填充在前缀的前面。当然这也符合我们正常人的思维：</p>
<ul>
<li>如果是 &quot;+    123&quot; 或者 &quot;00000+123&quot;，明显觉得别扭；</li>
<li>如果是 &quot;    +123&quot; 或者 &quot;+00000123&quot;，则明显顺眼多了；</li>
</ul>
<p>当然工作中我们不会用的这么复杂，知道整数如何填充即可。</p>
<h2 id="浮点数的小数保留"><a class="header" href="#浮点数的小数保留">浮点数的小数保留</a></h2>
<p>浮点数的小数比较长的话，我们打印的时候一般会只打印前两位或前三位，这在 f-string 里面如何实现呢？</p>
<pre><code class="language-Python">num = 123.13421

# f 是保留小数，但我们没有指定精度，所以默认保留后 6 位，不够用 0 补齐
print(f&quot;{num:f}&quot;)
&quot;&quot;&quot;
123.134210
&quot;&quot;&quot;

# .2f 则是保留两位小数
print(f&quot;{num:.2f}&quot;)
&quot;&quot;&quot;
123.13
&quot;&quot;&quot;

# 10.2f 也是保留两位小数，然后整体占满 10 个字符长度，不够的话使用空格在左边填充
print(f&quot;{num:10.2f}&quot;)
&quot;&quot;&quot;
    123.13
&quot;&quot;&quot;

# 如果不想使用空格填充的话
# 那么也可以使用(也只能使用) 0 来进行填充，规则和整数是类似的
print(f&quot;{num:010.2f}&quot;)
&quot;&quot;&quot;
0000123.13
&quot;&quot;&quot;
</code></pre>
<p>当然 +、-、空格 同样可以适用于浮点数，规则也和整数类似，同样的，下面这些在工作中也不常用，所以我们知道怎么保留指定位数的小数即可。</p>
<pre><code class="language-Python">num = 123.13421

print(f&quot;{num:+10.2f}&quot;)   
print(f&quot;{num:+010.2f}&quot;)  
&quot;&quot;&quot;
   +123.13
+000123.13
&quot;&quot;&quot;

# 同理，浮点数也支持使用下划线或者逗号进行分隔
print(f&quot;{num:+10_.2f}&quot;)  
print(f&quot;{num:+10,.2f}&quot;) 
&quot;&quot;&quot;
   +123.13
   +123.13
&quot;&quot;&quot;

# 上面由于有效字符比较少，所以没有分隔符
# 我们用 0 填充一下
print(f&quot;{num:+010_.2f}&quot;)
print(f&quot;{num:+010,.2f}&quot;)
&quot;&quot;&quot;
+00_123.13
+00,123.13
&quot;&quot;&quot;
</code></pre>
<p>以上就是浮点数的小数保留。</p>
<h2 id="任意字符的填充"><a class="header" href="#任意字符的填充">任意字符的填充</a></h2>
<p>我们上面介绍的还只是 f-string 的一部分，接下来就是 f-string 的杀手锏。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

print(f&quot;~{name:&gt;10}~&quot;)
print(f&quot;~{name:^10}~&quot;)
print(f&quot;~{name:&lt;10}~&quot;)
&quot;&quot;&quot;
~      古明地觉~
~   古明地觉   ~
~古明地觉      ~
&quot;&quot;&quot;
</code></pre>
<ul>
<li>&gt;n：输出的字符串占 n 个字符，原始的内容右对齐，长度不够则在左边用空格填充；</li>
<li>^n：输出的字符串占 n 个字符，原始的内容居中对齐，长度不够则在左右两端用空格填充；</li>
<li>&lt;n：输出的字符串占 n 个字符，原始的内容左对齐，长度不够则在右边用空格填充；</li>
</ul>
<p>还可以将 !r、!s、!a 结合起来使用。</p>
<pre><code class="language-Python">print(f&quot;{'abc'!s:&gt;10}&quot;) 
print(f&quot;{'abc'!r:&gt;10}&quot;) 
print(f&quot;{'abc'!a:&gt;10}&quot;) 
&quot;&quot;&quot;
       abc
     'abc'
     'abc'
&quot;&quot;&quot;
</code></pre>
<p>这些规则也适用于数值：</p>
<pre><code class="language-Python">print(f&quot;{3:&gt;10}&quot;)
print(f&quot;{3.14:&gt;10}&quot;)
&quot;&quot;&quot;
         3
      3.14
&quot;&quot;&quot;
</code></pre>
<p>另外默认是使用空格填充的，那么可不可以使用指定字符填充呢？答案是可以的, 直接在 &gt;、&lt;、^ 的左边写上用来填充的字符即可，但是只能写一个字符，多了报错。</p>
<pre><code class="language-Python">print(f&quot;~{'a':1&gt;10}~&quot;)  # ~111111111a~
print(f&quot;~{'a':1^10}~&quot;)  # ~1111a11111~
# 使用空格填充，'a': &gt;10 等价于 'a':&gt;10
print(f&quot;~{'a': &gt;10}~&quot;)  # ~         a~

# 这里我们实现了 {1:03d} 的效果
print(f&quot;{1:0&gt;3}&quot;)  # 001

print(f&quot;{123:b}&quot;)  # 1111011
print(f&quot;{123:b&lt;}&quot;)  # 123
&quot;&quot;&quot;
对于 f&quot;{123:b}&quot;，里面的 b 表示整数的进制转换
此时只能作用于整数，不能是字符串

但是对于 f&quot;{123:b&lt;}，由于里面出现了&lt;
那么此时的 b 就不再代表进制了，而是代表填充字符

只不过 &lt; 后面没有指定个数
所以解释器不知道要填充多少个，因此就原本输出了
&quot;&quot;&quot;

# 但是 f&quot;{'aaa':b}&quot; 报错
# 因为此时 b 代表进制，无法作用于字符串
print(f&quot;{'aaa':b&lt;}&quot;)  # aaa
print(f&quot;{'aaa':b&lt;4}&quot;)  # aaab
</code></pre>
<p>问题来了，如果我们希望整数在填充的时候，还能进制转化，该怎么做呢？</p>
<pre><code class="language-Python"># 转成十六进制
print(f&quot;{255:x}&quot;)
&quot;&quot;&quot;
ff
&quot;&quot;&quot;
# 转成十六进制，带前缀
print(f&quot;{123:#x}&quot;)
&quot;&quot;&quot;
0x7b
&quot;&quot;&quot;
# 转成十六进制，占满10位
# 不够使用字符 s 来左填充
print(f&quot;{123:s&gt;#10x}&quot;)
&quot;&quot;&quot;
ssssss0x7b
&quot;&quot;&quot;
</code></pre>
<p>浮点数也是类似的，在保留指定位数的同时，也可以进行填充。</p>
<pre><code class="language-Python">num = 123.1234

# 保留一位小数
print(f&quot;{num:.1f}&quot;)
&quot;&quot;&quot;
123.1
&quot;&quot;&quot;

# 保留一位小数，同时占满 10 位，此时只能用 0 或 空格填充
print(f&quot;{num:10.1f}&quot;)
print(f&quot;{num:010.1f}&quot;)
&quot;&quot;&quot;
     123.1
00000123.1
&quot;&quot;&quot;

# 如果想使用其它字符填充
print(f&quot;{num:s&lt;10.1f}&quot;)
print(f&quot;{num:s&gt;10.1f}&quot;)
print(f&quot;{num:s^10.1f}&quot;)
&quot;&quot;&quot;
123.1sssss
sssss123.1
ss123.1sss
&quot;&quot;&quot;

# 填充的时候带上正负号
print(f&quot;{num:s&lt;+10.1f}&quot;)
print(f&quot;{num:s&gt;+10.1f}&quot;)
print(f&quot;{num:s^+10.1f}&quot;)
&quot;&quot;&quot;
+123.1ssss
ssss+123.1
ss+123.1ss
&quot;&quot;&quot;

# 填充的时候带上正负号和分隔符
num = 123123123.1234
print(f&quot;{num:s&lt;+20_.1f}&quot;)
print(f&quot;{num:s&gt;+20_.1f}&quot;)
print(f&quot;{num:s^+20_.1f}&quot;)
&quot;&quot;&quot;
+123_123_123.1ssssss
ssssss+123_123_123.1
sss+123_123_123.1sss
&quot;&quot;&quot;
</code></pre>
<p>总的来说，f-string 还是非常强大的，但说实话，工作中不会用到这么多花里胡哨的功能。基本上就是简单的填充、进制转换、保留小数。很少会有 <code>f&quot;{num:s&lt;+20_.1f}&quot;</code> 这种保留小数的同时，还要带正负号、以及填充位数的情况出现。</p>
<h2 id="日期的截取"><a class="header" href="#日期的截取">日期的截取</a></h2>
<p>很多小伙伴应该没想到 f-string 还可以操作日期，这也算是一大亮点吧。我们在格式化或者截取日期的时候，一般会使用 datetime 模块，这些也是可以使用 f-string 来实现的。</p>
<pre><code class="language-Python">import datetime

dt = datetime.datetime(
    1995, 7, 5, 13, 30, 45, 100000)
print(dt)
&quot;&quot;&quot;
1995-07-05 13:30:45.100000
&quot;&quot;&quot;

# %F: 返回年月日（使用 - 连接）
print(f&quot;{dt:%F}&quot;)
&quot;&quot;&quot;
1995-07-05
&quot;&quot;&quot;
# %D: 返回日月年（使用 / 连接），但是年是两位的
# 并且也不符合中国人的日期表达习惯，建议只用 %F
print(f&quot;{dt:%D}&quot;)
&quot;&quot;&quot;
07/05/95
&quot;&quot;&quot;

# %X: 返回时间，精确到秒（小数点后面的会截断）
# 这里注意的 X 要大写，如果是 %x 那么等价于 %D
print(f&quot;{dt:%X}&quot;)
&quot;&quot;&quot;
13:30:45
&quot;&quot;&quot;

# 所以返回字符串格式的完整日期就可以这么写
print(f&quot;{dt:%F %X}&quot;)
&quot;&quot;&quot;
1995-07-05 13:30:45
&quot;&quot;&quot;

# %Y: 返回年（四位）
# %y: 返回年（两位）
print(f&quot;{dt:%Y}&quot;)
print(f&quot;{dt:%y}&quot;)
&quot;&quot;&quot;
1995
95
&quot;&quot;&quot;

# %m: 返回月
# %d: 返回天
# 注意：会占满两位，不够补0
print(f&quot;{dt:%m}&quot;)
print(f&quot;{dt:%d}&quot;)
&quot;&quot;&quot;
07
05
&quot;&quot;&quot;

# 所以 %F，我们还可以这么实现，这些符号是可以连用的
print(f&quot;{dt:%Y-%m-%d}&quot;)
&quot;&quot;&quot;
1995-07-05
&quot;&quot;&quot;

# %H: 返回小时（24小时制度）
# %I: 返回小时（12小时制度）
# 注意：会占满两位，不够补0
print(f&quot;{dt:%H}&quot;)
print(f&quot;{dt:%I}&quot;)
&quot;&quot;&quot;
13
01
&quot;&quot;&quot;

# %M: 返回分钟
# %S: 返回秒
# 注意：会占满两位，不够补0
print(f&quot;{dt:%M}&quot;)
print(f&quot;{dt:%S}&quot;)
&quot;&quot;&quot;
30
45
&quot;&quot;&quot;

# 所以完整的 &quot;年-月-日 时:分:秒&quot;
# 就可以这么实现
print(f&quot;{dt:%Y-%m-%d %H:%M:%S}&quot;)
&quot;&quot;&quot;
1995-07-05 13:30:45
&quot;&quot;&quot;

# %f: 返回微妙
# 注意：会占满六位，不够补0
print(f&quot;{dt:%f}&quot;)
&quot;&quot;&quot;
100000
&quot;&quot;&quot;

# %p: 早上还是下午（本地时间）
# 早上返回 AM、下午返回 PM
print(f&quot;{dt:%p}&quot;)
&quot;&quot;&quot;
PM
&quot;&quot;&quot;

# %j: 一年中的第几天，从 1 开始，1月1号就是 1
# 注意：会占满三位，不够补 0
print(f&quot;{dt:%j}&quot;)
&quot;&quot;&quot;
186
&quot;&quot;&quot;

# %w: 星期几（0 是周日、1 到 6 是周一到周六）
# %u: 星期几（1 到 7 是周一到周日）
# 可以看到两种格式只有星期天不一样
print(f&quot;{dt:%w}&quot;)
print(f&quot;{dt:%u}&quot;)
&quot;&quot;&quot;
3
3
&quot;&quot;&quot;

# %U: 一年中的第几周（以全年首个周日所在的星期为第 0 周）
# %W: 一年中的第几周（以全年首个周一所在的星期为第 1 周）
# %V: 一年中的第几周（以全年首个包含 1 月 4 日的星期为第 1 周）
# 都是占满两位，不够补 0
print(f&quot;{dt:%U}&quot;)
print(f&quot;{dt:%W}&quot;)
print(f&quot;{dt:%V}&quot;)
&quot;&quot;&quot;
27
27
27
&quot;&quot;&quot;
# 所以如果对应的年的第一天恰好是星期一，那么 %U 会比 %W 少 1。
# 如果不是星期一，那么两者是相等的，比如 2007 年的 1 月 1 号恰好是星期一
dt = datetime.datetime(2007, 10, 13)
print(f&quot;{dt:%U}&quot;)
print(f&quot;{dt:%W}&quot;)
print(f&quot;{dt:%V}&quot;)
&quot;&quot;&quot;
40
41
41
&quot;&quot;&quot;

# %Z: 返回时区名，如果没有则返回空字符串
print(f&quot;'{dt:%Z}'&quot;)  # ''
from pytz import timezone
dt = datetime.datetime(2007, 10, 13, tzinfo=timezone(&quot;UTC&quot;))
print(f&quot;'{dt:%Z}'&quot;)  # 'UTC'
</code></pre>
<p>怎么样，是不是很方便呢？以后在做日期的格式化和解析的时候，不妨使用 f-string 试一下。</p>
<h2 id="f-string-的注意事项"><a class="header" href="#f-string-的注意事项">f-string 的注意事项</a></h2>
<p>使用 f-string 需要注意单双引号的问题，如果限定字符串使用的是双引号，那么 {} 里面出现的必须是单引号，反之亦然。</p>
<pre><code class="language-Python">d = {&quot;a&quot;: 1}
# 外面是双引号，{} 里面必须是单引号，不能是 d[&quot;a&quot;]
print(f&quot;{d['a'] + 1}&quot;)  # 2
</code></pre>
<p>我们限定字符串的时候使用的是双引号，{} 里面必须是单引号。可能有人好奇，如果里面仍使用双引号，但通过反斜杠 \ 进行转义的话会怎么样呢？答案是不行的，因为 f-string 的 {} 里面不可以出现 \。注意：{} 是不可以出现 \，一个都不可以，所以也不要再想是不是可以使用两个 \ 进行转义啥的。</p>
<pre><code class="language-Python">try:
    print(f&quot;{\\}&quot;)
except Exception as e:
    pass
# 我们即便使用异常捕获，也是无用的，依旧会抛出 SyntaxError
# 因为 try except 是捕捉运行时的错误
# 而 {} 里面出现反斜杠属于语法上的错误，在编译成字节码阶段就会检测出来
&quot;&quot;&quot;
    print(f&quot;{\\}&quot;)
          ^
SyntaxError: f-string expression part cannot include a backslash
&quot;&quot;&quot;
</code></pre>
<p>因此：使用 f-string 同样需要注意单双引号的问题，并且 {} 里面不可以出现反斜杠。如果真的需要反斜杠，那么可以将反斜杠赋值给一个变量，然后将变量传递到 {} 里面去。</p>
<pre><code class="language-Python">a = &quot;\\&quot;
print(f&quot;{a}&quot;)  # \
</code></pre>
<p>另外，使用 f-string 时一定要注意：<strong>{</strong> 和 <strong>}</strong> 的个数要匹配。</p>
<pre><code class="language-Python"># 如果不使用 f-string，没有任何问题
# 但是使用了f-string，那么会报错
# 因为里面出现了 { 但是却没有对应的 }
# 这段代码不会通过编译
print(f&quot;我永远喜欢{古明地觉&quot;)
&quot;&quot;&quot;
    print(f&quot;我永远喜欢{古明地觉&quot;)
          ^
SyntaxError: f-string: expecting '}'
&quot;&quot;&quot;
</code></pre>
<p>可能有人好奇了，如果我只是想单纯地输入 <strong>{</strong> 这个字符呢？答案是用两个 <strong>{</strong> 进行转义。</p>
<pre><code class="language-Python">print(f&quot;我永远喜欢{{古明地觉&quot;)
&quot;&quot;&quot;
我永远喜欢{古明地觉
&quot;&quot;&quot;

# } 也是同理，需要使用两个 }} 进行转义
print(f&quot;我永远喜欢古明地觉}}&quot;)
&quot;&quot;&quot;
我永远喜欢古明地觉}
&quot;&quot;&quot;

print(f&quot;我永远喜欢{{古明地觉}}&quot;)
&quot;&quot;&quot;
我永远喜欢{古明地觉}
&quot;&quot;&quot;
</code></pre>
<p>不过这就又产生了一个问题，如果我希望外面的 <strong>{}</strong> 表示限定符，里面的 <strong>{}</strong> 表示集合该怎么办？</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

# 打印的不是我们想要的结果
print(f&quot;{{name}}&quot;)
&quot;&quot;&quot;
{name}
&quot;&quot;&quot;

# 在内部的 {} 周围套上一层小括号即可
print(f&quot;{({name})}&quot;)
&quot;&quot;&quot;
{'古明地觉'}
&quot;&quot;&quot;

# 字典也是同理
print(f&quot;{{'name': name}}&quot;)
print(f&quot;{({'name': name})}&quot;)
&quot;&quot;&quot;
{'name': name}
{'name': '古明地觉'}
&quot;&quot;&quot;
</code></pre>
<p>还有字符串的拼接：</p>
<pre><code class="language-Python"># 等价于 &quot;你好世界&quot;
s = &quot;你好&quot; &quot;世界&quot;
print(s)  # 你好世界

name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;
# 每一部分都要带上 f
s = f&quot;{name}&quot; f&quot;{address}&quot;
print(s)  # 古明地觉,地灵殿

s = f&quot;{name}&quot; &quot;{address}&quot;
print(s)  # 古明地觉{address}

# 多行显示也是同理
s = (f&quot;{name}&quot;
     f&quot;{address}&quot;)
print(s)  # 古明地觉地灵殿
</code></pre>
<p>最后则是 lambda 表达式的问题。</p>
<pre><code class="language-Python"># 使用 lambda 表达式的时候一定要使用括号括起来
# 否则会将 lambda 中的 : 解释成表达式与格式描述符之间的分隔符
print(f&quot;{(lambda x: x + 123)(123)}&quot;)  # 246
</code></pre>
<h2 id="小结-1"><a class="header" href="#小结-1">小结</a></h2>
<p>个人觉得 f-string 算是 Python3.6 新增的一大亮点，虽然有着一些限制，但是这都不是什么问题，毕竟在做分词解析的时候肯定是有一些限制的，但总体来说 f-string 是非常强大的一个工具了。因此在格式化字符串的时候，推荐使用f-string，相信它一定可以在格式化字符串的时候给你提供很大的帮助。</p>
<p>对了，再补充一点，在 3.8 的时候给 f-string 增加了一个功能：</p>
<pre><code class="language-Python">num = 123

print(f&quot;{num=}&quot;)
print(f&quot;{num =}&quot;)
print(f&quot;{num = }&quot;)
&quot;&quot;&quot;
num=123
num =123
num = 123
&quot;&quot;&quot;
# 可以看到加上了 =，还会将 {} 里面的内容输出出来
# 像我们之前的例子
print(f&quot;sum([1, 2, 3]) = {sum([1, 2, 3])}&quot;)
&quot;&quot;&quot;
sum([1, 2, 3]) = 6
&quot;&quot;&quot;
# 加上 = 就会简洁很多
print(f&quot;{sum([1, 2, 3]) = }&quot;)
&quot;&quot;&quot;
sum([1, 2, 3]) = 6
&quot;&quot;&quot;

print(f&quot;{1 + 1 = }&quot;)
&quot;&quot;&quot;
1 + 1 = 2
&quot;&quot;&quot;

print(f&quot;{len('古明地觉') = }&quot;)
&quot;&quot;&quot;
len('古明地觉') = 4
&quot;&quot;&quot;
</code></pre>
<p>以上就是 f-string 相关的内容，这些用法你是不是都了如指掌呢？</p>
<div style="break-before: page; page-break-before: always;"></div><p>关于日期处理，Python 提供了很多的库，比如标准库 datetime、第三方库 dateutil、arrow 等等。这里介绍一个我个人最喜欢的库 pendulum，用起来可以说非常的方便，任何对日期的操作它都能满足。</p>
<p>在使用之前需要先安装，直接 pip install pendulum 即可。</p>
<p>下面来看一下用法，首先是 datetime, date, time 的创建。</p>
<pre><code class="language-python">import pendulum

dt = pendulum.datetime(
    2022, 3, 28, 20, 10, 30)
print(dt.__class__)
print(dt)
&quot;&quot;&quot;
&lt;class 'pendulum.datetime.DateTime'&gt;
2022-03-28T20:10:30+00:00
&quot;&quot;&quot;
# 创建的对象是 DateTime 类型，并且带有时区，默认是 UTC
# 我们可以换一个时区
dt = pendulum.datetime(2022, 3, 28, 20, 10, 30, tz=&quot;Asia/Shanghai&quot;)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30+08:00
&quot;&quot;&quot;

# 如果不想要时区，那么指定 tz=None
dt = pendulum.datetime(2022, 3, 28, 20, 10, 30, tz=None)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30
&quot;&quot;&quot;

# 然后是 date 的创建
d = pendulum.date(2022, 3, 28)
print(d.__class__)
print(d)
&quot;&quot;&quot;
&lt;class 'pendulum.date.Date'&gt;
2022-03-28
&quot;&quot;&quot;

# time 的创建
t = pendulum.time(20, 10, 30)
print(t.__class__)
print(t)
&quot;&quot;&quot;
&lt;class 'pendulum.time.Time'&gt;
20:10:30
&quot;&quot;&quot;
</code></pre>
<p>创建 datetime 时，时区默认是 UTC。如果不想要时区，或者希望时区是本地时区，那么 pendulum 还专门提供了两个方法。</p>
<pre><code class="language-Python">import pendulum

# 创建 datetime 时设置为本地时区
# 还是调用了 pendulum.datetime 函数
# 但是 tz 被设置成了 pendulum.local_timezone()
dt = pendulum.local(2022, 3, 28, 20, 10, 30)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30+08:00
&quot;&quot;&quot;
print(pendulum.local_timezone())
&quot;&quot;&quot;
Timezone('Asia/Shanghai')
&quot;&quot;&quot;

# 创建 datetime 时不设置时区
# 内部也是调用了 pendulum.datetime 函数
# 但是 tz 为 None
dt = pendulum.naive(2022, 3, 28, 20, 10, 30)
print(dt)
&quot;&quot;&quot;
2022-03-28T20:10:30
&quot;&quot;&quot;
</code></pre>
<p>然后 pendulum 还提供了几个方法，比如创建当前的 datetime，date 等等。</p>
<pre><code class="language-Python">import pendulum

# 创建当前的 datetime，默认是本地时区，但时区可以指定
dt = pendulum.now()
print(dt)
&quot;&quot;&quot;
2022-05-29T20:40:49.632182+08:00
&quot;&quot;&quot;

# 创建当前的 date，但返回的仍是 datetime
# 只不过时分秒均为 0，同样可以指定时区
dt = pendulum.today()
print(dt)
&quot;&quot;&quot;
2022-05-29T00:00:00+08:00
&quot;&quot;&quot;

# 获取明天对应的 date，返回的是 datetime，时分秒为 0
# 时区可以指定，默认是本地时区
dt = pendulum.tomorrow()
print(dt)
&quot;&quot;&quot;
2022-05-30T00:00:00+08:00
&quot;&quot;&quot;

# 获取昨天对应的 date
dt = pendulum.yesterday()
print(dt)
&quot;&quot;&quot;
2022-05-28T00:00:00+08:00
&quot;&quot;&quot;
</code></pre>
<p>我们还可以根据时间戳或者字符串来创建：</p>
<pre><code class="language-Python">import pendulum

# 根据时间戳创建
dt1 = pendulum.from_timestamp(1653828466)
dt2 = pendulum.from_timestamp(1653828466, tz=pendulum.local_timezone())
print(dt1)
print(dt2)
&quot;&quot;&quot;
2022-05-29T12:47:46+00:00
2022-05-29T20:47:46+08:00
&quot;&quot;&quot;

# 根据字符串创建
dt1 = pendulum.parse(&quot;2020-05-03 12:11:33&quot;)
dt2 = pendulum.parse(&quot;2020-05-03 12:11:33&quot;, tz=pendulum.local_timezone())
print(dt1)
print(dt2)
&quot;&quot;&quot;
2020-05-03T12:11:33+00:00
2020-05-03T12:11:33+08:00
&quot;&quot;&quot;
</code></pre>
<p>datetime、date、time 的创建我们说完了，然后再来看看它们支持的操作，这也是最核心的部分。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 28, 20, 10, 30)

# 获取 date 部分和 time 部分
print(dt.date())
print(dt.time())
&quot;&quot;&quot;
2022-03-28
20:10:30
&quot;&quot;&quot;

# 替换掉 dt 的某部分，返回新的 datetime
# 年月日时分秒、以及时区都可以替换
print(dt.replace(year=9999))
&quot;&quot;&quot;
9999-03-28T20:10:30+08:00
&quot;&quot;&quot;

# 转成时间戳
print(dt.timestamp())
&quot;&quot;&quot;
1648469430.0
&quot;&quot;&quot;

# 返回年、月、日、时、分、秒、时区
print(dt.year, dt.month, dt.day)
print(dt.hour, dt.minute, dt.second)
print(dt.tz)
&quot;&quot;&quot;
2022 3 28
20 10 30
Timezone('Asia/Shanghai')
&quot;&quot;&quot;
</code></pre>
<p>然后是生成字符串，pendulum.DateTime 对象可以转成各种格式的日期字符串。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 28, 20, 10, 30)

# 下面四个最为常用
print(&quot;datetime:&quot;, dt.to_datetime_string())
print(&quot;date:&quot;, dt.to_date_string())
print(&quot;time:&quot;, dt.to_time_string())
print(&quot;iso8601:&quot;, dt.to_iso8601_string())
&quot;&quot;&quot;
datetime: 2022-03-28 20:10:30
date: 2022-03-28
time: 20:10:30
iso8601: 2022-03-28T20:10:30+08:00
&quot;&quot;&quot;
# 当然还支持很多其它格式，不过用的不多，随便挑几个吧
print(&quot;atom:&quot;, dt.to_atom_string())
print(&quot;rss:&quot;, dt.to_rss_string())
print(&quot;w3c:&quot;, dt.to_w3c_string())
print(&quot;cookie:&quot;, dt.to_cookie_string())
print(&quot;rfc822:&quot;, dt.to_rfc822_string())
&quot;&quot;&quot;
atom: 2022-03-28T20:10:30+08:00
rss: Mon, 28 Mar 2022 20:10:30 +0800
w3c: 2022-03-28T20:10:30+08:00
rfc822: Mon, 28 Mar 22 20:10:30 +0800
&quot;&quot;&quot;
</code></pre>
<p>我们有时也需要判断当前日期是星期几、在当前这一年是第几天等等，pendulum 也已经帮我们封装好了。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 28, 20, 10, 30)

# 返回星期几
# 注意：星期一到星期天分别对应 1 到 7
print(dt.isoweekday())  # 1

# 返回一年当中的第几天
# 范围是 1 到 366
print(dt.day_of_year)  # 87

# 返回一个月当中的第几天
print(dt.days_in_month)  # 31

# 返回一个月当中的第几周
print(dt.week_of_month)  # 5

# 返回一年当中的第几周
print(dt.week_of_year)  # 13

# 是否是闰年
print(dt.is_leap_year())  # False
</code></pre>
<p>最后就是日期的运算，这是 pendulum 最为强大的地方，至于为什么强大，我们演示一下就知道了。</p>
<pre><code class="language-Python">import pendulum

dt = pendulum.local(2022, 3, 30, 20, 10, 30)

# 返回下一个月的今天
print(dt.add(months=1))
&quot;&quot;&quot;
2022-04-30T20:10:30+08:00
&quot;&quot;&quot;

# 返回上一个月的今天
# 但是上一个月是 2 月，并且是平年，所以最多 28 天
print(dt.add(months=-1))
&quot;&quot;&quot;
2022-02-28T20:10:30+08:00
&quot;&quot;&quot;
# 我们看到处理的非常完美
# 该方法的原型如下，年月日时分秒都是支持的，当然还有星期也支持
&quot;&quot;&quot;
def add(
    self,
    years=0,
    months=0,
    weeks=0,
    days=0,
    hours=0,
    minutes=0,
    seconds=0,
    microseconds=0,
):
&quot;&quot;&quot;
</code></pre>
<p>像 Python 的内置模块 datetime 在将日期相加的时候，最多支持到天，我们无法计算下一周、下一个月、下一年的日期。而 pendulum 则可以很方便地处理，这也是我最喜欢的一点。当然啦，add 里面的值为正，相当于日期往后退；值为负，相当于日期往前推。</p>
<p>然后是两个日期还可以做减法：</p>
<pre><code class="language-Python">import pendulum

dt1 = pendulum.local(2021, 1, 20, 11, 22, 33)

dt2 = pendulum.local(2022, 3, 30, 20, 10, 30)

period = dt2 - dt1
# 返回的是 Period 对象，相当于 datetime 模块里面的 timedelta
print(period.__class__)
&quot;&quot;&quot;
&lt;class 'pendulum.period.Period'&gt;
&quot;&quot;&quot;

# 但是功能方面，Period 要强大很多
# 两者差了多少年
print(period.in_years())  # 1
# 两者差了多少个月
print(period.in_months())  # 14
# 两者差了多少个星期
print(period.in_weeks())  # 62
# 两者差了多少天
print(period.in_days())  # 434
# 两者差了多少个小时
print(period.in_hours())  # 10424
# 两者差了多少分钟
print(period.in_minutes())  # 625487
# 两者差了多少秒
print(period.in_seconds())  # 37529277
</code></pre>
<p>功能非常强大，Python 的 datetime 模块里面的 timedelta 最多只能计算两个日期差了多少天，而这里年月日时分秒均可。</p>
<p>以上就是本文的内容，当然 pendulum 的功能其实不止我们上面说的那些，有兴趣的话可以参考官网，但常用的差不多就这些东西。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-2"><a class="header" href="#楔子-2">楔子</a></h2>
<p>导入一个模块，我们一般都会使用 import 关键字，但有些场景下 import 难以满足我们的需要。所以除了 import 之外还有很多其它导入模块的方式，下面就来介绍一下。</p>
<h2 id="__import__"><a class="header" href="#__import__">__import__</a></h2>
<p>这是一个内置函数，解释器在 import 的时候，实际上就执行了这个函数。</p>
<pre><code class="language-python"># import os 等价于如下方式
os = __import__(&quot;os&quot;)
print(os)  # &lt;module 'os' from 'C:\\python38\\lib\\os.py'&gt;

# 但是这种方式不能多级导入
path = __import__(&quot;os.path&quot;)
print(path)  # &lt;module 'os' from 'C:\\python38\\lib\\os.py'&gt;
# 可以看到，导入的仍是 os，而不是 os.path

# 如果想导入子模块，需要一个参数 fromlist
# 我们给它传一个非空列表即可
path = __import__(&quot;os.path&quot;, fromlist=[&quot;&quot;])
print(path)  # &lt;module 'ntpath' from 'C:\\python38\\lib\\ntpath.py'&gt;
</code></pre>
<p>但是官方不建议使用这个函数，因为它是专门给解释器用的，我们可以使用一个模块。</p>
<pre><code class="language-Python">import importlib

os = importlib.import_module(&quot;os&quot;)
print(os)  # &lt;module 'os' from 'C:\\python38\\lib\\os.py'&gt;

# 可以多级导入
path = importlib.import_module(&quot;os.path&quot;)
print(path)  # &lt;module 'ntpath' from 'C:\\python38\\lib\\ntpath.py'&gt;
</code></pre>
<p>所以当导入的模块名以字符串的形式存在时，就可以使用这种方式。</p>
<h2 id="importlibmachinery"><a class="header" href="#importlibmachinery">importlib.machinery</a></h2>
<p>importlib.machinery 里面提供了三种 Loader，可以让我们以打开文件的方式导入一个模块。</p>
<pre><code class="language-Python">from importlib.machinery import (
    SourceFileLoader,  # 导入源文件
    SourcelessFileLoader,  # 导入 pyc 文件
    ExtensionFileLoader  # 导入扩展文件
)

# 参数一：给模块起个名字
# 参数二：文件路径
os = SourceFileLoader(
    &quot;我是 os 模块&quot;,
    r&quot;C:\python38\lib\os.py&quot;
).load_module()
print(os)
&quot;&quot;&quot;
&lt;module '我是 os 模块' from 'C:\\python38\\lib\\os.py'&gt;
&quot;&quot;&quot;
print(os.path.join(&quot;video&quot;, &quot;overwatch&quot;, &quot;hanzo.mp4&quot;))
&quot;&quot;&quot;
video\overwatch\hanzo.mp4
&quot;&quot;&quot;

# 我们看到结果一切正常，但有一点需要注意
# 如果是导入包的话，那么要导入包里面的 __init__.py 文件
pd = SourceFileLoader(
    &quot;我是 pandas 模块&quot;,
    r&quot;C:\python38\lib\site-packages\pandas\__init__.py&quot;
).load_module()
print(pd.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [4, 5, 6]}))
&quot;&quot;&quot;
   a  b
0  1  4
1  2  5
2  3  6
&quot;&quot;&quot;

# 如果只写到 pandas，那么会抛出 PermissionError，因为不能把目录当成文件来读取
# 至于 import 一个包，本质上也是加载包内部的 __init__.py 
# 但这里需要显式地加上 __init__.py
</code></pre>
<p>同理加载 pyc 和 pyd 也是类似的，但需要注意的是，加载普通文件和 pyc 文件时，我们可以随便起名字，也就是第一个参数任意。但对于 pyd 文件，第一个参数必须和 pyd 文件的名字保持一致。</p>
<h2 id="通过-module-类创建模块"><a class="header" href="#通过-module-类创建模块">通过 module 类创建模块</a></h2>
<p>Python 一切皆对象，模块自然也不例外。既然是对象，那么必然就会有相应的类来实例化它。</p>
<pre><code class="language-Python">import os
import hashlib
import numpy

# os.__class__ 等价于 type(os)
print(os.__class__)  # &lt;class 'module'&gt;
print(hashlib.__class__)  # &lt;class 'module'&gt;
print(numpy.__class__)  # &lt;class 'module'&gt;
</code></pre>
<p>在 Python 里面，我们一般会把单独的可导入文件称之为<strong>模块</strong>，把包含多个模块的目录称之为<strong>包</strong>。通过模块和包，我们可以对项目进行功能上的划分，分门别类地进行组织。但不管是模块、还是包，它们都是 module 这个类的实例对象，打印结果也能说明这一点。所以从解释器的角度来看的话，模块和包区分的并没有那么明显，直接把包看做是包内部的 __init__.py 即可。</p>
<p>既然模块的类型是 &lt;class 'module'&gt;，那么我们是不是也可以通过调用类型对象的方式创建呢？显然是可以的，但是 module 这个类解释器没有暴露给我们，直接用的话会提示<strong>变量 module 未定义</strong>。所以只能先随便导入一个模块，然后通过 type 函数或者 __class__ 属性获取。</p>
<pre><code class="language-python"># 当然 types 模块内部已经帮我们做好了
# ModuleType = type(sys)
from types import ModuleType

print(ModuleType)  # &lt;class 'module'&gt;

# 类对象有了，下面就可以创建了
# module 类接收两个参数
# 参数一：模块的名字，必须传递
# 参数二：模块的 doc，不传默认为 None
satori = ModuleType(&quot;古明地觉&quot;, &quot;模块的名字是一个女孩，她来自地灵殿&quot;)
print(satori)  # &lt;module '古明地觉'&gt;
print(satori.__doc__)  # 模块的名字是一个女孩，她来自地灵殿


# 但此时模块里面是没啥东西的，我们加一些属性吧
# 操作模块本质上是在操作它的属性字典
code = &quot;&quot;&quot;
age = 16

def foo():
    return &quot;^_^&quot;
&quot;&quot;&quot;
# 执行 code，结果会体现在 satori 的属性字典中
exec(code, satori.__dict__)
print(satori.age)  # 16
print(satori.foo())  # ^_^
</code></pre>
<p>需要注意的是里面 exec 函数，它会把字符串当成代码来执行，所以这就要求字符串的来源必须是可靠的，我们能够确保不会出现恶意内容。而如果是用户传递的字符串，那么绝不能用 exec 来执行，当然 eval 也是同理。</p>
<p>然后是 exec 的第二个参数，表示执行时的名字空间，默认是全局名字空间。所以当不指定第二个参数时，exec(code) 相当于创建了两个全局变量：age 和 foo。</p>
<pre><code class="language-Python">code = &quot;&quot;&quot;
age = 16

def foo():
    return &quot;^_^&quot;
&quot;&quot;&quot;

exec(code)
print(age)  # 16
print(foo())  # ^_^
</code></pre>
<p>但是我们在执行的时候，将它换成了 satori.__dict__，所以结果相当于给模块添加了两个变量，或者说属性。</p>
<h2 id="将一个类的实例变成一个模块"><a class="header" href="#将一个类的实例变成一个模块">将一个类的实例变成一个模块</a></h2>
<p>如果想将一个类的实例变成模块，那么这个类应该继承 ModuleType。</p>
<pre><code class="language-python">import sys
from types import ModuleType


class A(ModuleType):

    def __init__(self, module_name):
        super().__init__(module_name)

    def __getattr__(self, item):
        return f&quot;不存在的属性: {item}&quot;

    def __setattr__(self, key, value):
        self.__dict__[key] = value

    def __str__(self):
        return f&quot;&lt;module '{self.__name__}' from '我来自于虚无'&gt;&quot;


a = A(&quot;我是 A&quot;)
print(a)  # &lt;module '我是 A' from '我来自于虚无'&gt;
print(a.__name__)  # 我是 A
print(a.xx)  # 不存在的属性: xx
a.xx = &quot;xx&quot;
print(a.xx)  # xx

# 加入到 sys.modules 中
sys.modules[&quot;嘿嘿&quot;] = a
import 嘿嘿
print(嘿嘿.xx)  # xx
print(嘿嘿.yy)  # 不存在的属性: yy
</code></pre>
<p>是不是很好玩呢？</p>
<h2 id="小结-2"><a class="header" href="#小结-2">小结</a></h2>
<p>以上就是加载模块的几种方式，主要用途如下：</p>
<ul>
<li>导入一个在 sys.path 中的模块，并且模块名已知，那么直接使用 import 关键字即可；</li>
<li>导入一个在 sys.path 中的模块，但模块名是运行时的一个字符串，那么使用 importlib 模块的 import_module 函数；</li>
<li>导入一个不在 sys.path 中的模块，使用 importlib.machinery 的各种 Loader，只要把模块的路径传进去即可。当然啦，位于 sys.path 中的模块也可以使用该方法，但显然此时使用前两种更为方便；</li>
<li>直接创建一个模块，通过继承 module 类来实现，并且还可以加入到 sys.modules 中。Python 有一个第三方模块叫 sh，顾名思义是用来执行 Linux Shell 命令的，它内部就使用了继承 module 类来创建模块的这种方式。但是要知道 module 这个类解释器没有暴露给我们，我们需要通过 type(模块) 或者 模块.__class__ 的方式获取；</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>如果想主动退出 Python 程序，那么可以使用 exit, quit, sys.exit, os._exit 这四个函数，而这些函数之间有什么区别呢？</p>
<p>首先来说前三个，exit, quit, sys.exit 退出程序的原理是一样的，只不过 exit 和 quit 用在交互式环境中，sys.exit 用在非交互式环境中。当然啦，无论是交互式还是非交互式，这三个函数都是适用的。至于这个三个函数所做的事情，实际上就是 raise 一个 SystemExit 异常。如果没有捕获这个异常，那么程序就会退出。</p>
<pre><code class="language-python">import sys
sys.exit(100)
print(&quot;程序退出，这里不会打印&quot;)
</code></pre>
<p>当执行 sys.exit 的时候，会抛出 SystemExit，这里我们没有捕获它，所以程序会退出。并且函数接收一个整数，表示程序退出时的状态码。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./1.png" alt="" /></p>
<p>这里我用的 Cursor，结尾会显示程序退出时的状态码，可以看到结果是我们设置的 100。一般来说，如果程序正常退出，那么状态码为 0；程序执行出错，状态码为 1。当然啦，如果是解释器执行时内部出问题了，那么会抛出一个乱七八糟的状态码，不过这种情况基本只有在写 C 扩展的时候才会遇到。。</p>
<p>我们说 quit, exit, sys.exit 都可以接收一个整数，表示退出时的状态码。但如果接收的不是整数，那么会将参数作为打印信息输出到 stderr（标准错误输出）中，然后退出程序，并且状态码为 1。</p>
<pre><code class="language-Python">import sys
sys.exit(&quot;我退出啦&quot;)
</code></pre>
<p>执行一下看看。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./2.png" alt="" /></p>
<p>这三个函数的工作原理是 raise 一个 SystemExit 异常，那如果将其捕获了，程序是不是就不退出了，答案是肯定的。</p>
<pre><code class="language-Python">import sys

try:
    sys.exit(100)
except SystemExit:
    print(&quot;程序想要退出，但被捕获了&quot;)
print(&quot;正常打印&quot;)
</code></pre>
<p>执行一下，看看结果。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./3.png" alt="" /></p>
<p>结果确实如我们所料，将 sys.exit 引发的异常捕获掉之后，程序正常执行。所以最后状态码是 0，因为程序是正常结束的。那么问题来了，我们能不能手动抛一个 SystemExit 呢？</p>
<pre><code class="language-Python">print(&quot;我要抛异常了&quot;)
raise SystemExit(233)
print(&quot;此处不会执行&quot;)
</code></pre>
<p>SystemExit 里面也可以接收一个整数，会作为状态码返回；如果接收的不是整数，那么会将参数作为打印信息输出到 stderr 当中，并且状态码为 1。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./4.png" alt="" /></p>
<p>和 sys.exit 的表现是一样的，因为 sys.exit 本质上就是 raise 一个 SystemExit。并且我们看到在 raise SystemExit 的时候，并没有出现异常回溯栈，或者说没有看到 Traceback (most recent call last): 这样的字眼。所以说 SystemExit 是不像异常的异常，因为没有任何的错误信息出现。并且注意：SystemExit 继承自 BaseException，不是 Exception。</p>
<p>因此结论很清晰了，sys.exit 是通过引发 SystemExit 异常来退出程序的，我们可以捕获此异常做一些清理工作，甚至可以阻挠程序退出。当然，quit 和 exit 这两个内置函数也是同样的工作原理，只不过它们一般用在交互式环境中，但非交互式环境也能用。</p>
<pre><code class="language-python">try:
    exit(&quot;我想退出&quot;)
except SystemExit:
    print(&quot;exit，别做梦了&quot;)

try:
    quit(&quot;我想退出&quot;)
except SystemExit:
    print(&quot;quit，别做梦了&quot;)

exit(&quot;这下我真的退出了&quot;)
</code></pre>
<p>前面三个退出函数我们就说完了，再来看看最后一个，也就是 os._exit。它就比较厉害了，在底层会调用 C 语言的 exit 函数，相当于强制退出。</p>
<pre><code class="language-Python">import os

try:
    os._exit(233)
except Exception:
    print(&quot;会打印吗&quot;)
print(&quot;会打印吗&quot;)
</code></pre>
<p>下面的 print 会打印吗？执行一下看看。</p>
<p><img src="exit%E3%80%81quit%E3%80%81sys.exit%E3%80%81os._exit%EF%BC%8C%E8%BF%99%E4%B9%88%E5%A4%9A%E9%80%80%E5%87%BA%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F/./5.png" alt="" /></p>
<p>并没有执行，因此 os._exit 属于强制退出，无法被阻止。因此它一般用于子进程的退出，我们在主进程中退出的话一般使用 sys.exit。</p>
<p>最后 os._exit 还有一个不同的地方，就是它必须接收一个整数作为退出时的状态码，否则报错。</p>
<pre><code class="language-python">import os

try:
    os._exit(&quot;xx&quot;)
except TypeError as e:
    print(e)
print(&quot;正常执行&quot;)
&quot;&quot;&quot;
an integer is required (got type str)
正常执行
&quot;&quot;&quot;
</code></pre>
<p>此时程序是可以正常执行下去的，因为 os._exit 接收的参数类型不对，导致该函数并没有执行，而是直接抛出了 TypeError。</p>
<p>以上就是这几个退出函数之间的区别。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-3"><a class="header" href="#楔子-3">楔子</a></h2>
<p>文件处理是程序开发中经常会遇到的一个问题，比如文件是否存在，是否可读、可写、可执行，查看文件的状态，文件的读写操作等等。</p>
<p>本篇文章将会介绍一些最佳实践，让你在处理文件的时候更加得心应手。另外我们知道 Linux 一切皆文件，大致有以下七种。</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./1.png" alt="" /></p>
<p>而本篇文章所说的文件并不单单指普通文件，而是指所有类型的文件。</p>
<h2 id="文件是否存在是否可读可写可执行"><a class="header" href="#文件是否存在是否可读可写可执行">文件是否存在、是否可读可写可执行</a></h2>
<p>针对这个需求，我推荐使用 os.access 函数。使用该函数一般传递两个参数即可，参数一是文件路径，参数二是模式，而模式有以下四种：</p>
<ul>
<li>os.F_OK：判断文件是否存在；</li>
<li>os.R_OK：判断文件是否可读；</li>
<li>os.W_OK：判断文件是否可写；</li>
<li>os.X_OK：判断文件是否可执行；</li>
</ul>
<p>我们测试一下：</p>
<pre><code class="language-python">import os

# 文件是否存在
os.access(&quot;main.c&quot;, os.F_OK)
# 文件是否可读
os.access(&quot;main.c&quot;, os.R_OK)
# 文件是否可写
os.access(&quot;main.c&quot;, os.W_OK)
# 文件是否可执行
os.access(&quot;main.c&quot;, os.X_OK)

# 返回的都是布尔值
</code></pre>
<p>可读、可写、可执行在工作中遇到的不是很多，更多的还是判断是否存在。</p>
<h2 id="文件的状态"><a class="header" href="#文件的状态">文件的状态</a></h2>
<p>文件的状态一般包含以下几种：</p>
<ul>
<li>文件的类型，比如普通文件、目录文件等等；</li>
<li>文件的访问权限；</li>
<li>文件的最后访问时间、修改时间等等；</li>
<li>文件的大小（普通文件）；</li>
</ul>
<p>在 Python 里面要如何获取文件状态呢？实际上获取文件状态都是通过系统调用来完成的，而 os.stat 函数可以帮我们实现这一点。</p>
<pre><code class="language-Python">import os

# 接收一个路径，或者文件描述符
stat = os.stat(&quot;main.c&quot;)
# 返回一个 os.stat_result 对象
print(stat)
&quot;&quot;&quot;
os.stat_result(
st_mode=33206, st_ino=37999121855938744, 
st_dev=2993193685, st_nlink=1, st_uid=0, 
st_gid=0, st_size=3375, st_atime=1652539604, 
st_mtime=1652539604, st_ctime=1652537628)
&quot;&quot;&quot;
print(stat.st_mode)
print(stat.st_ino)
print(stat.st_dev)
print(stat.st_nlink)
print(stat.st_uid)
print(stat.st_gid)
print(stat.st_size)
print(stat.st_atime)
print(stat.st_mtime)
print(stat.st_ctime)
</code></pre>
<p>里面的字段包含了文件的全部信息，我们来介绍常用的。</p>
<h3 id="st_mode"><a class="header" href="#st_mode">st_mode</a></h3>
<p>我们先在 CentOS 上使用 ll 命令查看某个文件，观察它的输出信息：</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./2.png" alt="" /></p>
<p>注意红色框框里面的部分，总共十个字符，首先是第一个字符，表示文件类型。<strong>-</strong> 代表普通文件，<strong>d</strong> 代表目录文件，<strong>b</strong> 代表块设备文件，<strong>c</strong> 代表字符设备文件，<strong>p</strong> 代表管道文件，<strong>l</strong> 代表链接文件。显然这里是普通文件。</p>
<p>然后是剩余的九个字符，分为三组，分别代表 文件所有者、文件所属组、其它用户 的操作权限，顺序都是 rwx，即是否可读、可写、可执行。如果显示的是 <strong>-</strong>，那么代表不具备相应的权限；如果显示的是具体的字符，那么代表具备相应的权限。</p>
<p>比如 main.c 的文件所有者具备对 main.c 的可读可写权限，而其它用户则只有可读权限。好了，前置知识介绍完毕，下面看 st_mode。</p>
<pre><code class="language-Python">import os

stat = os.stat(&quot;main.c&quot;)
print(
    bin(stat.st_mode)
)  # 0b1000000110100100
</code></pre>
<p>需要转成二进制观察，我们先看后九位，110_100_100，分别对应 文件所有者、文件所属组、其它用户 的操作权限。每三位对应的都是 rwx，为 1 表示具有相关权限，为 0 表示不具有，所以它们都具有可读权限，没有可执行权限。</p>
<ul>
<li>100：具备可读权限，转成十进制（八进制）结果为 4；</li>
<li>010：具备可写权限，转成十进制（八进制）结果为 2；</li>
<li>001：具备可执行权限，转成十进制（八进制）结果为 1；</li>
<li>110：具备可读可写权限，转成十进制（八进制）结果为 6；</li>
<li>011：具备可写可执行权限，转成十进制（八进制）结果为 3；</li>
<li>101：具备可读可执行权限，转成十进制（八进制）结果为 5；</li>
<li>111：具备可读可写可执行权限，转成十进制（八进制）结果为 7；</li>
</ul>
<pre><code class="language-python">import os

stat = os.stat(&quot;main.c&quot;)
# 右移 6 位，然后和 0b111 做按位与
# 可以计算出文件所有者的权限
print(stat.st_mode &gt;&gt; 6 &amp; 0b111)  # 6
# 右移 3 位，然后和 0b111 做按位与
# 可以计算出文件所属组的权限
print(stat.st_mode &gt;&gt; 3 &amp; 0b111)  # 4
# 计算其它用户的权限
print(stat.st_mode &amp; 0b111)  # 4
</code></pre>
<p>当然了，这种情况更建议使用 os.access 进行判断，会更方便一些。</p>
<p>好，后九位我们看完了，它代表的是三个权限。而前面的位，也就是 st_mode 右移 9 位之后的结果，则代表文件的类型。</p>
<pre><code class="language-Python">import os
import stat

st_mode = os.stat(&quot;main.c&quot;).st_mode
# 是否是普通文件
# 如果是返回非 0，否则返回 0
print(st_mode &amp; stat.S_IFREG)  # 32768
# 不过上面的方式比较麻烦
# stat 模块已经帮我们封装好了相应的函数
print(stat.S_ISREG(st_mode))  # True
# 是否是目录文件
print(stat.S_ISDIR(st_mode))  # False
# 是否是块设备
print(stat.S_ISBLK(st_mode))  # False
# 是否是字符设备文件
print(stat.S_ISCHR(st_mode))  # False
# 是否是套接字文件
print(stat.S_ISSOCK(st_mode))  # False
# 是否是管道文件
print(stat.S_ISFIFO(st_mode))  # False
# 是否是链接文件
print(stat.S_ISLNK(st_mode))  # False
</code></pre>
<h3 id="st_uid-和-st_gid"><a class="header" href="#st_uid-和-st_gid">st_uid 和 st_gid</a></h3>
<p>文件所有者和所属组的 id，这个在 Windows 上一般都是 0，无需太关注。</p>
<h3 id="st_size"><a class="header" href="#st_size">st_size</a></h3>
<p>文件的大小，这个也是比较常用的。每个文件有多大，操作系统帮我们记录好了，直接获取即可。</p>
<pre><code class="language-Python">import os

stat = os.stat(r&quot;main.c&quot;)
print(stat.st_size)  # 35
</code></pre>
<h3 id="st_atimest_mtimest_ctime"><a class="header" href="#st_atimest_mtimest_ctime">st_atime、st_mtime、st_ctime</a></h3>
<p>分别表示访问时间、修改时间、创建时间，都是时间戳。</p>
<h2 id="如何设置文件的缓冲区"><a class="header" href="#如何设置文件的缓冲区">如何设置文件的缓冲区</a></h2>
<p>像磁盘、网卡之类的硬件设备只有操作系统的内核才有权限操作，我们开发的应用程序是没有权限的。于是操作系统把对磁盘、网卡之类的硬件相关的操作封装成了一个个的系统调用，应用程序通过这些系统调用便可借助内核来操作硬件设备。</p>
<p>而将内存中的数据写入到磁盘也不例外，它也会触发相应的系统调用，而系统调用的 I/O 是比较耗时的。还有磁盘，磁盘属于块设备，它写入数据时，不是以字节为单位、而是以块为单位写入的。假设一个块是 4096 个字节，那么写 1 个字节和写 4096 个字节耗时是一样的。</p>
<p>所以在写入数据的时候，不能来一个字节就触发一次系统调用，而是应该有一个缓冲区，这个缓冲区和块大小是一致的。当缓冲区满了，那么再一次性写入，这样能够提高效率。</p>
<p>在 Python 里面，缓冲区的大小是多大呢？又要如何设置呢？</p>
<pre><code class="language-Python"># 以二进制模式打开
f = open(&quot;main.c&quot;, &quot;wb&quot;)
</code></pre>
<p>首先解释器会从内核中读取磁盘的块大小，然后让缓冲区大小和磁盘的块大小保持一致。要是找不到磁盘的块大小（基本都能找到），则使用 io.DEFAULT_BUFFER_SIZE，这个值等于 8192。</p>
<p>一般来说，磁盘的块大小都是可以读出来的，大小为 4096。假设已经写了 4096 个字节，此时缓冲区已满，那么当写入第 4097 个字节时，缓冲区的 4096 个字节就会刷到磁盘上。然后写入的第 4097 个字节，就会成为缓冲区里面的第一个字节，这种模式也被称为<strong>全缓冲</strong>。</p>
<p>如果以二进制模式打开，缓冲区就是当前描述的这样，但如果是以文本模式打开呢？</p>
<pre><code class="language-Python">binary_write = open(&quot;main.c&quot;, &quot;wb&quot;)
print(binary_write)
&quot;&quot;&quot;
&lt;_io.BufferedWriter name='main.c'&gt;
&quot;&quot;&quot;

text_write = open(&quot;main.c&quot;, &quot;w&quot;)
print(text_write)
print(text_write.buffer)
&quot;&quot;&quot;
&lt;_io.TextIOWrapper name='main.c' mode='w' encoding='cp936'&gt;
&lt;_io.BufferedWriter name='main.c'&gt;
&quot;&quot;&quot;

binary_read = open(&quot;main.c&quot;, &quot;rb&quot;)
print(binary_read)
&quot;&quot;&quot;
&lt;_io.BufferedReader name='main.c'&gt;
&quot;&quot;&quot;

text_read = open(&quot;main.c&quot;, &quot;r&quot;)
print(text_read)
print(text_read.buffer)
&quot;&quot;&quot;
&lt;_io.TextIOWrapper name='main.c' mode='r' encoding='cp936'&gt;
&lt;_io.BufferedReader name='main.c'&gt;
&quot;&quot;&quot;
</code></pre>
<ul>
<li>如果以二进制模式写入（wb），那么文件句柄的类型为 BufferedWriter；以文本模式写入（w），那么文件句柄的类型为 TextIOWrapper；</li>
<li>如果以二进制模式读取（rb），那么文件句柄的类型为 BufferedReader；以文本模式读取（r），那么文件句柄的类型仍为 TextIOWrapper；</li>
</ul>
<p>但是需要注意 TextIOWrapper 有一个属性叫 buffer，对应的正是以二进制模式打开时的文件句柄。所以文本模式打开（包含读取和写入），实际上还是基于二进制打开进行的一层封装。</p>
<pre><code class="language-Python">f = open(&quot;main.c&quot;, &quot;w&quot;)
# 可以通过如下方式写入
f.write(&quot;abc&quot;)
# 也可以使用如下方式写入
f.buffer.write(b&quot;abc&quot;)
</code></pre>
<p>而 TextIOWrapper 这一层也是有缓冲区的，它的大小一般是 8192 个字节。如果缓冲区满了，再写入 BufferedWriter 的缓冲区，BufferWriter 的缓冲区满了，再写入到磁盘。所以从这个角度看，二进制模式打开比文本模式打开要更快一些，因为计算机存储的数据就是二进制格式的。</p>
<p>另外我们说 TextIOWrapper 是基于 BufferedWriter（读取的话是 BufferedReader，这里以写入为例）进行的封装，但其实 BufferedWriter 下面还有一层，叫 raw，而 raw 这一层是无缓冲的。</p>
<pre><code class="language-Python"># 以二进制模式打开，缓冲区为 4096
f = open(&quot;main.c&quot;, &quot;wb&quot;)
# 会立即写入磁盘，因为这一层没有缓冲区
# 它可以看做是调用操作系统提供的原生接口
f.raw.write(b&quot;abc&quot;)

# 缓冲区大小为 4096，刚好满
f.write(b&quot;a&quot; * 4096)
# 但是到这里为止，缓冲区的数据还没有进入磁盘
# 如果你在此处 sleep 一会，然后查看文件
# 你会发现文件里面只有 abc 这三个字符

# 好，此时又来一个字符，缓冲区容不下了
# 必须先将已有的 4096 个字节写入磁盘
# 而写入是通过调用 f.raw 写入的
f.write(b&quot;b&quot;)
</code></pre>
<p>文本模式也是同理，它是在二进制模式的基础之上又构建了一层。</p>
<pre><code class="language-python"># 以文本模式打开，缓冲区为 8192
f = open(&quot;main.c&quot;, &quot;w&quot;)
# TextIOWrapper -&gt; BufferedWriter -&gt; raw
# 此时缓冲区刚好满
f.write(&quot;a&quot; * 8192)
# 再写入一个字符
f.write(&quot;b&quot;)

# 缓冲区容不下了，于是会将已有的 8192 字节写入 f.buffer 的缓冲区
# f.buffer 是以二进制模式打开的文件句柄
# 因为文本模式打开是构建在二进制模式打开的基础之上的
# 然后再通过 f.buffer.raw 将数据写入磁盘
</code></pre>
<p>因此，如果你希望写入的内容立刻刷到磁盘上，除了使用 flush 之外，还可以这么做。</p>
<pre><code class="language-Python"># 以文本模式打开
f = open(&quot;main.c&quot;, &quot;w&quot;)

# TextIOWrapper 没有 raw，只有 buffer，因为它是构建在 BufferedWriter 之上的
# raw 这一层没有缓冲区，调用它的 write，会直接写入文件
f.buffer.raw.write(b&quot;abc&quot;)

# 或者还可以调用 flush 方法
f.write(&quot;abc&quot;)
# 该方法的本质也是强制调用 raw 的 write 操作，将内容写入磁盘
f.flush()
</code></pre>
<p>因此这三层的关系如下：</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./3.png" alt="" /></p>
<p>所以这就是三者之间的关系，最终实际负责写入数据的肯定还是 raw 这一层，只不过它没有缓冲区，只要有数据，就立刻写入。所以为了保证效率，在 raw 这一层之上又构建了带缓冲区的两层。</p>
<p>那么如何指定缓冲区的大小呢？</p>
<pre><code class="language-python">f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=1024)
</code></pre>
<p>通过 buffering 参数即可设置缓冲区大小，注意：不管是文本模式打开、还是二进制模式打开，这里的 buffering 参数设置的都是二进制这一层的缓冲区。在设置的时候 buffering 必须大于 1，如果等于 1，那么就不再是全缓冲了，而是行缓冲，意思就是遇到换行会立即写入磁盘。不过问题来了， 要是一直都没有写入换行呢？如果一直没有换行，那么缓冲区满了会写入磁盘，所以此时相当于全缓冲。</p>
<p>另外，行缓冲只支持文本模式。</p>
<pre><code class="language-python">import time

f = open(&quot;main.c&quot;, &quot;w&quot;)
f.write(&quot;abc\n&quot;)
time.sleep(30)
</code></pre>
<p>执行，然后查看文件，会发现里面啥也没有，因为数据都在缓冲区里面。默认是全缓冲，第一层的缓冲区大小是 8192，第二层的缓冲区大小是 4096，只有缓冲区满了，才会写入磁盘。</p>
<pre><code class="language-Python">import time

f = open(&quot;main.c&quot;, &quot;w&quot;, buffering=1)
f.write(&quot;abc\n&quot;)
time.sleep(30)
</code></pre>
<p>如果指定 buffering=1，那么就变成了行缓冲，在遇到换行的时候会直接写入磁盘，而不管缓冲区有没有满。如果一直没有换行，那么等价于全缓冲。</p>
<p>最后，还有一个无缓冲，也就是指定 buffering 为 0，但只支持二进制模式。</p>
<pre><code class="language-Python">f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=0)
# 立即写入缓冲区
f.write(b&quot;abc&quot;)
</code></pre>
<p>实际上，如果指定 buffering=0，那么会直接得到 raw 这一层的文件句柄。</p>
<pre><code class="language-Python">import time

f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=1024)
print(f)
print(f.raw)
&quot;&quot;&quot;
&lt;_io.BufferedWriter name='main.c'&gt;
&lt;_io.FileIO name='main.c' mode='wb' closefd=True&gt;
&quot;&quot;&quot;
# raw 这一层对应的文件句柄类型是 FileIO
# 它可以看做是调用操作系统的原生接口，这一层没有缓冲区

# 如果指定 buffering=0
f = open(&quot;main.c&quot;, &quot;wb&quot;, buffering=0)
# 我们看到直接返回第三层
print(f)
&quot;&quot;&quot;
&lt;_io.FileIO name='main.c' mode='wb' closefd=True&gt;
&quot;&quot;&quot;
# 所以 buffering=0 表示无缓冲
# 因为它返回的不是 BufferedWriter，而是 raw 这一层的句柄
</code></pre>
<p>我们总结一下，缓冲模式分为全缓冲、行缓冲、无缓冲。</p>
<ul>
<li>buffering 大于 1：全缓冲；</li>
<li>buffering 等于 1：行缓冲，只适用于文本模式；</li>
<li>buffering 等于 0：无缓冲，只适用于二进制模式，并且返回的句柄类型是 FileIO；</li>
</ul>
<h2 id="优雅地遍历一个目录"><a class="header" href="#优雅地遍历一个目录">优雅地遍历一个目录</a></h2>
<p>在工作中，有时我们需要读取一个目录，然后遍历里面所有的文件。我们可以使用 os.listdir 来实现，但是 Python 从 3.4 开始引入了一个 pathlib 模块，更加的方便。</p>
<pre><code class="language-python">from pathlib import Path

p = Path(r&quot;C:\python38\Lib\asyncio&quot;)

for file in p.glob(&quot;b*.py&quot;):
    print(file)
&quot;&quot;&quot;
C:\python38\Lib\asyncio\base_events.py
C:\python38\Lib\asyncio\base_futures.py
C:\python38\Lib\asyncio\base_subprocess.py
C:\python38\Lib\asyncio\base_tasks.py
&quot;&quot;&quot;
</code></pre>
<p>Path 接收一个文件路径，然后调用它的 glob 方法，即可遍历内部所有的文件。并且 glob 方法接收一个模式，在遍历的时候会选择名称和模式匹配的文件。</p>
<ul>
<li>?：匹配一个任意字符；</li>
<li>*：匹配任意个任意字符；</li>
<li>[sequence]：匹配出现在 sequence 里面的一个字符；</li>
<li>[!sequence]：匹配没有出现在 sequence 里面的一个字符；</li>
<li>[a-z]：匹配出现在 abcdef...z 中的一个字符；</li>
<li>[A-Z]：匹配出现在 ABCDEF...Z 中的一个字符；</li>
<li>[0-9]：匹配出现在 0123...9 中的一个字符；</li>
</ul>
<p>如果想匹配所有文件，那么直接 <strong>.glob(&quot;*&quot;)</strong> 即可，并且遍历得到的仍是一个 Path 对象。当然啦，如果只是 glob，那么可以用 os.listdir 代替。Path 对象还有一个方法叫 rglob，用法和 glob 一样，但是它可以递归遍历子目录，而 glob 只能遍历一层。</p>
<pre><code class="language-Python">from pathlib import Path

p = Path(r&quot;C:\python38\Lib\site-packages\numpy&quot;)

# 只能遍历一层
for file in p.glob(&quot;*.py&quot;):
    # 拿到文件名
    # 直接 p.glob(&quot;__init__.py&quot;) 也是可以的
    if file.name == &quot;__init__.py&quot;:
        print(file)
&quot;&quot;&quot;
C:\python38\Lib\site-packages\pnumpy\__init__.py
&quot;&quot;&quot;

# 递归遍历
for file in p.rglob(&quot;*.py&quot;):
    if file.name == &quot;__init__.py&quot;:
        print(file)
&quot;&quot;&quot;
C:\python38\Lib\site-packages\numpy\__init__.py
C:\python38\Lib\site-packages\numpy\compat\__init__.py
C:\python38\Lib\site-packages\numpy\compat\tests\__init__.py
C:\python38\Lib\site-packages\numpy\core\__init__.py
C:\python38\Lib\site-packages\numpy\core\tests\__init__.py
C:\python38\Lib\site-packages\numpy\distutils\__init__.py
......
......
&quot;&quot;&quot;
</code></pre>
<p>因此在遍历目录的时候，强烈推荐使用 pathlib 模块，非常的方便。其实不光是遍历目录，pathlib 还有其它的功能，这里也补充一下。</p>
<pre><code class="language-Python">from pathlib import Path

p = Path(__file__)
print(p)
&quot;&quot;&quot;
D:\satori\main.py
&quot;&quot;&quot;

# 如果想拿到它的上一级目录，该怎么做呢？
# 是不是比 os.path.dirname 要方便呢？
print(p.parent)  # D:\satori
# 上一级目录的上一级目录
print(p.parent.parent)  # D:\

# 目录的拼接，直接使用 / 即可
# 或者调用 joinpath
print(p.parent / &quot;koishi&quot; / &quot;main.py&quot;)
print(p.parent.joinpath(&quot;koishi&quot;, &quot;main.py&quot;))
&quot;&quot;&quot;
D:\satori\koishi\main.py
D:\satori\koishi\main.py
&quot;&quot;&quot;

# 所以 Path 在路径拼接上面也是一把好手
# 另外以上返回的都是 Path 对象
# 如果想当成字符串来用，需要调用 str 转化一下

# Path 还有一些其它方法
# 返回文件名，字符串格式
print(p.name)  # main.py

# 返回不带后缀的文件名
print(p.stem)  # main

# 文件重命名
p.rename(&quot;main2.py&quot;)
</code></pre>
<p>此外 Path 还有一些方法可以用来判断文件类型，比如是普通文件、目录文件等等。</p>
<p><img src="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/./4.png" alt="" /></p>
<p>这些方法内部在判断的时候也是基于 os 和 stat 模块实现的，我们上面已经介绍过了，先通过 os.stat 函数获取 st_mode，再使用 stat 模块里面函数判断类型。</p>
<p>总之在拼接路径和遍历目录的时候，首推 pathlib。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="使用-osopen-打开文件"><a class="header" href="#使用-osopen-打开文件">使用 os.open 打开文件</a></h2>
<p>无论是读文件还是写文件，都要先打开文件。说到打开文件，估计首先想到的就是内置函数 open（即 io.open），那么它和 os.open 有什么关系呢？</p>
<p>内置函数 open 实际上是对 os.open 的封装，在 os.open 基础上增加了相关访问方法。因此为了操作方便，应该调用内置函数 open 进行文件操作，但如果对效率要求较高的话，则可以考虑使用 os.open。此外 open 函数返回的是一个文件对象，我们可以在此基础上进行任意操作；而 os.open 返回的是一个文件描述符，说白了就是一个整数，因为每一个文件对象都会对应一个文件描述符。</p>
<pre><code class="language-python">import os

f1 = open(&quot;main.c&quot;, &quot;r&quot;)
f2 = os.open(&quot;main.c&quot;, os.O_RDONLY)

print(f1.__class__)
print(f2.__class__)
&quot;&quot;&quot;
&lt;class '_io.TextIOWrapper'&gt;
&lt;class 'int'&gt;
&quot;&quot;&quot;
</code></pre>
<p>Python 的 open 函数实际上是封装了 C 的 fopen，C 的 fopen 又封装了系统调用提供的 open。</p>
<p><img src="%E4%BD%BF%E7%94%A8%20os%20%E6%A8%A1%E5%9D%97%E6%9B%B4%E9%AB%98%E6%95%88%E5%9C%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/./1.png" alt="" /></p>
<p>操作系统提供了很多的系统调用，打开文件则是 open，我们看到它返回一个整数，这个整数就是对应的文件描述符。C 的 fopen 封装了系统调用的 open，返回的是一个文件指针。</p>
<p>所以内置函数 open 和 os.open 的区别就更加清晰了，内置函数 open 在底层会使用 C 的 fopen，得到的是一个封装好的文件对象，在此基础上可以直接操作。至于 os.open 在底层则不走 C 的 fopen，而是直接使用系统调用提供的 open，得到的是文件描述符。</p>
<blockquote>
<p>os 模块内部的函数基本上都是直接走的系统调用，所以模块名才叫 os。</p>
</blockquote>
<p>然后我们使用 os.open 一般需要传递两个参数，第一个参数是文件名，第二个参数是模式，举个栗子：</p>
<pre><code class="language-python">import os

# 以只读方式打开，要求文件必须存在
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_RDONLY)

# 以只写方式打开，要求文件必须存在
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_WRONLY)

# 以可读可写方式打开，要求文件必须存在
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_RDWR)

# 如果希望文件不存在时能够自动创建，那么可以使用 os.O_CREAT
os.open(&quot;main.c&quot;, os.O_RDONLY | os.O_CREAT)
os.open(&quot;main.c&quot;, os.O_WRONLY | os.O_CREAT)
os.open(&quot;main.c&quot;, os.O_RDWR | os.O_CREAT)

# 文件不存在时创建，存在时清空
# 打开时光标处于文件的起始位置
os.open(&quot;main.c&quot;, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)
# 当然读取文件也是可以的
# 比如 os.O_RDONLY | os.O_CREAT | os.O_TRUNC
# 也是文件存在时清空内容，但是这没有任何意义
# 因为读取的时候将文件清空了，那还读什么？

# 文件不存在时创建，存在时追加
# 打开时光标处于文件的末尾
os.open(&quot;main.c&quot;, os.O_WRONLY | os.O_CREAT | os.O_APPEND)

# 所以
&quot;&quot;&quot;
open 里面的读模式等价于这里的 os.O_RDONLY
open 里面的写模式等价于这里的 os.O_WRONLY | os.O_CREATE | os.O_TRUNC
open 里面的追加模式等价于这里的 os.O_WRONLY | os.O_CREATE | os.O_APPEND
&quot;&quot;&quot;
</code></pre>
<p>好，打开方式介绍完了，那么怎么读取和写入呢？很简单，读取使用 os.read，写入使用 os.write。</p>
<h2 id="使用-osread-读取文件"><a class="header" href="#使用-osread-读取文件">使用 os.read 读取文件</a></h2>
<p>先来看读取，os.read 接收两个参数，第一个参数是文件描述符，第二个参数是要读取多少个字节。</p>
<pre><code class="language-Python">import os

fd = os.open(&quot;main.c&quot;, os.O_RDONLY)
# 使用 os.read 进行读取，这里读取 20 个字节
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'#include &lt;Python.h&gt;'
&quot;&quot;&quot;

# 再读取 20 个字节
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'\n#include &lt;ctype.h&gt;'
&quot;&quot;&quot;

# 继续读取
data = os.read(fd, 20)
# 由于只剩下一个字节，所以就读取了一个字节
# 显然此时文件已经读完了
print(data)
&quot;&quot;&quot;
b'\n'
&quot;&quot;&quot;

# 文件读取完毕之后
# 再读取的话会返回空字节串
print(os.read(fd, 20))  # b''
print(os.read(fd, 20))  # b''
print(os.read(fd, 20))  # b''
</code></pre>
<p>所以这就是文件的读取方式，还是很简单的。然后在读取的过程中，我们还可以移动光标，通过 os.lseek 函数。</p>
<ul>
<li>os.lseek(fd, m, 0)：将光标从文件的起始位置向后移动 m 个字节；</li>
<li>os.lseek(fd, m, 1)：将光标从当前所在的位置向后移动 m 个字节；</li>
<li>os.lseek(fd, m, 2)：将光标从文件的结束位置向后移动 m 个字节；</li>
</ul>
<p>如果 m 大于 0，表示向后移动，m 小于 0，表示向前移动。所以当第三个参数为 2 的时候，也就是结束位置，那么 m 一般为负数。因为相对于结束位置，肯定要向前移动，当然向后移动也可以，不过没啥意义；同理当第三个参数为 0 时，m 一般为正数，相对于起始位置，肯定要向后移动。</p>
<pre><code class="language-Python">import os

fd = os.open(&quot;main.c&quot;, os.O_RDONLY)
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'#include &lt;Python.h&gt;'
&quot;&quot;&quot;

# 从文件的起始位置向后移动 0 个字节
# 相当于将光标设置在文件的起始位置
os.lseek(fd, 0, 0)
data = os.read(fd, 20)
print(data)
&quot;&quot;&quot;
b'#include &lt;Python.h&gt;'
&quot;&quot;&quot;

# 设置在结束位置
os.lseek(fd, 0, 2)
print(os.read(fd, 20))  # b''

# 此时就什么也读不出来了
</code></pre>
<p>然后我们提一下 stdin, stdout, stderr，含义应该不需要解释了，重点是它们对应的文件描述符分别为 0, 1, 2。</p>
<pre><code class="language-Python">import os

# 从标准输入里面读取 10 个字节
# 没错，此时作用类似于 input
while True:
    data = os.read(0, 10).strip()
    print(f&quot;你输入了:&quot;, data)
    if data == b&quot;exit&quot;:
        break
</code></pre>
<p>我们测试一下：</p>
<p><img src="%E4%BD%BF%E7%94%A8%20os%20%E6%A8%A1%E5%9D%97%E6%9B%B4%E9%AB%98%E6%95%88%E5%9C%B0%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/./2.png" alt="" /></p>
<p>os.read 可以实现 input 的效果，并且效率更高。另外当按下回车时，换行符也会被读进去，所以需要 strip 一下。然后我们这里读的是 10 个字节，如果一次读不完，那么会分多次读取。在读取文件的时候，也是同理。</p>
<pre><code class="language-Python">from io import BytesIO
import os

fd = os.open(&quot;main.c&quot;, os.O_RDONLY)
buf = BytesIO()

while True:
    data = os.read(fd, 10)
    if data != b&quot;&quot;:
        buf.write(data)
    else:
        break
print(buf.getvalue().decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
#include &lt;Python.h&gt;
#include &lt;ctype.h&gt;

&quot;&quot;&quot;
</code></pre>
<p>然后 os.read 还可以和内置函数 open 结合，举个栗子：</p>
<pre><code class="language-Python">import os
import io

f = open(&quot;main.c&quot;, &quot;r&quot;)
# 通过 f.fileno() 即可拿到对应的文件描述符
# 虽然这里是以文本模式打开的文件，但只要拿到文件描述符，都可以交给 os.read
print(os.read(f.fileno(), 10))  # b'#include &lt;'

# 查看光标位置
print(f.tell())  # 10

# 移动光标位置，从文件开头向后移动 5 字节
f.seek(5, 0)
print(f.tell())  # 5
# os.lseek 也可以实现
os.lseek(f.fileno(), 3, 0)
print(f.tell())  # 3
# 此时会从第 4 个字节开始读取
print(f.read())
&quot;&quot;&quot;
clude &lt;Python.h&gt;
#include &lt;ctype.h&gt;

&quot;&quot;&quot;

# os.lseek 比 f.seek 要强大一些
# 移动到文件末尾，此时没问题
f.seek(0, 2)
print(f.tell())  # 41

try:
    f.seek(-1, 2)
except io.UnsupportedOperation as e:
    print(e)
&quot;&quot;&quot;
can't do nonzero end-relative seeks
&quot;&quot;&quot;
# 但如果要相对文件末尾移动具体的字节数
# 那么 f.seek 不支持，而 os.lseek 是可以的
print(f.tell())  # 41
os.lseek(f.fileno(), -1, 2)
print(f.tell())  # 40
# 最后只剩下一个换行符
print(os.read(f.fileno(), 10))  # b'\n'
</code></pre>
<p>是不是很好玩呢？</p>
<h2 id="使用-oswrite-写入文件"><a class="header" href="#使用-oswrite-写入文件">使用 os.write 写入文件</a></h2>
<p>然后是写入文件，调用 os.write 即可写入。</p>
<pre><code class="language-Python">import os

# 此时可读可写，文件不存在时自动创建，存在则清空
fd = os.open(&quot;1.txt&quot;, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
# 写入内容，接收两个参数
# 参数一：文件描述符；参数二：bytes 对象
os.write(fd, b&quot;hello, &quot;)
os.write(fd, &quot;古明地觉&quot;.encode(&quot;utf-8&quot;))
# 读取内容
data = os.read(fd, 1024)
print(data)  # b''
# 问题来了，为啥读取不到内容呢？
# 很简单，因为光标会伴随着数据的写入而不断后移，这样的话，数据才能不断地写入
# 因此，现在的光标位于文件的结尾处，想要查看写入的内容需要移动到开头
os.lseek(fd, 0, 0)
print(os.read(fd, 1024).decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
hello, 古明地觉
&quot;&quot;&quot;
# 从后往前移动 3 字节
os.lseek(fd, -3, 2)
print(os.read(fd, 1024).decode(&quot;utf-8&quot;))
&quot;&quot;&quot;
觉
&quot;&quot;&quot;
</code></pre>
<p>以上就是文件的写入，当然它也可以和内置函数 open 结合，通过 <strong>os.write(f.fileno(), b&quot;xxx&quot;)</strong> 进行写入。但是不建议 os.open 和 open 混用，其实工作中使用 open 就足够了。</p>
<p>然后是 stdout 和 stderr，和 os.write 结合可以实现 print 的效果。</p>
<pre><code class="language-Python">import os

os.write(1, &quot;往 stdout 里面写入\n&quot;.encode(&quot;utf-8&quot;))
os.write(2, &quot;往 stderr 里面写入\n&quot;.encode(&quot;utf-8&quot;))
</code></pre>
<p>以上就是 os.write 的用法。</p>
<h2 id="使用-osclose-关闭文件"><a class="header" href="#使用-osclose-关闭文件">使用 os.close 关闭文件</a></h2>
<p>最后是关闭文件，使用 os.close 即可。</p>
<pre><code class="language-Python">import os
import io

fd = os.open(&quot;1.txt&quot;, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
# 关闭文件
os.close(fd)

# 文件对象也是可以的
f = open(r&quot;1.txt&quot;, &quot;r&quot;)
os.close(f.fileno())
try:
    f.read()
except OSError as e:
    print(e)
&quot;&quot;&quot;
[Errno 9] Bad file descriptor
&quot;&quot;&quot;
</code></pre>
<p>如果是调用 f.close() 关闭文件，再进行读取的话，会抛出一个 ValueError，提示 I/O operation on closed file。这个报错信息比较明显，不应该在关闭的文件上执行 IO 操作，因为文件对象知道文件已经关闭了，毕竟调用的是自己的 close 方法，所以这个报错是解释器给出的。当然啦，调用 f.close 也会触发 os.close，因为关闭文件最终还是要交给操作系统负责的。</p>
<p>但如果是直接关闭底层的文件描述符，文件对象是不知道的，再使用 f.read() 依旧会触发系统调用，也就是 os.read。而操作系统发现文件已经关闭了，所以会报错：文件描述符有问题，此时就是一个 OSError，报错信息是操作系统给出的。</p>
<pre><code class="language-Python">import os

f = open(r&quot;1.txt&quot;, &quot;r&quot;)
# 文件是否关闭
print(f.closed)  # False
os.close(f.fileno())
print(f.closed)  # False

# 所以调用 os.close，文件对象 f 并不知道
# f.read 依旧会触发系统调用
</code></pre>
<p>如果是使用 f.close()。</p>
<pre><code class="language-Python">f = open(r&quot;1.txt&quot;, &quot;r&quot;)
f.close()
print(f.closed)  # True
</code></pre>
<p>后续执行 IO 操作，就不会再走系统调用了，而是直接抛出 ValueError，原因是文件对象知道文件已经关闭了。</p>
<p>除了 os.close 之外，还有一个 os.closerange，可以关闭多个文件描述符对应的文件。</p>
<pre><code class="language-Python">import os

# 关闭文件描述符为 1、2、3、4 的文件 
os.closerange(1, 5)
</code></pre>
<p>该方法不是很常用，了解一下即可。</p>
<p>以上就是使用 os 模块操作文件，它是直接使用操作系统提供的系统调用，所以效率上会比内置函数 open 要高一些。但是工作中还是不太建议使用 os 模块操作文件，使用内置函数 open 就好。</p>
<div style="break-before: page; page-break-before: always;"></div><p>为了安全，操作系统将虚拟内存划分为用户态和内核态，两者是相互隔离的，即使用户的应用程序崩溃了，也不会影响系统的运行。</p>
<p><img src="%E5%B0%86%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E5%83%8F%E6%95%B0%E7%BB%84%E4%B8%80%E6%A0%B7%E8%AE%BF%E9%97%AE/./1.png" alt="" /></p>
<p>而磁盘、网卡等硬件设备，只有内核才有权限操作，如果应用程序想读取文件，那么必然涉及用户态和内核态之间的切换。假设应用程序想要读取数据，那么会经历以下过程：</p>
<ul>
<li>1）调用 read 方法，然后触发系统调用，向内核发送 IO 请求，此时程序进入阻塞状态；</li>
<li>2）内核收到 IO 请求后，进一步将请求发送给 DMA，这里解释一下什么是 DMA。早期搬运数据都是由 CPU 来做的，但 CPU 是非常宝贵的，让它搬运数据简直是一种浪费，于是便有了 Direct Memory Access（直接内存访问）技术，简称  DMA。和磁盘等设备之间进行数据交互的时候，数据搬运的工作全部交给 DMA 控制器，让 CPU 去做别的事情；</li>
<li>3）DMA 将 IO 请求进一步发送给磁盘，表示：磁盘兄弟，你快给我准备数据；</li>
<li>4）磁盘收到 DMA 的 IO 请求，会把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li>5）DMA 收到磁盘的中断信号，会将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时仍然不占用 CPU，CPU 可以执行其他任务；</li>
<li>6）当 DMA 将数据准备好后，就会向 CPU 发送中断信号，表示你可以将数据搬到用户空间了；</li>
<li>7）CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间、或者说用户缓冲区，然后系统调用返回，read 方法结束；</li>
</ul>
<p>以上就是读取文件的整个过程，这里再解释一下 DMA。在早期搬运数据都是由 CPU 来做的，磁盘控制器的缓冲区满了之后， 由 CPU 搬到内核缓冲区。但搬数据这种简单的工作让 CPU 去做太大材小用了，如果数据量非常大的话，那 CPU 还怎么做其它事情？</p>
<p>于是有了 DMA，因为磁盘（硬件）存储的数据肯定要先到内核缓冲区，然后才能到用户空间。同理，用户空间想要往磁盘存储数据，也要先将数据拷贝到内核缓冲区，然后才能落盘。而为了保证 CPU 效率，内核缓冲区和磁盘之间的数据交互就可以交给 DMA 来做，CPU 不用亲自参与了。CPU 只需要告诉 DMA 传输的数据内容、以及将数据传输到哪里即可，剩下的交给 DMA 去做，DMA 做完了再告知 CPU。</p>
<p>早期的 DMA 只存在于主板上，而现在 IO 设备越来越多，不同的 IO 设备对数据传输的要求也不相同，所以每个设备都有自己的 DMA 控制器。总之 DMA 的作用非常单纯，就是为了减少 CPU 的工作量，帮助 CPU 完成内核缓冲区和磁盘等硬件之间的数据搬运。</p>
<p>但是 DMA 只负责内核缓冲区和磁盘之间的数据搬运，而内核空间和用户空间之间的数据搬运，必须由 CPU 来做。因为 DMA 位于硬件设备之上，只有内核才能操作硬件设备，所以 DMA 只能把数据搬到内核空间，不可能把内核空间的数据再搬到用户空间。换句话说，只要涉及到用户态，那么数据搬运只能由 CPU 来做。</p>
<p>整个过程示意图如下：</p>
<p><img src="%E5%B0%86%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E5%83%8F%E6%95%B0%E7%BB%84%E4%B8%80%E6%A0%B7%E8%AE%BF%E9%97%AE/./2.png" alt="" /></p>
<p>好了，说了这么多，接下来就要进入主题了。</p>
<p>以上过程发生了两次数据拷贝，第一次拷贝是 DMA 做的，将数据从磁盘搬到内核缓冲区；但第二次拷贝是 CPU 做的，将数据从内核缓冲区搬到用户缓冲区，因为用户进程只能操作用户空间里的数据。</p>
<p>但显然数据的拷贝是比较耗时的，于是 Linux 提供了一个系统调用函数 mmap，可以直接将文件映射到指定的用户进程（对应的虚拟内存）。进程通过对内存的读取和修改，实现对文件的读取和修改，从而避免了内核空间和用户空间的数据拷贝。</p>
<p>另外，如果多个进程映射同一个文件，还可以实现进程通信的目的。因为映射的是同一个文件，一个进程修改了，另一个进程也能看到。</p>
<p>前置知识介绍完了，而我们的主题是和 Python 相关的，那么接下来就要通过 Python 实现 mmap。而实现方式也很简单，Python 有一个内置库叫 mmap，调用它的 mmap 类即可实现。函数的原型如下：</p>
<pre><code class="language-Python"># Windows
mmap(fileno, length[, tagname[, access[, offset]]])
# UNIX
mmap(fileno, length[, flags[, prot[, access[, offset]]]])
</code></pre>
<p>解释一下里面的参数，这里只看 UNIX：</p>
<ul>
<li>fileno：文件描述符，通过 os.open 获取即可。或者使用内置函数 open 打开，然后通过文件对象的 fileno 方法获取；</li>
<li>length：映射的长度，比如文件有 1G，但我们可能只映射 1024 字节。如果指定为 0，则全部映射；</li>
<li>offset：映射默认是从头开始的，如果不想从头开始，还可以指定偏移量。但这个偏移量必须是页对齐的，一个页大小默认是 4096，可以通过 mmap.PAGESIZE 查看。换句话说，offset 必须是 mmap.PAGESIZE 的整数倍；</li>
<li>prot：映射之后的内存段权限，有以下几种：
<ul>
<li>mmap.PROT_READ：内存段可读；</li>
<li>mmap.PROT_WRITE：内存段可写；</li>
<li>mmap.PROT_EXEC：内存段可执行；</li>
<li>mmap.PROT_NONE：内存段不能被访问；</li>
</ul>
</li>
<li>flags：进程修改内存段之后，文件的表现，有以下几种：
<ul>
<li>mmap.MAP_SHARED：对内存的修改，会体现在文件中；</li>
<li>mmap.MAP_PRIVATE：对内存的修改，不会体现在文件中；</li>
<li>mmap.ANNOYMOUS：如果内存不是基于映射文件得到的，那么内容全部被初始化为 0；</li>
</ul>
</li>
</ul>
<p>prot 和 flags 参数我们一般不需要太关注，默认值就是我们想要的，多个进程可以共享文件，并且对内存的修改也会体现在文件中。所以我们只需要关注 fileno, length, offset 这三个参数即可，下面来测试一下，看看 mmap 的用法。</p>
<pre><code class="language-Python">import mmap
import os

# 1.txt 里面的内容是 a-z 总共 26 个小写的英文字母
m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
# 打印的结果是一个 mmap 对象
print(m)
&quot;&quot;&quot;
&lt;mmap.mmap object at 0x0000011D7FD5A930&gt;
&quot;&quot;&quot;

# 查看长度
print(len(m))
print(m.size())
&quot;&quot;&quot;
26
26
&quot;&quot;&quot;

# 获取元素，支持索引和切片
print(m[0], chr(m[0]))
&quot;&quot;&quot;
97 a
&quot;&quot;&quot;
print(m[-1], chr(m[-1]))
&quot;&quot;&quot;
122 z
&quot;&quot;&quot;

print(m[1: 3])
print(m[-3:])
print(m[:])
&quot;&quot;&quot;
b'bc'
b'xyz'
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

# 还提供了 find 和 rfind 方法
print(m.find(b&quot;bcd&quot;))  # 1
print(m.find(b&quot;z&quot;))  # 25
print(m.rfind(b&quot;z&quot;))  # 25
</code></pre>
<p>是不是很方便呢？就跟操作数组一样。当然啦，mmap 还支持文件操作。</p>
<pre><code class="language-python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)

# 返回文件光标
print(m.tell())
&quot;&quot;&quot;
0
&quot;&quot;&quot;
# 读取文件内容，可以指定读取多少字节
# 不指定，则从当前光标位置读到结尾
print(m.read())
&quot;&quot;&quot;
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;
# 此时光标处于文件结尾
print(m.tell())
&quot;&quot;&quot;
26
&quot;&quot;&quot;
# 移动光标
# 从结尾向前移动 5 字节
m.seek(-5, 2)
print(m.tell())
&quot;&quot;&quot;
21
&quot;&quot;&quot;
# 读取内容
print(m.read())
&quot;&quot;&quot;
b'vwxyz'
&quot;&quot;&quot;
# 继续读取的话，会读到空字节串
print(m.read(3), m.read())
&quot;&quot;&quot;
b'' b''
&quot;&quot;&quot;

# 无论光标在什么位置
# 都不影响索引或切片访问
print(m[10: 20])
&quot;&quot;&quot;
b'klmnopqrst'
&quot;&quot;&quot;
</code></pre>
<p>除此之外，mmap 还支持 for 循环：</p>
<pre><code class="language-python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)

# 既然支持索引访问，证明实现了 __getitem__
# 那么支持 for 循环也是意料之中的
for index, char in enumerate(m):
    if index == 5:
        break
    print(char)
&quot;&quot;&quot;
b'a'
b'b'
b'c'
b'd'
b'e'
&quot;&quot;&quot;
# 注意：for 循环这种方式，不会影响光标

# 所以 mmap 对象还提供了一个 read_byte 方法
# read_byte 也是每次读取一个字节，但是会影响光标
print(m.read_byte())  # 97
print(m.read_byte())  # 98
print(m.read_byte())  # 99
# 返回的是整数，read_byte() 就相当于 read(1)[0]

# 最后 mmap 还提供了 readline 方法，一次读取一行
print(m.tell())  # 3
print(m.readline())
&quot;&quot;&quot;
b'defghijklmnopqrstuvwxyz'
&quot;&quot;&quot;
m.seek(0, 0)
print(m.readline())
&quot;&quot;&quot;
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;
# 当前文件只有一行
# 所以再读的话就没有内容了
print(m.readline())  # b''
</code></pre>
<p>以上都是读取数据，然后我们来写入数据。</p>
<pre><code class="language-Python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)

# 通过索引赋值，赋的值必须是整数
m[0] = ord(&quot;A&quot;)
# 注意长度要匹配
m[1: 3] = b&quot;BC&quot;
# 查看文件的话，会发现文件也被修改了
print(m[:])
&quot;&quot;&quot;
ABCdefghijklmnopqrstuvwxyz
&quot;&quot;&quot;
m[-2:] = b&quot;YZ&quot;
print(m[:])
&quot;&quot;&quot;
ABCdefghijklmnopqrstuvwxYZ
&quot;&quot;&quot;

# 注意：在通过索引或切片操作的时候，不要越界
# 文件总共 26 个字符，都是 ASCII
# 因此最大索引是 25
try:
    m[26] = 33
except IndexError as e:
    print(e)
&quot;&quot;&quot;
mmap index out of range
&quot;&quot;&quot;

try:
    # 依旧越界    
    m[26: 27] = b&quot;~&quot;
except IndexError as e:
    print(e)
&quot;&quot;&quot;
mmap slice assignment is wrong size
&quot;&quot;&quot;

# 最大索引是 25，所以 m[24:] 等价于 m[24: 26]
# 此时只剩下两个字节，而我们赋的值是 3 个字节
try:
    m[24:] = b&quot;~~~&quot;
except IndexError as e:
    print(e)
&quot;&quot;&quot;
mmap slice assignment is wrong size
&quot;&quot;&quot;
# 此时是没问题的
m[23:] = b&quot;~~~&quot;
print(m[:])
&quot;&quot;&quot;
b'ABCdefghijklmnopqrstuvw~~~'
&quot;&quot;&quot;
</code></pre>
<p>像这种通过索引或切片赋值的方式，不仅修改内存中的数据，还会将修改后的数据映射到磁盘文件里面。如果你在 Windows 上操作之后，发现文件内容没有变化，那么不妨先关闭，然后再用 notepad++ 打开。Linux 的话，直接 cat 命令即可。</p>
<p>注意：此时进程对内存的操作会直接体现在文件里，而不需要经过内核空间的 read、write 等系统调用。换句话说，此时操作内存等价于操作文件，因为两者已经建立好了映射关系，因此这种做法非常高效。</p>
<blockquote>
<p>通常在加载共享库的时候，也是通过 mmap 的方式加载的。另外，在映射的时候，不能映射一个空文件，里面必须有内容。</p>
</blockquote>
<p>mmap 也提供了类似文件的写入方法，我们来看一看，不过在这之前我先把文件恢复原样。</p>
<pre><code class="language-Python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
print(m[:])
&quot;&quot;&quot;
b'abcdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

# 会伴随光标移动
m.write(b&quot;ABC&quot;)
print(m[:])
&quot;&quot;&quot;
b'ABCdefghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

m.write(b&quot;DEF&quot;)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwxyz'
&quot;&quot;&quot;

# 移动到文件末尾的前 1 个字节
m.seek(-1, 2)
print(m.tell())  # 25
# 此时最多写入一个字节
try:
    m.write(b&quot;ZZ&quot;)
except ValueError as e:
    print(e)
&quot;&quot;&quot;
data out of range
&quot;&quot;&quot;
m.write(b&quot;Z&quot;)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwxyZ'
&quot;&quot;&quot;
# 除了 write 方法之外，还有一个 write_byte
# 但 write_byte 每次只能写入一个字节，并且接收的必须是 0 ~ 255 之间的整数
</code></pre>
<p>用记事本打开 1.txt 文件，如果已经打开，那么就先关闭再打开，会发现内容被修改。</p>
<p>然后 mmap 还有一个 resize 方法，它可以改变内存段的大小。</p>
<pre><code class="language-Python">import mmap
import os

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwxyZ'
&quot;&quot;&quot;
# 打开文件会发现结尾的 yZ 已经没了
m.resize(24)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwx'
&quot;&quot;&quot;
# 如果扩大 size 的话，会用 \x00 填充
m.resize(26)
print(m[:])
&quot;&quot;&quot;
b'ABCDEFghijklmnopqrstuvwx\x00\x00'
&quot;&quot;&quot;
</code></pre>
<p>打开文件，查看内容：</p>
<p><img src="%E5%B0%86%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%86%85%E5%AD%98%EF%BC%8C%E5%83%8F%E6%95%B0%E7%BB%84%E4%B8%80%E6%A0%B7%E8%AE%BF%E9%97%AE/./3.png" alt="" /></p>
<p>\x00 显示的就是这种乱七八糟的样子，总之 resize 的话，如果 size 减少，相当于删除；size 增加，用 \x00 填充。</p>
<p>以上就是通过 mmap 来读写文件，它的效率很高，并且还支持通过索引和切片的方式读写，建议使用此方式。对了，还有关闭，如果不需要使用了，可以调用 m.close() 关闭 mmap 对象（但是文件不会关闭）。</p>
<p>最后，再来聊一聊 offset，它表示偏移量，这个偏移量必须是页对齐的。</p>
<pre><code class="language-Python">import mmap
import os

with open(&quot;1.txt&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
    f.write(&quot;a&quot; * 4096 + &quot;abc&quot;)

m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0)
print(len(m))  # 4099

try:
    m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0, offset=100)
except OSError as e:
    print(e)
&quot;&quot;&quot;
[WinError 1132] 指定的基址或文件偏移量没有适当对齐。
&quot;&quot;&quot;

# 偏移量必须是 mmap.PAGESIZE 的整数倍
# 一个页的大小一般是 4096
m = mmap.mmap(os.open(&quot;1.txt&quot;, os.O_RDWR), 0, offset=mmap.PAGESIZE)
# 显然此时只能读出 b&quot;abc&quot;
print(m[:])
&quot;&quot;&quot;
b'abc'
&quot;&quot;&quot;
# 补充一下，即便 offset 是 PAGESIZE 的整数倍
# 在 Windows 上依然会报出上面的错误，但在 Linux 上面是没有问题的
</code></pre>
<p>以上就是 offset 的作用，它表示偏移量，但是这个偏移量必须是页对齐的。并且，offset 不可以超过文件的长度，否则会报错：ValueError: mmap offset is greater than file size。</p>
<p>关于 mmap 的部分我们就说到这里。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-4"><a class="header" href="#楔子-4">楔子</a></h2>
<p>Python 有一个第三方模块叫 psutil，专门用来获取操作系统以及硬件相关的信息，比如：CPU、磁盘、网络、内存等等。下面来看一下它的用法，不过在使用之前需要先安装，直接 pip install psutil 即可。</p>
<h2 id="cpu-相关"><a class="header" href="#cpu-相关">CPU 相关</a></h2>
<p><strong><font color="darkblue">获取 CPU 的逻辑核心数量</font></strong></p>
<pre><code class="language-Python">import psutil
print(psutil.cpu_count())  # 12

# 或者使用 multiprocessing
import multiprocessing
print(multiprocessing.cpu_count())  # 12
</code></pre>
<p><strong><font color="darkblue">获取 CPU 的物理核心数量</font></strong></p>
<pre><code class="language-Python">import psutil
print(psutil.cpu_count(logical=False))  # 6
</code></pre>
<p>结果为 6，说明是 6 核超线程；如果 CPU 的物理核心数和逻辑核心数相等，也为 12，则说明是 12 核非超线程。</p>
<p><strong><font color="darkblue">统计 CPU 的用户／系统／空闲时间</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.cpu_times())
&quot;&quot;&quot;
scputimes(user=84732.10937499999, 
          system=37132.85937500023, 
          idle=2003964.1249999998, 
          interrupt=3500.765625, 
          dpc=1089.6875)
&quot;&quot;&quot;

# 还有一个 psutil.cpu_times_percent() 
# 功能与之类似, 只不过返回的是比例
</code></pre>
<p>该函数返回的是一个 namedtuple，后面凡是结构长的和这里类似的，都是 namedtuple。补充一下，如果你的程序中需要创建大量的对象，并且该对象的属性固定不变，那么不妨使用 namedtuple，相比使用字典，能节省大量空间。</p>
<p><strong><font color="darkblue">查看 CPU 的使用率</font></strong></p>
<pre><code class="language-Python">import psutil

for x in range(3):
    # interval：表示每隔 0.5s 刷新一次
    # percpu：为 True 表示查看所有的 cpu 使用率
    print(psutil.cpu_percent(interval=0.5, percpu=True))
&quot;&quot;&quot;
[9.1, 3.1, 12.5, 3.1, 15.6, 0.0, 6.2, 0.0, 12.5, 50.0, 9.4, 3.1]
[9.1, 6.2, 12.5, 6.2, 3.1, 0.0, 0.0, 3.1, 0.0, 15.6, 3.1, 0.0]
[0.0, 0.0, 15.6, 0.0, 6.2, 0.0, 6.2, 25.0, 3.1, 9.4, 6.2, 0.0]
&quot;&quot;&quot;
# 我这里 cpu 的逻辑数量是 12
# 所以每个列表里面有 12 个元素
</code></pre>
<p><strong><font color="darkblue">查看 CPU 的统计信息</font></strong></p>
<p>包括上下文切换、中断、软中断，以及系统调用次数等等。</p>
<pre><code class="language-Python">import psutil

print(psutil.cpu_stats())
&quot;&quot;&quot;
scpustats(ctx_switches=3346512902, 
          interrupts=2288572793, 
          soft_interrupts=0, 
          syscalls=3324041552)
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看 CPU 的频率</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.cpu_freq())
&quot;&quot;&quot;
scpufreq(current=2208.0, min=0.0, max=2208.0)
&quot;&quot;&quot;
</code></pre>
<h2 id="内存相关"><a class="header" href="#内存相关">内存相关</a></h2>
<p><strong><font color="darkblue">查看内存使用情况</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.virtual_memory())
&quot;&quot;&quot;
svmem(total=17029259264, 
      available=7698505728, 
      percent=54.8, 
      used=9330753536, 
      free=7698505728)
&quot;&quot;&quot;
</code></pre>
<p>total 表示总内存，available 表示可用内存，percent 表示内存使用率，used 表示已使用的内存，free 表示可用内存。</p>
<p>所以 available 加上 used 等于 total，used 除以 total 再乘以 100 等于 percent。</p>
<p><strong><font color="darkblue">查看交换内存信息</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.swap_memory())
&quot;&quot;&quot;
sswap(total=3087007744, 
      used=4509839360, 
      free=-1422831616, 
      percent=146.1, 
      sin=0, 
      sout=0)
&quot;&quot;&quot;
</code></pre>
<p>说到内存，有物理内存、交换内存、虚拟内存，这三者有什么区别呢？用大白话解释就是：</p>
<p>1）物理内存是实际的内存条提供的临时数据存储空间，在 Windows 上右键点击计算机，再点击属性时，上面显示的安装内存（RAM）就是电脑的物理内存。这些内存是实际存在的，在你不给机器增加内存条的时候是不会改变的。</p>
<p>2）交换内存通常在页面调度和交换进程数据时使用，相当于在进行内存整理的时候，会先把部分数据放在硬盘的某块区域。类似我们整理衣柜，衣服一多直接整理会很麻烦，因此会先把部分衣服拿出来放在其它地方，等衣柜里的衣服整理完了，再把放在其它地方的衣服拿回来。</p>
<p>这个<strong>其它地方</strong>在计算机中则代表硬盘的某块区域，也就是我们所说的交换区。通常使用交换内存是因为物理内存不足导致的，正所谓衣柜，如果足够大的话就没必要拿出部分衣服放在其它地方， 直接在衣柜里就能解决了。</p>
<p>3）最后是虚拟内存，当操作文件，可执行程序等等，那么首先要把它们从磁盘读取到内存中，因此 CPU 除了自己那一部分小小的空间外，要想操作数据，只能操作内存里的数据。</p>
<p>但是当内存不够了，那么会在硬盘上开辟一份虚拟内存，将物理内存里的部分数据放在虚拟内存当中。硬盘的空间很大，即使普通电脑安装的固态硬盘也有一百个 G，因此可以拿出一部分充当虚拟内存。不过虚拟内存虽说是内存，但毕竟在硬盘上，速度和 CPU 直接从物理内存里读取数据相差甚远。这也是为什么要将经常被访问的热点数据放在 Redis 缓存里，而不是放在硬盘或者数据库上。</p>
<h2 id="磁盘相关"><a class="header" href="#磁盘相关">磁盘相关</a></h2>
<p><strong><font color="darkblue">查看磁盘分区、磁盘使用率和磁盘 IO 信息</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.disk_partitions())
&quot;&quot;&quot;
[sdiskpart(device='C:\\', mountpoint='C:\\', fstype='NTFS', opts='rw,fixed', maxfile=255, maxpath=260),
 sdiskpart(device='D:\\', mountpoint='D:\\', fstype='NTFS', opts='rw,fixed', maxfile=255, maxpath=260),
 sdiskpart(device='E:\\', mountpoint='E:\\', fstype='NTFS', opts='rw,fixed', maxfile=255, maxpath=260)]
&quot;&quot;&quot;
</code></pre>
<p>可以看到一共有三个盘符，fstype 表示文件系统类型，这里是 NTFS；opts 中的 rw 表示可读写。</p>
<p>该函数还可以接收一个参数 all，默认为 False。如果指定为 True，在 Linux 上返回的内容还会包含 /proc 等特殊文件系统的挂载信息。由于我这里是 Windows，所以两者没区别。</p>
<p><strong><font color="darkblue">查看某个磁盘使用情况</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.disk_usage(&quot;C:\\&quot;))
&quot;&quot;&quot;
sdiskusage(total=267117391872, 
           used=96894304256, 
           free=170223087616, 
           percent=36.3)
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看磁盘 IO 统计信息</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.disk_io_counters())
&quot;&quot;&quot;
sdiskio(read_count=1172461, 
        write_count=2153031, 
        read_bytes=36854982144, 
        write_bytes=52718300160, 
        read_time=551, 
        write_time=1437)
&quot;&quot;&quot;
</code></pre>
<ul>
<li>read_count ：<strong>读次数</strong></li>
<li>write_count：<strong>写次数</strong></li>
<li>read_bytes：<strong>读的字节数</strong></li>
<li>write_bytes：<strong>写的字节数</strong></li>
<li>read_time：<strong>读时间</strong></li>
<li>write_time：<strong>写时间</strong></li>
</ul>
<p>以上返回的是所有磁盘加起来的统计信息，我们可以指定 perdisk=True，分别列出每一个分区的统计信息。</p>
<h2 id="网络相关"><a class="header" href="#网络相关">网络相关</a></h2>
<p><strong><font color="darkblue">查看网卡的网络 IO 统计信息</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.net_io_counters())
&quot;&quot;&quot;
snetio(bytes_sent=175995567, 
       bytes_recv=2849015622, 
       packets_sent=1052206, 
       packets_recv=3050302, 
       errin=0, 
       errout=0, 
       dropin=3491, 
       dropout=0)
&quot;&quot;&quot;
# bytes_sent: 发送的字节数
# bytes_recv: 接收的字节数
# packets_sent: 发送的包数据量
# packets_recv: 接收的包数据量
# errin: 接收包时, 出错的次数
# errout: 发送包时, 出错的次数
# dropin: 接收包时, 丢弃的次数
# dropout: 发送包时, 丢弃的次数

# 里面还有一个 pernic 参数
# 如果为 True, 则列出所有网卡的信息
print(psutil.net_io_counters(pernic=True))
&quot;&quot;&quot;
{'以太网': snetio(bytes_sent=178716616, 
                 bytes_recv=2866823348, 
                 packets_sent=1058190, 
                 packets_recv=3102852, 
                 errin=0, errout=0, 
                 dropin=3491, dropout=0), 
'WLAN': snetio(bytes_sent=0, bytes_recv=0, 
               packets_sent=0, packets_recv=0, 
               errin=0, errout=0, 
               dropin=0, dropout=0), 
'本地连接* 3': snetio(bytes_sent=0, bytes_recv=0, 
                    packets_sent=0, packets_recv=0, 
                    errin=0, errout=0, 
                    dropin=0, dropout=0), 
'本地连接* 4': snetio(bytes_sent=0, bytes_recv=0, 
                     packets_sent=0, packets_recv=0,
                     errin=0, errout=0, 
                     dropin=0, dropout=0), 
'蓝牙网络连接': snetio(bytes_sent=0, bytes_recv=0, 
                    packets_sent=0, packets_recv=0,
                    errin=0, errout=0, 
                    dropin=0, dropout=0), 
'Loopback Pseudo-Interface 1': snetio(bytes_sent=0, 
                                      bytes_recv=0, 
                                      packets_sent=0, 
                                      packets_recv=0, 
                                      errin=0, errout=0, 
                                      dropin=0, dropout=0)}
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看网络接口信息</font></strong></p>
<pre><code class="language-python">import psutil

# 以字典的形式返回网卡的配置信息
# 包括 IP 地址、Mac地址、子网掩码、广播地址等等
print(psutil.net_if_addrs())
&quot;&quot;&quot;
{'以太网': [
    snicaddr(family=&lt;AddressFamily.AF_LINK: -1&gt;, 
             address='9C-7B-EF-15-FC-2F', netmask=None, 
             broadcast=None, ptp=None), 
    snicaddr(family=&lt;AddressFamily.AF_INET: 2&gt;, 
             address='192.168.4.150', netmask='255.255.240.0', 
             broadcast=None, ptp=None), 
    snicaddr(family=&lt;AddressFamily.AF_INET6: 23&gt;, 
             address='fe80::4826:a6a6:b5f4:3647', 
             netmask=None, broadcast=None, ptp=None)], 

'WLAN': [...], 
'本地连接* 3': [...], 
'本地连接* 4': [...], 
'蓝牙网络连接': [...], 
'Loopback Pseudo-Interface 1': [...]}
&quot;&quot;&quot;

# 返回网卡的详细信息, 包括是否启动、通信类型、传输速度、mtu
print(psutil.net_if_stats())
&quot;&quot;&quot;
{'以太网': snicstats(isup=True, 
                    duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                    speed=1000, mtu=1500), 
'蓝牙网络连接': snicstats(isup=False, 
                        duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                        speed=3, mtu=1500), 
'Loopback Pseudo-Interface 1': snicstats(isup=True, 
                                         duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                                         speed=1073, mtu=1500), 
'WLAN': snicstats(isup=False, 
                  duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                  speed=0, mtu=1500), 
'本地连接* 3': snicstats(isup=False, 
                        duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                        speed=0, mtu=1500), 
'本地连接* 4': snicstats(isup=False, 
                        duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, 
                        speed=0, mtu=1500)}
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看当前机器的网络连接</font></strong></p>
<pre><code class="language-python">import psutil

# 以列表的形式返回每个网络连接的详细信息
# 里面接受一个参数, 默认是 &quot;inet&quot;
# 当然我们也可以指定为其它, 比如 &quot;tcp&quot;
print(psutil.net_connections())
&quot;&quot;&quot;
[sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_DGRAM: 2&gt;, 
       laddr=addr(ip='192.168.4.150', port=137), 
       raddr=(), status='NONE', pid=4),
 sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_DGRAM: 2&gt;, 
       laddr=addr(ip='127.0.0.1', port=54872), 
       raddr=(), status='NONE', pid=11652),
 sconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_STREAM: 1&gt;, 
       laddr=addr(ip='192.168.4.150', port=11253), 
       raddr=addr(ip='117.50.19.136', port=80), 
       status='CLOSE_WAIT', pid=11568),
 ....
 ....
 ....
]
&quot;&quot;&quot;
</code></pre>
<p>是不是很方便呢？在 Linux 中有两个命令可以做到这一点，分别是 netstat 和 ss。另外该函数会返回所有的连接信息，所以当连接数很多的时候，会占用较高的内存。</p>
<p><strong><font color="darkblue">查看当前登录的用户信息</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.users())
&quot;&quot;&quot;
[suser(name='satori', terminal=None, host='0.0.0.0', 
       started=1609841661.0, pid=None)]
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看系统的启动时间</font></strong></p>
<pre><code class="language-Python">import psutil
from datetime import datetime

print(psutil.boot_time())  # 1654012221.2945454
print(
    datetime.fromtimestamp(psutil.boot_time())
)  # 2022-05-31 23:50:21.294545
</code></pre>
<h2 id="进程管理"><a class="header" href="#进程管理">进程管理</a></h2>
<p>psutil 还提供了很多和进程管理相关的功能函数，非常的丰富，我们来看一下。</p>
<p><strong><font color="darkblue">查看当前存在的所有进程的 pid</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.pids())
&quot;&quot;&quot;
[0, 4, 148, 532, 668, 796, 904, 912, 976, ...]
&quot;&quot;&quot;
</code></pre>
<p><strong><font color="darkblue">查看某个进程是否存在</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.pid_exists(22333))  # False
print(psutil.pid_exists(532))  # True
</code></pre>
<p><strong><font color="darkblue">返回所有进程（Process）对象组成的迭代器</font></strong></p>
<pre><code class="language-Python">import psutil

print(psutil.process_iter())
&quot;&quot;&quot;
&lt;generator object process_iter at 0x000...&gt;
&quot;&quot;&quot;

# 遍历的话，会得到每一个进程对象
# 进程对象在 psutil 里面的类型是 Process
</code></pre>
<p><strong><font color="darkblue">根据 pid 获取一个进程对应的 Process 对象</font></strong></p>
<pre><code class="language-python">import psutil

print(psutil.Process(14124))
&quot;&quot;&quot;
psutil.Process(pid=14124, name='WeChat.exe', 
               status='running', started='10:54:43')
&quot;&quot;&quot;
# 进程名称是 WeChat.exe，状态为运行中
# 启动时间是早上 10 点 54 分
</code></pre>
<h2 id="进程管理-1"><a class="header" href="#进程管理-1">进程管理</a></h2>
<p>我们说根据 pid 可以获取一个进程对应的 Process 对象，而这个对象里面包含了该进程的全部信息。</p>
<pre><code class="language-Python">import psutil

p = psutil.Process(14124)

# 进程名称
print(p.name())
&quot;&quot;&quot;
WeChat.exe
&quot;&quot;&quot;

# 进程的exe路径
print(p.exe())
&quot;&quot;&quot;
D:\WeChat\WeChat.exe
&quot;&quot;&quot;

# 进程的工作目录
print(p.cwd())
&quot;&quot;&quot;
D:\WeChat
&quot;&quot;&quot;

# 进程启动的命令行
print(p.cmdline())
&quot;&quot;&quot;
['D:\\WeChat\\WeChat.exe']
&quot;&quot;&quot;

# 当前进程id
print(p.pid)
&quot;&quot;&quot;
14124
&quot;&quot;&quot;

# 父进程id
print(p.ppid())
&quot;&quot;&quot;
8860
&quot;&quot;&quot;

# 父进程
print(p.parent())
&quot;&quot;&quot;
psutil.Process(pid=8860, name='explorer.exe', 
               status='running', started='10:53:58')
&quot;&quot;&quot;

# 子进程列表
print(p.children())
&quot;&quot;&quot;
[psutil.Process(pid=6852, name='WechatBrowser.exe', 
                status='running', started='10:54:59'), 
 psutil.Process(pid=1960, name='WeChatPlayer.exe',
                status='running', started='10:54:59'), 
 psutil.Process(pid=10432, name='WeChatApp.exe', 
                status='running', started='10:55:33')]
&quot;&quot;&quot;

# 进程状态
print(p.status())
&quot;&quot;&quot;
running
&quot;&quot;&quot;

# 进程用户名
print(p.username())
&quot;&quot;&quot;
LAPTOP-264ORES3\satori
&quot;&quot;&quot;

# 进程创建时间,返回时间戳
print(p.create_time())
&quot;&quot;&quot;
1654570483.2370846
&quot;&quot;&quot;

# 进程终端
# 在windows上无法使用
try:
    print(p.terminal())
except Exception as e:
    print(e)
&quot;&quot;&quot;
'Process' object has no attribute 'terminal'
&quot;&quot;&quot;

# 进程使用的cpu时间
print(p.cpu_times())
&quot;&quot;&quot;
pcputimes(user=27.8125, system=13.484375,
          children_user=0.0, children_system=0.0)
&quot;&quot;&quot;

# 进程所使用的的内存
print(p.memory_info())
&quot;&quot;&quot;
pmem(rss=110141440, vms=116899840, 
     num_page_faults=661356, peak_wset=221048832, 
     wset=110141440, peak_paged_pool=834824, 
     paged_pool=806216, peak_nonpaged_pool=144584, 
     nonpaged_pool=78560, pagefile=116899840, 
     peak_pagefile=197505024, private=116899840)
&quot;&quot;&quot;

# 进程打开的文件
print(p.open_files())

# 进程相关的网络连接
print(p.connections())
&quot;&quot;&quot;
[pconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_STREAM: 1&gt;, 
       laddr=addr(ip='192.168.4.150', port=7693), 
       raddr=addr(ip='58.251.111.106', port=8080), 
       status='ESTABLISHED'), 
 pconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, 
       type=&lt;SocketKind.SOCK_STREAM: 1&gt;, 
       laddr=addr(ip='127.0.0.1', port=8680), 
       raddr=(), status='LISTEN')]
&quot;&quot;&quot;

# 进程内的线程数量，这个进程开启了多少个线程
print(p.num_threads())  # 58

# 这个进程内的所有线程信息
print(p.threads())
&quot;&quot;&quot;
[pthread(id=14128, user_time=11.3125, system_time=7.578125), 
 pthread(id=13428, user_time=0.0, system_time=0.0), 
 pthread(id=13616, user_time=0.0, system_time=0.0), 
 pthread(id=13600, user_time=0.015625, system_time=0.328125),
 pthread(id=7364, user_time=0.078125, system_time=0.015625),
 ... 
 ]
&quot;&quot;&quot;

# 进程的环境变量
print(p.environ())

# 结束进程
# 执行之后微信就会被强制关闭, 这里就不试了
# p.terminal()
</code></pre>
<p>我们还可以调用 psutil.test 来模拟 ps 命令。</p>
<pre><code class="language-Python">import psutil

psutil.test()
</code></pre>
<p>可以自己看一下输出，和 Linux 的 ps 命令的输出是类似的。那么它是怎么做的呢？还记得我们之前说的 process_iter 吗？会返回所有进程的 Process 对象，直接依次输出里面的信息即可。同理，我们也可以通过 process_iter 找到某一个进程对应的进程 id。</p>
<pre><code class="language-Python">import psutil

for prcs in psutil.process_iter():
    if prcs.name().lower() == &quot;wechat.exe&quot;:
        print(prcs)
&quot;&quot;&quot;
psutil.Process(pid=14124, name='WeChat.exe', 
               status='running', started='10:54:43')
&quot;&quot;&quot;
</code></pre>
<p>有了这个操作之后，我们便可以找到对应的进程，然后借助操作系统的 kernal 修改进程内部的数据。</p>
<h2 id="小结-3"><a class="header" href="#小结-3">小结</a></h2>
<p>以上就是 psutil 模块相关的用法，总的来说，这个模块提供的功能还是蛮丰富的。在做运维的时候，少不了这个模块。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
