<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python 实用技巧</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="如何优雅地遍历可迭代对象？/doc.html">如何优雅地遍历可迭代对象？</a></li><li class="chapter-item expanded "><a href="解密可迭代对象的排序问题/doc.html">解密可迭代对象的排序问题</a></li><li class="chapter-item expanded "><a href="通过 TOP K 问题，探究堆和优先队列的秘密/doc.html">通过 TOP K 问题，探究堆和优先队列的秘密</a></li><li class="chapter-item expanded "><a href="如何优雅地对数据进行分组？/doc.html">如何优雅地对数据进行分组？</a></li><li class="chapter-item expanded "><a href="全方位解析 f-string/doc.html">全方位解析 f-string</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 实用技巧</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/python-tech" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>本篇文章来介绍如何优雅地遍历可迭代对象，举个例子：</p>
<pre><code class="language-Python">data = [&quot;古明地觉&quot;, &quot;芙兰朵露&quot;, &quot;雾雨魔理沙&quot;]

for item in data:
    print(item)
&quot;&quot;&quot;
古明地觉
芙兰朵露
雾雨魔理沙
&quot;&quot;&quot; 
</code></pre>
<p>遍历一个可迭代对象，可以使用 for 循环，每次会从可迭代对象中迭代出一个元素。当迭代完毕时，抛出 StopIteration，然后 for 循环捕获，终止循环。</p>
<p>当然，可迭代对象对内部的元素没有要求，可以指向任意的对象。</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

for item in data:
    print(item)
&quot;&quot;&quot;
('古明地觉', '女', '地灵殿')
('琪露诺', '女', '雾之湖')
('芙兰朵露', '女', '红魔馆')
&quot;&quot;&quot;
</code></pre>
<p>此时迭代出来的元素就是一个个的元组，如果想获取元组里面的元素，那么可以通过索引的方式获取，比如 item[0]。但是基于索引的话，代码可读性不高，于是你可能会这么做。</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

for item in data:
    name, gender, address = item
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>通过这种方式，代码的可读性变得更高了一些。但实际上，这段代码有点冗余，我们可以简化一下：</p>
<pre><code class="language-Python">data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]

# name, gender, address 周围的小括号可以省略
for (name, gender, address) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>for 后面可以跟一个循环变量，也可以跟多个循环变量组成的元组。如果 for 后面跟的是一个普通的变量，那么可迭代对象里面的元素迭代出来之后会直接赋值给该变量。</p>
<p>如果 for 后面跟的是多个变量组成的元组，那么可迭代对象里迭代出来的元素必须仍是一个可迭代对象，并且迭代出来的每一个可迭代对象里面的元素个数，都必须和 for 后面的元组里的变量个数相同。最后进行解包，按照顺序将值分别赋给 for 后面的变量，这里就是 name, gender, address。</p>
<p>那么问题来了，这两种迭代方式有什么不同呢？</p>
<pre><code class="language-Python"># 第一种迭代方式
for item in data:
    name, gender, address = item
    print(name, gender, address)

# 第二种迭代方式
for name, gender, address in data:
    print(name, gender, address)
</code></pre>
<p>我们看一下字节码就清楚了，字节码面前没有秘密：</p>
<pre><code class="language-Python"> # 第一种迭代方式对应的字节码
 
 # 加载变量 data
 0 LOAD_NAME                0 (data)
 # 获取可迭代对象对应的迭代器
 2 GET_ITER
 # 将元素迭代出来
 4 FOR_ITER                13 (to 32)
 # 赋值给变量 item
 6 STORE_NAME               1 (item)
 # 加载变量 item，item 一定也指向一个可迭代对象
 8 LOAD_NAME                1 (item)
 # 解包
10 UNPACK_SEQUENCE          3
 # 按照顺序将里面的值赋给变量 name, gender, address
12 STORE_NAME               2 (name)
14 STORE_NAME               3 (gender)
16 STORE_NAME               4 (address)


 # 第二种迭代方式对应的字节码

 0 LOAD_NAME                0 (data)
 2 GET_ITER
 4 FOR_ITER                11 (to 28)
 6 UNPACK_SEQUENCE          3
 # 前面三条字节码没有区别
 # 但是这里将元素迭代出来之后，直接就解包了
 8 STORE_NAME               1 (name)
10 STORE_NAME               2 (gender)
12 STORE_NAME               3 (address)
</code></pre>
<p>所以这两种方式没有本质上的区别，只是第一种方式在将元素迭代出来之后需要单独用一个变量保存，然后加载变量，最后进行解包；而第二种方式在将元素迭代出来之后，直接就解包了。因此虽然效果是一样的，但是第二种方式要稍微快一点点，因为它少执行了两条指令。</p>
<p>另外，还有一种特殊情况：</p>
<pre><code class="language-python">data = [[1], [2], [3], [4]]
# for 后面是一个变量
for item in data:
    print(item)
&quot;&quot;&quot;
[1]
[2]
[3]
[4]
&quot;&quot;&quot;    

# for 后面是包含一个变量的元组
for item, in data:
    print(item)
&quot;&quot;&quot;
1
2
3
4
&quot;&quot;&quot;
</code></pre>
<p>由于 data 里面的元素也是列表，所以 for 后面仍然可以跟一个元组，迭代的时候会自动解包。只是当元组里面只有一个元素的时候，需要在第一个元素的后面加上一个逗号，什么意思呢？举个例子：</p>
<pre><code class="language-python">data = [[1], [2], [3], [4]]
# 这里虽然给 item 加上了括号，但它仍然不是一个元组
for (item) in data:
    print(item)
&quot;&quot;&quot;
[1]
[2]
[3]
[4]
&quot;&quot;&quot;    

# 如果元组里面只有一个元素
# 那么第一个元素后面必须要有一个逗号
# 否则解释器会认为这个括号只是起到一个限定优先级的作用
for (item,) in data:
    print(item)
&quot;&quot;&quot;
1
2
3
4
&quot;&quot;&quot;

# 再举个栗子
a, b, c = 3, 2, 4
# 此时 a + b 周围的括号只是起到了一个限定作用
# 用于提高 a + b 的优先级
print((a + b) * c)  # 20

# 但如果是这样的话，就不同了
# 此时和 c 相乘的不再是整数，而是一个元组
print((a + b,) * c)  # (5, 5, 5, 5)
</code></pre>
<p>当然啦，变量赋值也是同样的道理，因为每一次 for 循环本质上也是一次变量赋值。</p>
<pre><code class="language-Python">numbers = (99, 96, 100)

a, b, c = numbers
print(a, b, c)  # 99 96 100

# 也可以显式地使用括号括起来
(a, b, c) = (99, 96, 100)
print(a, b, c)  # 99 96 100

# 如果变量名字比较长，那么还可以换行写
(
    a,
    b,
    c
) = numbers
print(a, b, c)  # 99 96 100

# 当可迭代对象只包含一个元素时，也是同理
numbers = (88,)
(a,) = numbers
print(a)  # 88
# 赋值的时候，元组周围的小括号可以不要 
a, = numbers
print(a)  # 88
</code></pre>
<p>最后还有一个神奇的地方，在赋值的时候，多个变量不仅可以组成一个元组，还可以组成一个列表，举个例子：</p>
<pre><code class="language-python">numbers = (99, 96, 100)

[a, b, c] = numbers
print(a, b, c)  # 99 96 100

# 如果是列表的话，当只有一个元素的时候，就不需要逗号了
numbers = [88]
[a] = numbers
print(a)  # 88

# for 循环的时候也是同理
data = [(&quot;古明地觉&quot;, &quot;女&quot;, &quot;地灵殿&quot;),
        (&quot;琪露诺&quot;, &quot;女&quot;, &quot;雾之湖&quot;),
        (&quot;芙兰朵露&quot;, &quot;女&quot;, &quot;红魔馆&quot;)]
for [name, gender, place] in data:
    print(name, gender, place)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;
</code></pre>
<p>当然啦，无论多个变量组成的是元组还是列表，字节码都没有区别。只是我们更习惯写成元组，并且将元组周围的小括号省略掉。</p>
<p>另外可迭代对象也是可以嵌套的，举个例子：</p>
<pre><code class="language-Python">data = [(&quot;古明地觉&quot;, (&quot;女&quot;, &quot;地灵殿&quot;)),
        (&quot;琪露诺&quot;, (&quot;女&quot;, &quot;雾之湖&quot;)),
        (&quot;芙兰朵露&quot;, (&quot;女&quot;, &quot;红魔馆&quot;))]

# 每个可迭代对象内部只有两个元素，所以在迭代的时候
# for 后面的元组或列表里面也只能有两个变量
for name, gender_address in data:
    print(name, gender_address)
&quot;&quot;&quot;
古明地觉 ('女', '地灵殿')
琪露诺 ('女', '雾之湖')
芙兰朵露 ('女', '红魔馆')
&quot;&quot;&quot;

# 于是聪明的你可能想到了
for name, (gender, address) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

# 使用列表也是可以的
for [name, (gender, address)] in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;    

# 以下几种方式也是可以的
&quot;&quot;&quot;
for [name, [gender, address]] in data:
    print(name, gender, address)

for (name, [gender, address]) in data:
    print(name, gender, address)

for (name, (gender, address)) in data:
    print(name, gender, address)
&quot;&quot;&quot;
</code></pre>
<p>并且嵌套的可迭代对象的数量也是任意的，举个例子：</p>
<pre><code class="language-python">data = [(&quot;古明地觉&quot;, (&quot;女&quot;,), (&quot;地灵殿&quot;,)),
        (&quot;琪露诺&quot;, (&quot;女&quot;,), (&quot;雾之湖&quot;,)),
        (&quot;芙兰朵露&quot;, (&quot;女&quot;,), (&quot;红魔馆&quot;,))]

for name, gender, address in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 ('女',) ('地灵殿',)
琪露诺 ('女',) ('雾之湖',)
芙兰朵露 ('女',) ('红魔馆',)
&quot;&quot;&quot;

for name, [gender], [address] in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

for name, (gender,), (address,) in data:
    print(name, gender, address)
&quot;&quot;&quot;
古明地觉 女 地灵殿
琪露诺 女 雾之湖
芙兰朵露 女 红魔馆
&quot;&quot;&quot;

# 变量赋值也是同理
numbers = [[[3]]]
a = numbers
print(a)  # [[[3]]]

a, = numbers
print(a)  # [[3]]

((a,),) = numbers
print(a)  # [3]

(((a,),),) = numbers
print(a)  # 3
[[[a]]] = numbers
print(a)  # 3

# 再来一个恶心人的，当然啦，这个做法没啥意义
# 只是想表明可迭代对象之间的嵌套是非常自由的
numbers = [[[3], [[[[4]], 5], 6]], 7]
(((a,), ((((b,),), c), d)), e) = numbers
print(a, b, c, d, e)  # 3 4 5 6 7
</code></pre>
<p>最后再来介绍一个高级特性，不过介绍之前先来看看上面的迭代方式有什么缺陷：</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
</code></pre>
<p>如果是这种情况的话，那么 for 循环在遍历的时候，要使用几个变量去遍历呢？两个、三个、还是四个呢？我们先用三个变量看看：</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for a, b, c in data:
    print(a, b, c)
&quot;&quot;&quot;
Traceback (most recent call last):
  File &quot;...&quot;, line 6, in &lt;module&gt;
    for a, b, c in data:
ValueError: too many values to unpack (expected 3)
&quot;&quot;&quot;
</code></pre>
<p>很明显它报错了，所以这种方式有一个缺陷，就是它除了要求可迭代对象里面的元素也是可迭代对象之外，还要满足它们内部的值的个数都相等，并且个数已知。</p>
<p>但是问题来了，如果我在遍历的时候，只想拿到里面的第一个值和最后一个值，该怎么办呢？</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for item in data:
    print(item[0], item[-1])
&quot;&quot;&quot;
1 4
5 6
7 9
&quot;&quot;&quot;
</code></pre>
<p>首先上面这种方式肯定是可以的，但还有没有另外的方式呢？显然是有的。</p>
<pre><code class="language-Python">data = [
    (1, 2, 3, 4),
    (5, 6),
    (7, 8, 9)
]
for first, *middle, last in data:
    print(first, middle, last)
&quot;&quot;&quot;
1 [2, 3] 4
5 [] 6
7 [8] 9
&quot;&quot;&quot;
</code></pre>
<p>在迭代的时候，第一个值会赋给 first，这没有问题。然后是 middle，它的前面加上了一个 *，那么 middle 就会变成一个列表，这个类似正则的贪婪匹配，会不断地匹配值。而 *middle 后面还有一个 last，因此 *middle 就会匹配到倒数第二个值为止，最后一个值留给 last。</p>
<p>我们再举几个例子：</p>
<pre><code class="language-python">data = [
    (1, 2, 3, 4, 5),
    (6, 7, 8, 9, 10),
    (11, 12, 13, 14, 15)
]

# 第 1 个值给 a、剩余的 4 个值给 b
for a, *b in data:
    print(a, b)
&quot;&quot;&quot;
1 [2, 3, 4, 5]
6 [7, 8, 9, 10]
11 [12, 13, 14, 15]
&quot;&quot;&quot;

# 第 1 个值给 a、第 2 个值给 b，剩余的 3 个值给 c
for a, b, *c in data:
    print(a, b, c)
&quot;&quot;&quot;
1 2 [3, 4, 5]
6 7 [8, 9, 10]
11 12 [13, 14, 15]
&quot;&quot;&quot;

# 第 1 个值给 a、第 2 个值给 b
# 倒数第 1 个值给 d，剩余的值给 c
for a, b, *c, d in data:
    print(a, b, c, d)
&quot;&quot;&quot;
1 2 [3, 4] 5
6 7 [8, 9] 10
11 12 [13, 14] 15
&quot;&quot;&quot;

# 倒数第 1 个值给 b，前面的值给 a
for *a, b in data:
    print(a, b)
&quot;&quot;&quot;
[1, 2, 3, 4] 5
[6, 7, 8, 9] 10
[11, 12, 13, 14] 15
&quot;&quot;&quot;    

# 每次迭代的元素内部只有 5 个值，所以 b 是一个空列表
for a, *b, c, d, e, f in data:
    print(a, b, c, d, e, f)
&quot;&quot;&quot;
1 [] 2 3 4 5
6 [] 7 8 9 10
11 [] 12 13 14 15
&quot;&quot;&quot;

# 所有的值都给 a，但是需要注意：
# 如果出现了 *，那么 for 后面的变量必须组成一个元组或列表
# 所以如果是 for *a in data: 会报出语法错误
# 必须是 for *a, in data: 或者 for [*a] in data:
for *a, in data:
    print(a)
&quot;&quot;&quot;
[1, 2, 3, 4, 5]
[6, 7, 8, 9, 10]
[11, 12, 13, 14, 15]
&quot;&quot;&quot;    
</code></pre>
<p>另外还有一个约定或者说规范，如果在遍历的时候，有一部分的值我们不需要，那么可以使用下划线代替。比如我们只需要第一个值和倒数第二个值，那么遍历的时候就可以像下面这么做：</p>
<pre><code class="language-python">for a, *_, b, _ in data:
    pass
</code></pre>
<p>当然啦，* 不仅可以在 for 循环的时候用，普通的变量赋值也是可以使用的，一样的道理。</p>
<blockquote>
<p>在赋值的时候， * 最多只能出现一次，否则会报出语法错误。</p>
</blockquote>
<p>以上就是可迭代对象的遍历，是不是很有趣呢？</p>
<div style="break-before: page; page-break-before: always;"></div><p>假设有一个可迭代对象，现在想要对它内部的元素进行排序，我们一般会使用内置函数 sorted，举个例子：</p>
<pre><code class="language-python">data = (3, 4, 1, 2, 5)
print(sorted(data))  # [1, 2, 3, 4, 5]

data = (3.14, 2, 1.75)
print(sorted(data))  # [1.75, 2, 3.14]

data = [&quot;satori&quot;, &quot;koishi&quot;, &quot;marisa&quot;]
print(sorted(data))  # ['koishi', 'marisa', 'satori']
</code></pre>
<p>如果可迭代对象里面的元素是数值，那么会按照数值的大小进行排序；如果是字符串，那么会按照字符串的字典序进行排序，并且 sorted 函数会返回一个新的列表。</p>
<blockquote>
<p>sorted 函数默认是升序排序，如果想要降序，那么可以传递一个关键字参数 reverse=True。</p>
</blockquote>
<pre><code class="language-python">data = [
    (3, 4), (3, 1), (2, 3)
]
print(sorted(data))  # [(2, 3), (3, 1), (3, 4)]
</code></pre>
<p>如果可迭代对象里面都是元组的话，也是可以的，元组在比较大小的时候，会先按照元组的第一个元素比较；第一个元素相等，再按照第二个元素比较，依次类推。</p>
<p>因此在使用 sorted 函数的时候，可迭代对象内部的元素，要满足彼此之间都是可比较的，否则报错。</p>
<pre><code class="language-Python">data = [123, 456, &quot;123&quot;]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'str' and 'int'

data = [{&quot;a&quot;: 1}, {&quot;b&quot;: 2}, {&quot;c&quot;: 3}]
try:
    print(sorted(data))
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'

</code></pre>
<p>我们看到，由于 data 里面存在不可比较的元素，因此报错了。那么问题来了，假设有这样一个列表：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 字典是不可比较大小的，因此直接使用 sorted 会报错
# 我们希望按照字典内部的 &quot;age&quot; 字段进行排序，得到下面的结果

[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
</code></pre>
<p>如果是你的话，你会怎么做呢？很明显，我们将每个 &quot;age&quot; 字段的值取出来，和所在的字典拼接成一个元组（或列表）不就行了，然后对元组进行排序，举个例子：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 15}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 由于 data 内部的元素是一个元组
# 所以排序的时候会按照元组的第一个元素排序
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, {'name': 'marisa', 'age': 15}), 
 (16, {'name': 'koishi', 'age': 16}), 
 (17, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时顺序就排好了，然后再把字典取出来
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 15}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>显然这样就实现了基于字典内部某个字段的值，来对字典进行排序，只不过上面的代码还有一点点缺陷。我们说元组在比较的时候会先比较第一个元素，第一个元素相同的话，会比较第二个元素。</p>
<p>而我们上面 data 里面的元组，由于第一个元素都不相等，所以直接就比较出来了。但如果是下面这种情况呢？</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

data = [(d[&quot;age&quot;], d) for d in data]
print(data)
&quot;&quot;&quot;
[(17, {'name': 'satori', 'age': 17}), 
 (16, {'name': 'marisa', 'age': 16}), 
 (16, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;
try:
    sorted_data = sorted(data)
except TypeError as e:
    print(e)  # '&lt;' not supported between instances of 'dict' and 'dict'
</code></pre>
<p>此时就报错了，因为第二个元组和第三个元组内部的第一个元素都是 16，所以第一个元素相等，那么会比较第二个元素。而第二个元素是字典，字典之间无法比较，所以报错了。</p>
<p>但我们只是希望让字典的 &quot;age&quot; 字段的值参与比较，如果相等的话，那么就不用再比较了，相对顺序就保持现状。所以我们可以这么做：</p>
<pre><code class="language-Python">data = [{&quot;name&quot;: &quot;satori&quot;, &quot;age&quot;: 17}, 
        {&quot;name&quot;: &quot;marisa&quot;, &quot;age&quot;: 16}, 
        {&quot;name&quot;: &quot;koishi&quot;, &quot;age&quot;: 16}]

# 将索引也加进去
data = [(d[&quot;age&quot;], i, d) for i, d in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, {'name': 'satori', 'age': 17}), 
 (16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16})]
&quot;&quot;&quot;

# 如果 &quot;age&quot; 字段的值、或者说元组的第一个元素相等
# 那么就按照索引比较，而索引一定是不重复的
sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(16, 1, {'name': 'marisa', 'age': 16}), 
 (16, 2, {'name': 'koishi', 'age': 16}), 
 (17, 0, {'name': 'satori', 'age': 17})]
&quot;&quot;&quot;

# 此时就成功排好序了，并且 &quot;age&quot; 字段的值相等的字典之间的相对顺序
# 在排序之前和排序之后都保持一致，这正是我们想要的结果
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16}, 
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>再比如，我们想要对元组排序，但我们希望按照元组的第二个元素进行排序：</p>
<pre><code class="language-python">data = [(&quot;satori&quot;, 17), 
        (&quot;marisa&quot;, 15), 
        (&quot;koishi&quot;, 16)]

data = [(item[1], i, item) for i, item in enumerate(data)]
print(data)
&quot;&quot;&quot;
[(17, 0, ('satori', 17)), 
 (15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16))]
&quot;&quot;&quot;

sorted_data = sorted(data)
print(sorted_data)
&quot;&quot;&quot;
[(15, 1, ('marisa', 15)), 
 (16, 2, ('koishi', 16)), 
 (17, 0, ('satori', 17))]
&quot;&quot;&quot;

sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[('marisa', 15), 
 ('koishi', 16), 
 ('satori', 17)]
&quot;&quot;&quot;
</code></pre>
<p>所以当可迭代对象内部的元素无法进行排序，或者说我们不希望基于整个元素进行排序，那么就可以使用上面这个方法。将用来排序的值、索引、原始值放在一个元组里面，然后对元组排序，排完了再把最后一个值（也就是原始值）筛出来即可。</p>
<p>或者我们还可以做的再复杂一些：</p>
<pre><code class="language-python">data = [-3, -2, 3, 2, -1, 1, 0]
&quot;&quot;&quot;
对 data 进行排序，排序规则如下
先按照内部元素的正负进行排序，排序之后正数在后面
如果符号一样，再按照绝对值的大小进行排序
也就是说，排完之后是下面这样一个结果

[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

# 如果只按照正负排序
data1 = [(n &gt;= 0, i, n) for i, n in enumerate(data)]
sorted_data = sorted(data1)
print(sorted_data)
&quot;&quot;&quot;
[(False, 0, -3), (False, 1, -2), (False, 4, -1), 
 (True, 2, 3), (True, 3, 2), (True, 5, 1), (True, 6, 0)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 此时正数就排在了负数的后面
print(sorted_data)
&quot;&quot;&quot;
[-3, -2, -1, 3, 2, 1, 0]
&quot;&quot;&quot;

# 如果只按照绝对值排序
data2 = [(abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data2)
print(sorted_data)
&quot;&quot;&quot;
[(0, 6, 0), (1, 4, -1), (1, 5, 1), 
 (2, 1, -2), (2, 3, 2), (3, 0, -3), (3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
print(sorted_data)
&quot;&quot;&quot;
[0, -1, 1, -2, 2, -3, 3]
&quot;&quot;&quot;

# 同时按照正负和绝对值排序
data3 = [(n &gt;= 0, abs(n), i, n) for i, n in enumerate(data)]
sorted_data = sorted(data3)
print(sorted_data)
&quot;&quot;&quot;
[(False, 1, 4, -1), (False, 2, 1, -2), 
 (False, 3, 0, -3), (True, 0, 6, 0), 
 (True, 1, 5, 1), (True, 2, 3, 2), (True, 3, 2, 3)]
&quot;&quot;&quot;
sorted_data = [item[-1] for item in sorted_data]
# 大功告成
print(sorted_data)
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;
</code></pre>
<p>那么接下来，我们就可以封装一个属于我们自己的 my_sorted 函数了。</p>
<pre><code class="language-python">def my_sorted(data, *, key=None, reverse=False):
    &quot;&quot;&quot;
    :paramdata: 可迭代对象
    :paramkey: callable
    :paramreverse: 是否逆序
    :return:
    &quot;&quot;&quot;
    if key is not None:
        data = [(key(item), i, item) for i, item in enumerate(data)]
    sorted_data = sorted(data)
    if key is not None:
        sorted_data = [item[-1] for item in sorted_data]
    if reverse:
        sorted_data = sorted_data[:: -1]
    return sorted_data

# 下面来测试一下
data = [-3, -2 ,3, 2, -1, 1, 0]
print(my_sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(my_sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>结果一切正常，当然啦，实际工作中我们肯定不会专门封装一个 my_sorted 函数，因为内置的 sorted 已经包含了我们上面的所有功能。</p>
<pre><code class="language-python">data = [-3, -2 ,3, 2, -1, 1, 0]
print(sorted(data, key=lambda x: (x &gt;= 0, abs(x))))
&quot;&quot;&quot;
[-1, -2, -3, 0, 1, 2, 3]
&quot;&quot;&quot;

data = [
    {&quot;name&quot;: &quot;satori&quot;, 'age': 17},
    {&quot;name&quot;: &quot;marisa&quot;, 'age': 16},
    {&quot;name&quot;: &quot;koishi&quot;, 'age': 16}
]
print(sorted(data, key=lambda x: x[&quot;age&quot;]))
&quot;&quot;&quot;
[{'name': 'marisa', 'age': 16},
 {'name': 'koishi', 'age': 16}, 
 {'name': 'satori', 'age': 17}]
&quot;&quot;&quot;
</code></pre>
<p>内置函数 sorted 除了接收一个可迭代对象之外，还接收两个关键字参数 key 和 reverse，含义就是我们介绍的那样。在 sorted 的内部，它的处理方式和我们上面是一致的，如果指定了 key，也就是自定义排序规则，那么在底层会将可迭代对象内部的值封装成元组，然后对元组排序。排完序之后，再将元组的最后一个值、也就是原始值取出来，并返回。</p>
<p>所以这就是 sorted 函数的全部秘密，它里面的参数 key 赋予了 sorted 函数强大的能力，有了这个参数，我们想怎么排序，就怎么排序。</p>
<pre><code class="language-python">class A:
    
    def __init__(self, a):
        self.a = a
    
    def __repr__(self):
        return f&quot;self.a = {self.a}&quot;
    
    def __hash__(self):
        return self.a
    
a1 = A(1)
a2 = A(2)
a3 = A(3)
a4 = A(4)

data = [a2, a3, a1, a4]
print(data)
&quot;&quot;&quot;
[self.a = 2, self.a = 3, self.a = 1, self.a = 4]
&quot;&quot;&quot;

# A 的实例对象无法比较，我们希望按照内部的属性 a 进行比较
print(sorted(data, key=lambda x: x.a))
&quot;&quot;&quot;
[self.a = 1, self.a = 2, self.a = 3, self.a = 4]
&quot;&quot;&quot;

# 或者按照哈希值比较，此时仍相当于按照 self.a 比较
print(sorted(data, key=lambda x: hash(x), reverse=True))
&quot;&quot;&quot;
[self.a = 4, self.a = 3, self.a = 2, self.a = 1]
&quot;&quot;&quot;
</code></pre>
<p>因此我们想怎么比就怎么比，参数 key 赋予了我们极大的自由，key 接收一个函数（当然其它 callable 也可以，但大部分场景都是匿名函数），此函数接收一个参数，该参数会对应可迭代对象里面的每一个元素。而函数的返回值，决定了 sorted 的比较逻辑。</p>
<p>比如，我们不光可以对元组、列表排序，还可以对字典内部的键值对排序。</p>
<pre><code class="language-Python">data = {&quot;satori&quot;: 17, &quot;marisa&quot;: 15, &quot;koishi&quot;: 16}

# 对字典调用 sorted，针对的是字典里面的键，所以返回的也是键
print(sorted(data))  # ['koishi', 'marisa', 'satori']

# 匿名函数里面的参数 x 对应可迭代对象里面的每一个元素
# 这里就是字典的键，函数返回 d[x] 表示按照值来排序，但排序之后得到的仍然是键
print(sorted(data, key=lambda x: data[x]))  # ['marisa', 'koishi', 'satori']

# 此时的 x 就是键值对组成的元组，这里按照值来排序
print(
    sorted(data.items(), key=lambda x: x[1])
)  # [('marisa', 15), ('koishi', 16), ('satori', 17)]
</code></pre>
<p>当然啦，还有很多其它排序方式，比如按照数量排序：</p>
<pre><code class="language-python">string = &quot;a&quot; * 4 + &quot;b&quot; * 3 + &quot;c&quot; * 5 + &quot;d&quot; * 2
data = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]

print(
    sorted(data, key=lambda x: string.count(x))
)  # ['d', 'b', 'a', 'c']
</code></pre>
<p>最后再来介绍一个知识点，sorted 在对可迭代对象内部的元素进行排序的时候，肯定要有大小比较的过程，这是肯定的。但问题是比较的时候，用的什么方式呢？举个例子，我想判断 a 和 b 的大小关系（假设不相等），无论是执行 a &gt; b 还是 a &lt; b，根据结果我都能得出它们谁大谁小。</p>
<p>而 sorted 在比较的时候是怎么做的呢，这里给出结论：每次在比较两个对象的时候，都会调用左边对象的 __lt__ 方法。其实关于 sorted 内部是怎么比的，我们无需太关注，但之所以说这一点，是因为在极端场景下可能会遇到。举个例子：</p>
<pre><code class="language-python"># 第一个元素表示 &quot;商品名称&quot;
# 第二个元素表示 &quot;销量&quot;
data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

# 我们需要先按照 &quot;销量&quot; 的大小降序排序
# 如果 &quot;销量&quot; 相同，则按照 &quot;商品名称&quot; 的字典序升序排序
# 该怎么做呢？

# 由于一部分升序，一部分降序
# 我们无法直接使用 reverse 参数，所以就默认按照升序排
# 虽然 &quot;销量&quot; 要求降序排，但可以对它取反
# 这样值越大，取反之后的值就越小，从而实现降序效果
print(
    sorted(data, key=lambda x: (~x[1], x[0]))
)
&quot;&quot;&quot;
[('apple', 200), 
 ('banana', 200), 
 ('cherry', 150), 
 ('orange', 150), 
 ('peach', 150)]
&quot;&quot;&quot;
</code></pre>
<p>可能有小伙伴觉得这也没什么难的，那么我们将问题稍微换一下。如果让你先按照 &quot;销量&quot; 升序排序，如果 &quot;销量相同&quot;，再按照 &quot;商品名称&quot; 的字典序降序排序，你要怎么做呢？</p>
<p>显然这个问题的难点就在于字符串要怎么降序排，整数可以取反，但字符串是无法取反的。所以我们可以自定义一个类，实现它的 __lt__ 方法。</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 200),
    (&quot;banana&quot;, 200),
    (&quot;peach&quot;, 150),
    (&quot;cherry&quot;, 150),
    (&quot;orange&quot;, 150),
]

class STR(str):
    def __lt__(self, other):
        # 调用 str 的 __lt__，得到布尔值，然后再取反
        # 当然，把 not 换成 ~ 也是可以的
        # 因此：&quot;apple&quot; &lt; &quot;banana&quot; 为 True
        # 但是：STR(&quot;apple&quot;) &lt; STR(&quot;banana&quot;) 为 False
        return not super().__lt__(other)

# 销量升序排，直接 x[1] 即可
# 但是商品名称降序排，需要使用类 STR 将 x[0] 包起来
print(sorted(data, key=lambda x: (x[1], STR(x[0]))))
&quot;&quot;&quot;
[('peach', 150), 
 ('orange', 150), 
 ('cherry', 150), 
 ('banana', 200), 
 ('apple', 200)]
&quot;&quot;&quot;

# 事实上，如果你的思维够灵活，你会发现
# &quot;销量&quot;降序排、&quot;商品名称&quot;升序排，排完之后再整体取反
# 就是这里 &quot;销量&quot;升序排、&quot;商品名称&quot;将序排 的结果
print(
    sorted(data, key=lambda x: (~x[1], x[0]), reverse=True)
    ==
    sorted(data, key=lambda x: (x[1], STR(x[0])))
)  # True
# 当然这个思路也很巧妙
</code></pre>
<p>由于默认是调用 __lt__ 进行比较的，因此我们需要实现 __lt__。</p>
<p>以上就是 Python 中如何对可迭代对象进行排序，还是很有意思的。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>在工作中我们经常会遇到这样一个需求，就是获取可迭代对象中的前 K 个最大或最小的元素。我们之前介绍过排序，所以一个最简单的办法就是先排序，排完了再选择前 K 个元素即可。</p>
<pre><code class="language-Python">data = [3, 1, 2, 5, 4]

# 选择前 3 个最大的元素，和前 3 个最小的元素
sorted_data = sorted(data)
print(f&quot;TOP 3 MAX：{sorted_data[-3:]}&quot;)
print(f&quot;TOP 3 MIN：{sorted_data[: 3]}&quot;)
&quot;&quot;&quot;
TOP 3 MAX：[3, 4, 5]
TOP 3 MIN：[1, 2, 3]
&quot;&quot;&quot;

# 或者这么做
sorted_data = sorted(data, reverse=True)
print(f&quot;TOP 3 MAX：{sorted_data[: 3]}&quot;)
print(f&quot;TOP 3 MIN：{sorted_data[-3:]}&quot;)
&quot;&quot;&quot;
TOP 3 MAX：[5, 4, 3]
TOP 3 MIN：[3, 2, 1]
&quot;&quot;&quot;
</code></pre>
<p>显然这是一种解决办法，但如果列表的长度非常大，排序就会带来不小的开销。而且有时我们只要前几个元素即可，比如长度为 10000 的列表，我们只想要前三个最大或最小的元素，那么此时对整个列表进行排序显然会存在性能上的浪费。</p>
<blockquote>
<p>sorted 函数的时间复杂度是 O(NlogN)</p>
</blockquote>
<p>所以接下来我们要介绍一个模块叫 heapq，通过该模块我们能快速地获取前 K 个元素。</p>
<pre><code class="language-Python">import random
import heapq

data = [random.randint(10, 10000) for _ in range(1000)]

# 选择前 3 个最大的元素
print(heapq.nlargest(3, data))
print(sorted(data, reverse=True)[: 3])
&quot;&quot;&quot;
[9997, 9995, 9984]
[9997, 9995, 9984]
&quot;&quot;&quot;

# 选择前 3 个最小的元素
print(heapq.nsmallest(3, data))
print(sorted(data)[: 3])
&quot;&quot;&quot;
[23, 39, 52]
[23, 39, 52]
&quot;&quot;&quot;
</code></pre>
<p>得到的结果是一样的，但是性能差异如何呢？我们来测一下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./1.png" alt="" /></p>
<p>可以看到性能差异还是蛮大的，并且列表长度越大，性能差距越明显。而根本原因就在于 sorted 会对列表进行全局排序，而 heapq 没有。因此在获取前 K 个元素、并且 K 和列表长度差距比较大的时候，不妨使用 heapq 的 nsmallest 和 nlargest 函数，性能会有明显提升。</p>
<blockquote>
<p>但如果 K 和列表长度相差不大，那么先 sorted 排序，再使用切片的方式会更好一些。</p>
</blockquote>
<p>nsmallest 和 nlargest 这两个函数都接收 3 个参数，第一个参数表示要获取前多少个元素、第二个参数表示可迭代对象（一般是列表）、第三个参数是 key（和 sorted 函数里面的 key 含义相同）。</p>
<pre><code class="language-python">import random
import heapq

data = [{&quot;number&quot;: random.randint(10, 10000)} for _ in range(1000)]

# data 内部都是字典
# 获取前 3 个 number 字段的值最大的字典
print(heapq.nlargest(3, data, key=lambda x: x[&quot;number&quot;]))
print(sorted(data, key=lambda x: x[&quot;number&quot;], reverse=True)[: 3])
&quot;&quot;&quot;
[{'number': 9998}, {'number': 9963}, {'number': 9956}]
[{'number': 9998}, {'number': 9963}, {'number': 9956}]
&quot;&quot;&quot;
</code></pre>
<p>特别提示，如果 K 为 1，那么使用内置函数 min 和 max 是最佳选择。</p>
<pre><code class="language-Python">import random
import heapq

data = [{&quot;number&quot;: random.randint(10, 10000)} for _ in range(1000)]

# data 内部都是字典
# 获取前 3 个 number 字段的值最大的字典
print(heapq.nlargest(1, data, key=lambda x: x[&quot;number&quot;]))
print(sorted(data, key=lambda x: x[&quot;number&quot;], reverse=True)[0])
print(max(data, key=lambda x: x[&quot;number&quot;]))
&quot;&quot;&quot;
[{'number': 9997}]
{'number': 9997}
{'number': 9997}
&quot;&quot;&quot;
</code></pre>
<p>所以结论如下，当获取最大或最小元素的个数为 K，列表（可迭代对象）长度为 L 时：</p>
<ul>
<li>K 等于 1，使用内置函数 max 或 min；</li>
<li>K 不等于 1、且远小于 L，使用 heapq 模块的 nlargest 或 nsmallest 函数；</li>
<li>K 和 L 差别不大，使用 sorted 先全局排序、然后再通过切片方式截取；</li>
</ul>
<p>当然啦，以上都属于基础知识，比较简单。其实选择前 K 个元素就是我们常说的 TOP K 问题，如果只是单纯地想解决 TOP K 问题的话，上面已经给出了方案。这里我主要是想通过 TOP K 来引出一种数据结构，也就是堆。</p>
<p>堆是一种非常高效的数据结构，我们可以用它实现优先队列，堆实现的优先队列在元素入队、出队的时间复杂度上均为 O(logN)。</p>
<h2 id="什么是堆"><a class="header" href="#什么是堆">什么是堆？</a></h2>
<p>首先堆本身是一棵树，如果这棵树是二叉树，那么实现的堆就被称为二叉堆。当然除了二叉堆，还有三叉堆等等，只不过二叉堆是一种最主流的堆的实现方式。因此，堆（二叉堆）就是一棵满足一些特殊性质的二叉树，那么问题来了，它都满足哪些性质呢？</p>
<ul>
<li>堆是一棵完全二叉树；</li>
<li>堆里的每一个节点都大于等于（或小于等于）它的孩子节点；
<ul>
<li>如果每个节点都大于等于它的孩子节点，或者说每个节点都不大于它的父节点，那么这个堆就是大根堆；</li>
<li>如果每个节点都小于等于它的孩子节点，或者说每个节点都不小于它的父节点，那么这个堆就是小根堆；</li>
</ul>
</li>
</ul>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./2.png" alt="" /></p>
<p>注意：堆要求的是每个节点和其孩子节点之间要满足相应的大小关系，如果两个节点之间没有父子关系，那么它们谁大谁小无关紧要。比如图上的大根堆，第三层的最后一个节点是 13，可第四层的节点却都比它大，但它们之间没有父子关系，所以当前这个堆是成立的。</p>
<p>正是因为堆的这个性质，我们可以使用数组来表示堆，直接按照层序遍历的方式将每一层的元素放在数组中即可，比如：</p>
<p><code>[62, 41, 30, 28, 16, 22, 13, 19, 17, 15]</code></p>
<p>很明显，堆顶（数组索引为 0）的元素永远是值最大或最小的元素，如果构建的是大根堆，堆顶元素最大；构建的是小根堆，堆顶元素最小。</p>
<p>但是问题来了，如果我有一个节点，要如何找到它的父节点或者孩子节点呢？结论如下，假设当前节点所在的索引为 i。</p>
<ul>
<li>父节点的索引：(i - 1) / 2</li>
<li>左孩子节点的索引：2 * i + 1</li>
<li>右孩子节点的索引：2 * i + 2</li>
</ul>
<p>我们以索引为 3 这个元素（值为 28）为例，它父节点的索引是 (3 - 1) / 2 = 1，也就是 41 这个元素。左孩子节点的索引是 2 * 3 + 1 = 7，也就是 19 这个元素。右孩子节点的索引显然是 8，也就是 17 这个元素。可以对照上图，检验一下是否有误，或者你也可以创建一个更大的堆，自己测试一下，但前提必须是完全二叉树才具备这个性质。</p>
<p>显然通过这种方式，我们就不需要两个指针来维持节点之间的父子关系了，使用数组索引即可，并且通过索引定位元素的速度也会更快。</p>
<h2 id="向堆中添加元素sift-up"><a class="header" href="#向堆中添加元素sift-up">向堆中添加元素（Sift Up）</a></h2>
<p>我们来看看如何往堆中添加元素，首先堆是一个完全二叉树，往堆中添加一个元素，从树的层面来看，就是往最后一层的最右端添加一个元素，如果最后一层已经满了，那么就新加一层。如果从数组的层面来看，就相当于 append 一个元素。</p>
<p>假设我们往刚才的堆中添加一个 52，那么堆的示意图就会变成如下这样：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./3.png" alt="" /></p>
<p>添加的过程非常简单，因为往堆里面添加一个节点，就是往数组里面 append 一个元素，但显然还没有结束。因为堆有两个性质，虽然我们添加元素之后仍然满足是一棵完全二叉树，但是不满足子节点都不大于它的父节点（这里我们构建的是大根堆），因为 52 明显大于它的父节点 16。</p>
<p>因此还要进行调整，将新添加的节点放到属于它的位置，具体过程也很简单：将该节点和它的父节点进行比较，如果比它的父节点大，那么就进行交换；交换之后再和它新的父节点进行比较，如果还大于新的父节点则继续交换，直到不大于为止。</p>
<p>所以从尾部添加的节点，一直向上浮动，直到找到属于它的位置，因此这个过程也被称为 Sift Up（上浮），具体示意图如下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./4.png" alt="" /></p>
<p>当交换之后，发现不大于它的父节点，那么该节点就可以停下来了。可能有人问，它父节点之上的节点该怎么办？比如爷爷节点。答案是不需要关心，因为大根堆的性质就是每个子节点不大于父节点。所以当新添加的节点不大于它的父节点时，也更不可能大于父节点之上的爷爷节点。</p>
<p>下面我们就编写代码实现一下：</p>
<pre><code class="language-python">class BinaryHeap:
    &quot;&quot;&quot;
    大根堆
    &quot;&quot;&quot;
    def __init__(self):
        # 通过数组来模拟堆，为避免直接修改堆
        # 这个数组不对外暴露，而是专门提供一个接口
        self.__data = []
    
    def show_heap(self):
        return self.__data
    
    @staticmethod
    def get_parent(i: int) -&gt; int:
        # 根据节点的索引找到其父节点的索引
        return (i - 1) // 2

    def heappush(self, item: int):
        # 往堆中添加一个节点，对于数组而言，直接 append 即可
        self.__data.append(item)
        # 但是还没有结束，添加完之后不满足堆的性质
        # 我们还要对堆进行调整，由 sift_up 函数负责，它接收一个索引
        # 表示对指定索引的节点进行上浮，显然这里是最后一个
        self.sift_up(len(self.__data) - 1)
    
    def sift_up(self, i: int):
        # 对指定索引位置的节点进行上浮
        while i &gt; 0:
            parent = self.get_parent(i)
            # 当该元素不是根节点的时候，将其和父节点进行比较
            # 如果大于父节点，两者进行交换
            if self.__data[i] &gt; self.__data[parent]:
                self.__data[i], self.__data[parent] = self.__data[parent], self.__data[i]
                # 交换之后该节点成为了父节点，然后将 parent 赋值为 i
                # 因为它还要继续作为新的子节点和新的父节点比较
                i = parent
            else:
                # 如果不大于父节点，说明该元素已经找到属于它的位置了
                # 直接将循环结束掉即可
                break
        
heap = BinaryHeap()
for item in [62, 41, 30, 28, 16, 22, 13, 19, 17, 15]:
    heap.heappush(item)
print(heap.show_heap())
&quot;&quot;&quot;
[62, 41, 30, 28, 16, 22, 13, 19, 17, 15]

                        62
            41                       30
      28          16           22          13
  19      17  15
&quot;&quot;&quot;

# 这个时候再添加一个元素 52
heap.heappush(52)
print(heap.show_heap())
&quot;&quot;&quot;
[62, 52, 30, 28, 41, 22, 13, 19, 17, 15, 16]

                        62
            52                       30
      28          41           22          13
  19      17  15      16
&quot;&quot;&quot;
</code></pre>
<p>可以看到结果是没有问题的，以上我们添加元素就成功了，下面我们再来看看如何从堆中取出元素。</p>
<h2 id="从堆中取出元素sift-down"><a class="header" href="#从堆中取出元素sift-down">从堆中取出元素（Sift Down）</a></h2>
<p>正如添加节点从堆底添加，取出节点只能从堆顶取出（也就是只能取根节点），不能取其它位置的节点。</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./5.png" alt="" /></p>
<p>但问题是，如果直接将堆顶的节点取走的话，就会形成两个独立的堆，两个堆的根节点分别是它的左右节点。我们还要手动将两个堆合并在一起，会比较麻烦，因此可以换个思路，将堆顶和堆底的元素进行交换。交换之后，弹出堆底的元素，这样就得到了最大值。</p>
<p>但该做法同时也破坏了堆的第二个性质，因为之前的堆底元素现在跑到了堆顶，肯定不满足父节点和子节点之间的大小关系，所以还要进行调整。</p>
<p>对于大根堆而言，将该节点和左右子节点中大的那一个进行比较，如果比子节点小，那么进行交换。交换之后再和它新的子节点进行比较，如果还小于新的子节点则继续交换，直到不小于为止。</p>
<p>所以从顶部的节点，一直向下沉，直到找到属于它的位置，因此这个过程也被称为 Sift Down（下沉），具体示意图如下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./6.png" alt="" /></p>
<p>注意：堆顶节点和堆底节点交换之后，就被弹出了，所以图中的 62 不再是堆节点，因此我们刻意画的淡了一些。</p>
<p>下面完善一下之前的代码：</p>
<pre><code class="language-python">class BinaryHeap:
    &quot;&quot;&quot;
    大根堆
    &quot;&quot;&quot;
    def __init__(self):
        self.__data = []
    
    def show_heap(self):
        return self.__data
    
    @staticmethod
    def get_parent(i: int) -&gt; int:
        # 根据节点的索引找到其父节点的索引
        return (i - 1) // 2
    
    @staticmethod
    def get_left_child(i: int) -&gt; int:
        # 根据节点的索引找到左孩子节点的索引
        return 2 * i + 1
    
    @staticmethod
    def get_right_child(i: int) -&gt; int:
        # 根据节点的索引找到右孩子节点的索引
        return 2 * i + 2

    def heappush(self, item: int):
        self.__data.append(item)
        self.sift_up(len(self.__data) - 1)
    
    def sift_up(self, i: int):
        while i &gt; 0:
            parent = self.get_parent(i)
            if self.__data[i] &gt; self.__data[parent]:
                self.__data[i], self.__data[parent] = self.__data[parent], self.__data[i]
                i = parent
            else:
                break
            
    def heappop(self):
        # 弹出堆顶元素
        if len(self.__data) == 0:
            raise IndexError(&quot;pop from empty heap&quot;)
        # 将第一个元素和最后一个元素进行交换
        self.__data[0], self.__data[-1] = self.__data[-1], self.__data[0]
        # 弹出最后一个元素
        item = self.__data.pop()
        # 不过在返回之前，记得调整一下堆，由 sift_down 函数负责
        # 此函数接收一个索引，表示对指定节点的索引进行下沉
        # 显然这里是第一个
        self.sift_down(0)
        return item
    
    def sift_down(self, i: int):
        # 对索引为 i 的节点进行下沉，这里需要判断孩子节点是否存在的情况
        # 如果左孩子节点的索引越界，说明该节点已经是叶子节点了
        while self.get_left_child(i) &lt; len(self.__data):
            left_child = self.get_left_child(i)
            right_child = self.get_right_child(i)
            # 获取子节点大的那一个，注意：需要考虑右节点是否存在的情况
            if right_child &lt; len(self.__data) and self.__data[right_child] &gt; self.__data[left_child]:
                child = right_child
            else:
                child = left_child
            # 将该节点和孩子节点进行比较，如果比孩子节点小，那么交换位置
            # 并继续和新的孩子节点进行比较
            if self.__data[i] &lt; self.__data[child]:
                self.__data[i], self.__data[child] = self.__data[child], self.__data[i]
                i = child
            # 否则直接跳出循环
            else:
                break

heap = BinaryHeap()
data = [4, 8, 1, 5, 3, 9, 2, 7, 6]
# 依次添加到堆中
for item in data:
    heap.heappush(item)
# 从堆中弹出，由于每次都会弹出最大值
# 所以得到的新列表是降序排序的    
print([heap.heappop() for _ in range(len(data))])
&quot;&quot;&quot;
[9, 8, 7, 6, 5, 4, 3, 2, 1]
&quot;&quot;&quot;
</code></pre>
<p>显然是没有问题的，因此我们这里就实现了一个堆排序，只不过这个堆排序还不太完美，不完美之处有两个地方：</p>
<ul>
<li>默认是从大到小排序的，应该提供一个参数供外界选择究竟是从大到小还是从小到大；</li>
<li>开辟了一个额外的数组，合适的做法应该是接收一个数组，然后原地排序；</li>
</ul>
<p>那么下面我们完善一下堆排序。</p>
<pre><code class="language-python">def get_left_child(i: int):
    return 2 * i + 1

def get_right_child(i: int):
    return 2 * i + 2

def sift_down_large(data: list, i: int, length: int):
    # 大根堆下沉，但是参数多了一个 length，这是为啥呢？
    # 因为之前是将堆顶和堆底的元素交换之后，就将堆底的元素弹出去了
    # 以至于我们需要单独开辟一个数组去接收
    # 但很明显，我们这里要求原地排序，那么交换之后的元素在堆底不可以动
    # 因此每 sift_down 一次，length 要减去 1
    while get_left_child(i) &lt; length:
        left_child = get_left_child(i)
        right_child = get_right_child(i)
        # 判断是否有右孩子，如果有右孩子，那么选择值较大的那一个孩子节点
        if right_child &lt; length and data[right_child] &gt; data[left_child]:
            child = right_child
        else:
            child = left_child
        # 如果比孩子节点的值小，那么两者进行交换，因为大根堆要求父节点不小于子节点
        if data[i] &lt; data[child]:
            data[i], data[child] = data[child], data[i]
            i = child
        else:
            break


def sift_down_small(data: list, i: int, length: int):
    # 小根堆下沉
    while get_left_child(i) &lt; length:
        left_child = get_left_child(i)
        right_child = get_right_child(i)
        # 判断是否有右孩子，如果有右孩子，那么选择值较小的那一个孩子节点
        if right_child &lt; length and data[right_child] &lt; data[left_child]:
            child = right_child
        else:
            child = left_child
        # 如果比孩子节点的值大，那么两者进行交换，因为小根堆要求父节点不大于子节点
        if data[i] &gt; data[child]:
            data[i], data[child] = data[child], data[i]
            i = child
        else:
            break

def heapify_large(data: list):
    # 将一个数组整理成大根堆的形状
    # 从最后一个非叶子节点进行 sift_down 即可
    for i in range((len(data) - 1) &gt;&gt; 1, -1, -1):
        sift_down_large(data, i, len(data))

def heapify_small(data: list):
    # 将一个数组整理成小根堆的形状
    for i in range((len(data) - 1) &gt;&gt; 1, -1, -1):
        sift_down_small(data, i, len(data))
        
def heap_sort(data: list, reverse: bool = False):
    # 堆排序，首先将 data 整理成堆的形状
    if reverse:
        heapify_small(data)
    else:
        heapify_large(data)
    # i 从最后一个元素开始
    for i in range(len(data) - 1, -1, -1):
        # 交换完之后的元素就不可以动了
        data[0], data[i] = data[i], data[0]
        # 并且也不能再参与后续的 sift_down，因此依旧调整堆，但是范围变了
        # 比如第一次交换，那么最后一个元素为最大值
        # sift_down 的时候，整个范围就是 [0: len(data) - 1]
        # 同理第二次 sift_down 的时候，范围就是 [0: len(data) - 2]
        if reverse:
            sift_down_small(data, 0, i)
        else:
            sift_down_large(data, 0, i)


import random
data = [random.randint(0, 100) for _ in range(10)]
print(data)
&quot;&quot;&quot;
[51, 4, 38, 31, 87, 18, 39, 8, 98, 61]
&quot;&quot;&quot;
heap_sort(data)
print(data)
&quot;&quot;&quot;
[4, 8, 18, 31, 38, 39, 51, 61, 87, 98]
&quot;&quot;&quot;

data = [random.randint(0, 100) for _ in range(10)]
print(data)
&quot;&quot;&quot;
[78, 11, 83, 30, 99, 61, 45, 63, 17, 81]
&quot;&quot;&quot;
heap_sort(data, reverse=True)
print(data)
&quot;&quot;&quot;
[99, 83, 81, 78, 63, 61, 45, 30, 17, 11]
&quot;&quot;&quot;
</code></pre>
<p>以上我们就实现了堆排序，那么问题来了，你觉得 heapq 模块里的 nlargest 和 nsmallest 是怎么实现的呢？</p>
<p>很简单，假设我们要选取 k 个最小的元素，那么首先可以从数组中截取前 k 个元素，构建一个大根堆。然后从第 k + 1 个元素开始遍历数组，如果当前元素大于等于堆顶元素，那么它肯定就不是前 k 小的元素，如果当前元素小于堆顶的元素，那么两者进行交换，然后进行一次 Sift Down 操作。当数组遍历完毕之后，堆中的 k 个元素就是最小的前 k 个元素。同理，如果想选择前 k 个最大的元素，那么就构建一个小根堆。</p>
<blockquote>
<p>或者将整个数组构建成一个堆，然后heappop k 次即可，这样也能选择前 k 个元素。</p>
</blockquote>
<h2 id="优先队列"><a class="header" href="#优先队列">优先队列</a></h2>
<p>其实在排序的时候，堆排序不是效率最高的排序，它比三路快排要慢一些。但是堆存在的目的绝不仅仅是为了排序，由于它可以动态添加元素、删除元素，并且时间复杂度都为 O(logN) 级别，所以堆的强大之处就在于非常适合实现优先队列。</p>
<p>事实上 heapq 也已经为我们提供了堆的相关操作：</p>
<pre><code class="language-Python">&quot;&quot;&quot;
heapq.heapify(data)
    将数组 data 整理成堆的形状，只支持小根堆

heapq.heappush(data, item)
    向堆中添加元素，并维护堆的形状
    要求 data 已经是一个小根堆

heapq.heappop(data, item)
    从堆中弹出元素，并维护堆的形状
    要求 data 已经是一个小根堆
&quot;&quot;&quot;
</code></pre>
<p>而 Python 的优先队列，底层就是借助于 heapq 实现的，我们看一下：</p>
<p><img src="%E9%80%9A%E8%BF%87%20TOP%20K%20%E9%97%AE%E9%A2%98%EF%BC%8C%E6%8E%A2%E7%A9%B6%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%9A%84%E7%A7%98%E5%AF%86/./7.png" alt="" /></p>
<p>里面的 item 是一个元组，第一个元素是优先级（值越小、优先级越高），第二个元素是具体的数据，这就是优先队列，是不是比你想象中的要简单许多呢？</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>堆是一种非常高效的数据结构，它可以动态地添加、删除元素，并且时间复杂度均为 O(logN) 级别。这个特性就决定了它非常适合实现优先队列，维护一个堆，在往堆中添加元素的时候，只需要加一个优先级即可，也就是将优先级和数据组合成一个元组添加到堆中。如果构建的是小根堆，值越小、优先级越高；构建的是大根堆，值越大，优先级越高。</p>
<p>另外我们说，当获取最大值或最小值时，推荐使用内置函数 max 和 min。但如果数组 data 一直在动态变化，并且要随时获取里面的最大值或最小值，那么相比使用内置函数 max、min，更好的做法是将 data 维护成一个堆。然后添加元素使用 heappush，获取元素直接 data[0] 即可。因为这整体是一个 O(logN) 的操作，而是 min、max 是一个 O(N) 的操作。</p>
<p>最后，堆可以用来实现排序，效率也很高，但相比三路快排还差了那么一点。但堆存在的目的不在于排序，而在于它的动态性。优先队列就不必说了，还有 TOP K。虽然三路快排和堆都可以实现 TOP K，但前者要求数据必须一次性全部给出，而堆则没有这个要求，换句话说堆可以满足对流式数据的处理。</p>
<p>比如 1T 的文件，一行就是一串数字，如果想在 16G 内存的机器上查找最大的 100 个数字，用快排是无法实现的，因为无法将文件一次性加载到内存中。但堆可以实现这个需求，先读取 100 行维护一个小根堆，然后从 101 行继续读取，依次和堆顶进行比较。如果小于堆顶元素，那么它一定不是前 100 个最大的数字；如果大于堆顶元素，那么就替换掉，然后 sift_down，维护堆的形状。这样总有一刻，能够选出最大的 100 个数字。</p>
<p>所以当数组 data 不断变化时，将其维护成一个堆，然后通过 heappush 添加元素、heappop 弹出堆顶元素、data[0] 获取堆顶元素，往往是最佳选择。并且添加和弹出都是 logN 级别的时间复杂度，也正是这个特性，它适合优先队列以及流式数据（数据无法一次性全部给出）的处理。</p>
<div style="break-before: page; page-break-before: always;"></div><p>假设有这样一种数据：</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

# 我们需要变成如下格式
&quot;&quot;&quot;
[('apple', [30, 35, 32]),
 ('pear', [60, 32, 60]),
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>如果是你的话，你会怎么做呢？很容易想到的一种解决方案是构造一个字典：</p>
<pre><code class="language-python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

data_dict = {}
for name, count in data:
    if name not in data_dict:
        data_dict[name] = []
    data_dict[name].append(count)

print(data_dict)
&quot;&quot;&quot;
{'apple': [30, 35, 32], 
 'pear': [60, 32, 60], 
 'banana': [102, 104]}
&quot;&quot;&quot;
print(list(data_dict.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]), 
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>这种方案完全没有问题，不过我们还可以写的更优雅一些，也就是使用字典的 setdefault 方法：</p>
<pre><code class="language-Python">data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

data_dict = {}
for name, count in data:
    # setdefault(k, v) 含义如下
    # 当 k 不存在时，将 k: v 设置在字典中，并返回 v
    # 当 k 存在时，直接返回 k 对应值
    data_dict.setdefault(name, []).append(count)

print(list(data_dict.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]), 
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;
</code></pre>
<p>setdefault 是一个非常方便的方法，但是使用频率却不怎么高，或者说该方法不太让人喜欢。主要是每次调用都要给一个初始值，比如代码中的空列表 []。另外这里的初始值可以任意，如果你希望添加的时候还能实现去重效果，那么就将空列表换成空集合即可。</p>
<p>或者我们还可以使用 defaultdict，它位于 collections 模块中。</p>
<pre><code class="language-Python">from collections import defaultdict

data = [
    (&quot;apple&quot;, 30), (&quot;apple&quot;, 35),
    (&quot;apple&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;pear&quot;, 32), (&quot;pear&quot;, 60),
    (&quot;banana&quot;, 102), (&quot;banana&quot;, 104)
]

# 里面接收一个 callable
# 当访问的 k 不存在时，返回 callable 调用之后的值
data_dict1 = defaultdict(list)
for name, count in data:
    data_dict1[name].append(count)

print(list(data_dict1.items()))
&quot;&quot;&quot;
[('apple', [30, 35, 32]),
 ('pear', [60, 32, 60]), 
 ('banana', [102, 104])]
&quot;&quot;&quot;

# 也可以指定为 set
data_dict2 = defaultdict(set)
for name, count in data:
    data_dict2[name].add(count)

print(list(data_dict2.items()))
&quot;&quot;&quot;
[('apple', {32, 35, 30}), 
 ('pear', {32, 60}), 
 ('banana', {104, 102})]
&quot;&quot;&quot;
</code></pre>
<p>总的来说，defaultdict 和字典的 setdefault 方法非常类似，我们使用 setdefault 即可，因为 setdefault 其实更加方便。我们不妨再看个更复杂的例子。</p>
<pre><code class="language-Python">data = [
    (&quot;a&quot;, &quot;x&quot;, 1),
    (&quot;a&quot;, &quot;x&quot;, 2),
    (&quot;a&quot;, &quot;x&quot;, 3),
    (&quot;a&quot;, &quot;y&quot;, 4),
    (&quot;a&quot;, &quot;y&quot;, 5),
    (&quot;a&quot;, &quot;z&quot;, 6),
    
    (&quot;b&quot;, &quot;x&quot;, 7),
    (&quot;b&quot;, &quot;x&quot;, 8),
    (&quot;b&quot;, &quot;y&quot;, 9),
    (&quot;b&quot;, &quot;z&quot;, 10),
]
# 如果我想得到下面的结果，怎么做呢？
&quot;&quot;&quot;
{'a': {'x': [1, 2, 3], 'y': [4, 5], 'z': [6]}, 
 'b': {'x': [7, 8], 'y': [9], 'z': [10]}}
&quot;&quot;&quot;
# 使用 setdefault 会非常方便
data_dict = {}
for first, second, value in data:
    data_dict.setdefault(first, {}).setdefault(second, []).append(value)

print(data_dict)
</code></pre>
<p>以上就是数据分组，比较简单，setdefault 这个方法非常方便，但总是容易被遗忘。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="楔子-1"><a class="header" href="#楔子-1">楔子</a></h2>
<p>在 Python3.6 之前，格式化字符串一般会使用百分号占位符或者 format 函数，举个例子：</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;

# 使用百分号占位符格式化字符串
print(
    &quot;我是 %s, 来自 %s&quot; % (name, address)
)  # 我是 古明地觉, 来自 地灵殿

# 使用format函数格式化字符串
print(
    &quot;我是 {}, 来自 {}&quot;.format(name, address)
)  # 我是 古明地觉, 来自 地灵殿

# format 函数还支持关键字参数
print(
    &quot;我是 {name}, 来自 {address}&quot;.format(address=address, name=name)
)  # 我是 古明地觉, 来自 地灵殿
</code></pre>
<p>但是从 3.6 开始，Python 新增了一个格式化字符串的方法，称之为 f-string。f-string 的功能非常强大，可以说是一把 &quot;瑞士军刀&quot;。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;

print(
    f&quot;我是 {name}, 来自 {address}&quot;
)  # 我是 古明地觉, 来自 地灵殿
</code></pre>
<p>使用 f-string 需要给字符串增加一个前缀 f，此时 <strong>{}</strong> 和它里面的内容则不再表示字符串，而是整体作为一个需要单独计算的值或者表达式、或者变量。我们再举个例子：</p>
<pre><code class="language-Python">print(f&quot;1 + 1 = {1 + 1}&quot;)  # 1 + 1 = 2
print(f&quot;sum([1, 2, 3]) = {sum([1, 2, 3])}&quot;)  # sum([1, 2, 3]) = 6
print(f&quot;{'--'.join(['a', 'b', 'c', 'd'])}&quot;)  # a--b--c--d

try:
    print(f&quot;{a}&quot;)
except Exception as e:
    print(e)  # name 'a' is not defined

# 在f-string中，{} 里面的内容是需要单独计算的
# 可以是常量，比如 {123}、{'hello'} 等等。可以是表达式，比如 {1 + 1}、{2 &gt; 1} 等等
# 可以是变量，比如 {a}、{name}，但是变量要定义好，而上面的 a 没有定义，所以报错

# 或者定义一个变量
a = lambda x: x + 100
print(f&quot;{a}&quot;)  # &lt;function &lt;lambda&gt; at 0x000...&gt;
print(f&quot;{a(1)}&quot;)  # 101
</code></pre>
<p>我们看到 f-string 还是很方便的，并且和 format 功能类似，但是性能要优于 format 函数。当然 f-string 的功能远没有目前介绍的这么简单，它支持的操作非常多，下面就来逐一介绍。</p>
<h2 id="实现-repr-打印"><a class="header" href="#实现-repr-打印">实现 repr 打印</a></h2>
<p>有时候我们在打印的时候需要带上引号。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

print(name)  # 古明地觉
print(&quot;%s&quot; % name)  # 古明地觉
# 如果使用 %r 打印，会带上单引号
print(&quot;%r&quot; % name)  # '古明地觉'

# 上面类似于 str 和 repr 的区别
print(str(name))  # 古明地觉
print(repr(name))  # '古明地觉'

# 等价于调用 __str__ 和 __repr__
print(name.__str__())  # 古明地觉
print(name.__repr__())  # '古明地觉'
</code></pre>
<p>如果在交互式环境下，不使用 print，而是直接输入变量 name、然后回车，那么会调用 __repr__ 方法。如果使用 print(name)，那么不管在什么环境，都会调用 __str__ 方法。</p>
<p>那么在字符串周围带上一层单引号，有什么意义呢？</p>
<pre><code class="language-python">birthday = &quot;1995-07-05&quot;
print(&quot;select name from where birthday &gt; %s&quot; % birthday)  
print(&quot;select name from where birthday &gt; %r&quot; % birthday)  
&quot;&quot;&quot;
select name from where birthday &gt; 1995-07-05
select name from where birthday &gt; '1995-07-05'
&quot;&quot;&quot;
</code></pre>
<p>看到区别了吗？如果是第一个查询，那么肯定是会报错的。重点来了，如何通过 f-string 实现这种效果呢？</p>
<pre><code class="language-Python">birthday = &quot;1995-07-05&quot;

# 我们只需要在打印的内容后面加上一个!r即可
print(f&quot;{birthday!r}&quot;)  # '1995-07-05'
print(f&quot;{birthday}&quot;)  # 1995-07-05

# &quot;{name}&quot; &lt;==&gt; str(name) &lt;==&gt; name.__str__()
# &quot;{name!r}&quot; &lt;==&gt; repr(name) &lt;==&gt; name.__repr__()

print(f&quot;{'.'.join(['a', 'b', 'c'])}&quot;)  # a.b.c
print(f&quot;{'.'.join(['a', 'b', 'c'])!r}&quot;)  # 'a.b.c'

# 注意：!r 针对的是字符串
# 虽然也可以作用于其它对象，不过没有效果
print(f&quot;{123!r}&quot;)  # 123
print(f&quot;{3.14!r}&quot;)  # 3.14

# 另外除了 !r，还有 !s 和 !a，只有这三种
# !a 和 !r 类似，!s是默认选择、加不加均可
print(f&quot;{birthday}&quot;)  # 1995-07-05
print(f&quot;{birthday!s}&quot;)  # 1995-07-05
print(f&quot;{birthday!a}&quot;)  # '1995-07-05'
print(f&quot;{birthday!r}&quot;)  # '1995-07-05'
</code></pre>
<p>以上就是字符串的 repr 打印。</p>
<h2 id="整数的进制转换"><a class="header" href="#整数的进制转换">整数的进制转换</a></h2>
<p>我们在打印整数的时候，有时候需要转成某个进制之后再打印。</p>
<pre><code class="language-Python">i = 123
# 打印 2 进制
print(f&quot;{i:b}&quot;)  # 1111011
# 打印 8 进制
print(f&quot;{i:o}&quot;)  # 173
# 打印 10 进制
# 默认是 10 进制，也可以直接使用 {i}
print(f&quot;{i:d}&quot;)  # 123
# 打印 16 进制
print(f&quot;{i:x}&quot;)  # 7b

# 类似于内置函数 bin、oct、hex
# 但是这些内置函数调用之后会带上一个前缀
print(bin(i))  # 0b1111011
print(oct(i))  # 0o173
print(hex(i))  # 0x7b

# f-string 可不可以实现呢？答案是可以的
print(f&quot;{i:#b}&quot;)  # 0b1111011
print(f&quot;{i:#o}&quot;)  # 0o173
print(f&quot;{i:#x}&quot;)  # 0x7b
# 对于表示 16 进制的 x，我们还可以将 x 大写
# 此时输出的内容也是大写格式的
print(f&quot;{i:#X}&quot;)  # 0X7B
</code></pre>
<p>另外除了 # 号，还可以使用 +、-、以及空格，功能如下：</p>
<ul>
<li>+：显示正负号；</li>
<li>-：负数显示符号、正数不显示；</li>
<li>空格：正数显示空格、负数不显示，只能是一个空格；</li>
<li>#：显示前缀，比如 0b、0o、0x</li>
</ul>
<p>注意：这几个符号不可混用，并且最多只能出现一次。</p>
<pre><code class="language-Python">print(f&quot;{123:+x}, {-123:+x}&quot;)  # +7b, -7b
print(f&quot;{123:-x}, {-123:-x}&quot;)  # 7b, -7b
print(f&quot;{123: x}, {-123: x}&quot;)  #  7b, -7b
print(f&quot;{123:#x}, {-123:#x}&quot;)  # 0x7b, -0x7b
</code></pre>
<p>另外，Python 在创建整数的时候，还支持使用 _ 进行分隔，但打印的时候不会将 _ 显示出来。</p>
<pre><code class="language-Python">num = 100_000_000
print(num)  # 100000000

# 但如果是 f-string 的话
print(f&quot;{num:_d}&quot;)
&quot;&quot;&quot;
100_000_000
&quot;&quot;&quot;
print(f&quot;{num:_b}&quot;)
print(f&quot;{num:#_b}&quot;)
&quot;&quot;&quot;
101_1111_0101_1110_0001_0000_0000
0b101_1111_0101_1110_0001_0000_0000
&quot;&quot;&quot;
print(f&quot;{num:_o}&quot;)
print(f&quot;{num:#_o}&quot;)
&quot;&quot;&quot;
5_7536_0400
0o5_7536_0400
&quot;&quot;&quot;
print(f&quot;{num:_x}&quot;)
print(f&quot;{num:#_x}&quot;)
&quot;&quot;&quot;
5f5_e100
0x5f5_e100
&quot;&quot;&quot;

# 只需要在 b、d、o、x 前面加上一个 _ 即可
# 这样打印出来的字符串也会带上 _ 分隔符
# 另外分隔符还可以使用逗号
print(f&quot;{num:,d}&quot;)
&quot;&quot;&quot;
100,000,000
&quot;&quot;&quot;
</code></pre>
<p>注意：b、o、d、x 这些只能用于整数，不能是其它类型的对象。</p>
<pre><code class="language-Python">print(f&quot;{'aaa':b}&quot;)
&quot;&quot;&quot;
    print(f&quot;{'aaa':b}&quot;)
ValueError: Unknown format code 'b' for object of type 'str'
&quot;&quot;&quot;
</code></pre>
<p>最后再来补充一个字符，整数除了可以使用 b、o、d、x 之外， 还可以使用一个字符，也就是 c。</p>
<pre><code class="language-Python">num = 97

print(chr(num))  # a
print(f&quot;{num:c}&quot;)  # a
</code></pre>
<p>以上就是整数的进制转换。</p>
<h2 id="整数的填充"><a class="header" href="#整数的填充">整数的填充</a></h2>
<p>很多时候，打印出来的整数都会进行位数的填充，比如 1 的话，就打印 001，18 则打印 018，123 则打印本身的 123。这种需求，要怎么去处理它呢？</p>
<pre><code class="language-Python">num = 1
# 还记得这个 d 吗？
# 我们说直接打印的话，有它没它无影响
# 但是对于填充的话，它就派上用场了
print(f&quot;{num:03d}&quot;)  # 001
print(f&quot;{num:013d}&quot;)  # 0000000000001
</code></pre>
<p>填充只能用 0 或者空格来填充，比如 0123d，表示打印出来要占 123 个字符，够的话不管了，不够则使用 0 在左边填充。</p>
<p>如果是 123d，它代表的可不是占 23 个字符、不够用 1 填充，它代表的还是占 123 个字符，但是由于我们没有指定 0，所以默认使用空格在左边填充。</p>
<pre><code class="language-Python"># 长度 23，不够使用空格填充
print(f&quot;{1:23d}&quot;)   #                       1
# 长度 23，不够使用 0 填充
print(f&quot;{1:023d}&quot;)  # 00000000000000000000001

# 当然我们同样可以结合 +、-、空格、#
print(f&quot;{1:+08d}&quot;)  # +0000001
# 可以的话，再将分隔符包含进来
print(f&quot;{1:+023_d}&quot;)  # +00_000_000_000_000_001
print(f&quot;{1:+023,d}&quot;)  # +00,000,000,000,000,001
</code></pre>
<p>当然，以上规则除了适用于十进制的 d，也同样适用于二进制的 b、八进制的 o、十六进制的 x。</p>
<pre><code class="language-Python">print(f&quot;{123:x}&quot;)
print(f&quot;{123:016x}&quot;)
&quot;&quot;&quot;
7b
000000000000007b
&quot;&quot;&quot;

# 打印显示正负号，然后占 8 个字符
print(f&quot;{123:+08d}&quot;)
print(f&quot;{123:+8d}&quot;)
&quot;&quot;&quot;
+0000123
    +123
&quot;&quot;&quot;

# 打印的时候带上前缀，占 18 个字符
print(f&quot;{123:#018b}&quot;)
print(f&quot;{123:#18b}&quot;)
# 打印的时候带上前缀和分隔符，占 18 个字符
print(f&quot;{123:#18_b}&quot;)
&quot;&quot;&quot;
0b0000000001111011
         0b1111011
        0b111_1011
&quot;&quot;&quot;
</code></pre>
<p>我们看到填充的时候，如果用 0 填充，那么会填充在 0b、+ 等前缀的后面；如果用空格填充，那么会填充在前缀的前面。当然这也符合我们正常人的思维：</p>
<ul>
<li>如果是 &quot;+    123&quot; 或者 &quot;00000+123&quot;，明显觉得别扭；</li>
<li>如果是 &quot;    +123&quot; 或者 &quot;+00000123&quot;，则明显顺眼多了；</li>
</ul>
<p>当然工作中我们不会用的这么复杂，知道整数如何填充即可。</p>
<h2 id="浮点数的小数保留"><a class="header" href="#浮点数的小数保留">浮点数的小数保留</a></h2>
<p>浮点数的小数比较长的话，我们打印的时候一般会只打印前两位或前三位，这在 f-string 里面如何实现呢？</p>
<pre><code class="language-Python">num = 123.13421

# f 是保留小数，但我们没有指定精度，所以默认保留后 6 位，不够用 0 补齐
print(f&quot;{num:f}&quot;)
&quot;&quot;&quot;
123.134210
&quot;&quot;&quot;

# .2f 则是保留两位小数
print(f&quot;{num:.2f}&quot;)
&quot;&quot;&quot;
123.13
&quot;&quot;&quot;

# 10.2f 也是保留两位小数，然后整体占满 10 个字符长度，不够的话使用空格在左边填充
print(f&quot;{num:10.2f}&quot;)
&quot;&quot;&quot;
    123.13
&quot;&quot;&quot;

# 如果不想使用空格填充的话
# 那么也可以使用(也只能使用) 0 来进行填充，规则和整数是类似的
print(f&quot;{num:010.2f}&quot;)
&quot;&quot;&quot;
0000123.13
&quot;&quot;&quot;
</code></pre>
<p>当然 +、-、空格 同样可以适用于浮点数，规则也和整数类似，同样的，下面这些在工作中也不常用，所以我们知道怎么保留指定位数的小数即可。</p>
<pre><code class="language-Python">num = 123.13421

print(f&quot;{num:+10.2f}&quot;)   
print(f&quot;{num:+010.2f}&quot;)  
&quot;&quot;&quot;
   +123.13
+000123.13
&quot;&quot;&quot;

# 同理，浮点数也支持使用下划线或者逗号进行分隔
print(f&quot;{num:+10_.2f}&quot;)  
print(f&quot;{num:+10,.2f}&quot;) 
&quot;&quot;&quot;
   +123.13
   +123.13
&quot;&quot;&quot;

# 上面由于有效字符比较少，所以没有分隔符
# 我们用 0 填充一下
print(f&quot;{num:+010_.2f}&quot;)
print(f&quot;{num:+010,.2f}&quot;)
&quot;&quot;&quot;
+00_123.13
+00,123.13
&quot;&quot;&quot;
</code></pre>
<p>以上就是浮点数的小数保留。</p>
<h2 id="任意字符的填充"><a class="header" href="#任意字符的填充">任意字符的填充</a></h2>
<p>我们上面介绍的还只是 f-string 的一部分，接下来就是 f-string 的杀手锏。</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

print(f&quot;~{name:&gt;10}~&quot;)
print(f&quot;~{name:^10}~&quot;)
print(f&quot;~{name:&lt;10}~&quot;)
&quot;&quot;&quot;
~      古明地觉~
~   古明地觉   ~
~古明地觉      ~
&quot;&quot;&quot;
</code></pre>
<ul>
<li>&gt;n：输出的字符串占 n 个字符，原始的内容右对齐，长度不够则在左边用空格填充；</li>
<li>^n：输出的字符串占 n 个字符，原始的内容居中对齐，长度不够则在左右两端用空格填充；</li>
<li>&lt;n：输出的字符串占 n 个字符，原始的内容左对齐，长度不够则在右边用空格填充；</li>
</ul>
<p>还可以将 !r、!s、!a 结合起来使用。</p>
<pre><code class="language-Python">print(f&quot;{'abc'!s:&gt;10}&quot;) 
print(f&quot;{'abc'!r:&gt;10}&quot;) 
print(f&quot;{'abc'!a:&gt;10}&quot;) 
&quot;&quot;&quot;
       abc
     'abc'
     'abc'
&quot;&quot;&quot;
</code></pre>
<p>这些规则也适用于数值：</p>
<pre><code class="language-Python">print(f&quot;{3:&gt;10}&quot;)
print(f&quot;{3.14:&gt;10}&quot;)
&quot;&quot;&quot;
         3
      3.14
&quot;&quot;&quot;
</code></pre>
<p>另外默认是使用空格填充的，那么可不可以使用指定字符填充呢？答案是可以的, 直接在 &gt;、&lt;、^ 的左边写上用来填充的字符即可，但是只能写一个字符，多了报错。</p>
<pre><code class="language-Python">print(f&quot;~{'a':1&gt;10}~&quot;)  # ~111111111a~
print(f&quot;~{'a':1^10}~&quot;)  # ~1111a11111~
# 使用空格填充，'a': &gt;10 等价于 'a':&gt;10
print(f&quot;~{'a': &gt;10}~&quot;)  # ~         a~

# 这里我们实现了 {1:03d} 的效果
print(f&quot;{1:0&gt;3}&quot;)  # 001

print(f&quot;{123:b}&quot;)  # 1111011
print(f&quot;{123:b&lt;}&quot;)  # 123
&quot;&quot;&quot;
对于 f&quot;{123:b}&quot;，里面的 b 表示整数的进制转换
此时只能作用于整数，不能是字符串

但是对于 f&quot;{123:b&lt;}，由于里面出现了&lt;
那么此时的 b 就不再代表进制了，而是代表填充字符

只不过 &lt; 后面没有指定个数
所以解释器不知道要填充多少个，因此就原本输出了
&quot;&quot;&quot;

# 但是 f&quot;{'aaa':b}&quot; 报错
# 因为此时 b 代表进制，无法作用于字符串
print(f&quot;{'aaa':b&lt;}&quot;)  # aaa
print(f&quot;{'aaa':b&lt;4}&quot;)  # aaab
</code></pre>
<p>问题来了，如果我们希望整数在填充的时候，还能进制转化，该怎么做呢？</p>
<pre><code class="language-Python"># 转成十六进制
print(f&quot;{255:x}&quot;)
&quot;&quot;&quot;
ff
&quot;&quot;&quot;
# 转成十六进制，带前缀
print(f&quot;{123:#x}&quot;)
&quot;&quot;&quot;
0x7b
&quot;&quot;&quot;
# 转成十六进制，占满10位
# 不够使用字符 s 来左填充
print(f&quot;{123:s&gt;#10x}&quot;)
&quot;&quot;&quot;
ssssss0x7b
&quot;&quot;&quot;
</code></pre>
<p>浮点数也是类似的，在保留指定位数的同时，也可以进行填充。</p>
<pre><code class="language-Python">num = 123.1234

# 保留一位小数
print(f&quot;{num:.1f}&quot;)
&quot;&quot;&quot;
123.1
&quot;&quot;&quot;

# 保留一位小数，同时占满 10 位，此时只能用 0 或 空格填充
print(f&quot;{num:10.1f}&quot;)
print(f&quot;{num:010.1f}&quot;)
&quot;&quot;&quot;
     123.1
00000123.1
&quot;&quot;&quot;

# 如果想使用其它字符填充
print(f&quot;{num:s&lt;10.1f}&quot;)
print(f&quot;{num:s&gt;10.1f}&quot;)
print(f&quot;{num:s^10.1f}&quot;)
&quot;&quot;&quot;
123.1sssss
sssss123.1
ss123.1sss
&quot;&quot;&quot;

# 填充的时候带上正负号
print(f&quot;{num:s&lt;+10.1f}&quot;)
print(f&quot;{num:s&gt;+10.1f}&quot;)
print(f&quot;{num:s^+10.1f}&quot;)
&quot;&quot;&quot;
+123.1ssss
ssss+123.1
ss+123.1ss
&quot;&quot;&quot;

# 填充的时候带上正负号和分隔符
num = 123123123.1234
print(f&quot;{num:s&lt;+20_.1f}&quot;)
print(f&quot;{num:s&gt;+20_.1f}&quot;)
print(f&quot;{num:s^+20_.1f}&quot;)
&quot;&quot;&quot;
+123_123_123.1ssssss
ssssss+123_123_123.1
sss+123_123_123.1sss
&quot;&quot;&quot;
</code></pre>
<p>总的来说，f-string 还是非常强大的，但说实话，工作中不会用到这么多花里胡哨的功能。基本上就是简单的填充、进制转换、保留小数。很少会有 <code>f&quot;{num:s&lt;+20_.1f}&quot;</code> 这种保留小数的同时，还要带正负号、以及填充位数的情况出现。</p>
<h2 id="日期的截取"><a class="header" href="#日期的截取">日期的截取</a></h2>
<p>很多小伙伴应该没想到 f-string 还可以操作日期，这也算是一大亮点吧。我们在格式化或者截取日期的时候，一般会使用 datetime 模块，这些也是可以使用 f-string 来实现的。</p>
<pre><code class="language-Python">import datetime

dt = datetime.datetime(
    1995, 7, 5, 13, 30, 45, 100000)
print(dt)
&quot;&quot;&quot;
1995-07-05 13:30:45.100000
&quot;&quot;&quot;

# %F: 返回年月日（使用 - 连接）
print(f&quot;{dt:%F}&quot;)
&quot;&quot;&quot;
1995-07-05
&quot;&quot;&quot;
# %D: 返回日月年（使用 / 连接），但是年是两位的
# 并且也不符合中国人的日期表达习惯，建议只用 %F
print(f&quot;{dt:%D}&quot;)
&quot;&quot;&quot;
07/05/95
&quot;&quot;&quot;

# %X: 返回时间，精确到秒（小数点后面的会截断）
# 这里注意的 X 要大写，如果是 %x 那么等价于 %D
print(f&quot;{dt:%X}&quot;)
&quot;&quot;&quot;
13:30:45
&quot;&quot;&quot;

# 所以返回字符串格式的完整日期就可以这么写
print(f&quot;{dt:%F %X}&quot;)
&quot;&quot;&quot;
1995-07-05 13:30:45
&quot;&quot;&quot;

# %Y: 返回年（四位）
# %y: 返回年（两位）
print(f&quot;{dt:%Y}&quot;)
print(f&quot;{dt:%y}&quot;)
&quot;&quot;&quot;
1995
95
&quot;&quot;&quot;

# %m: 返回月
# %d: 返回天
# 注意：会占满两位，不够补0
print(f&quot;{dt:%m}&quot;)
print(f&quot;{dt:%d}&quot;)
&quot;&quot;&quot;
07
05
&quot;&quot;&quot;

# 所以 %F，我们还可以这么实现，这些符号是可以连用的
print(f&quot;{dt:%Y-%m-%d}&quot;)
&quot;&quot;&quot;
1995-07-05
&quot;&quot;&quot;

# %H: 返回小时（24小时制度）
# %I: 返回小时（12小时制度）
# 注意：会占满两位，不够补0
print(f&quot;{dt:%H}&quot;)
print(f&quot;{dt:%I}&quot;)
&quot;&quot;&quot;
13
01
&quot;&quot;&quot;

# %M: 返回分钟
# %S: 返回秒
# 注意：会占满两位，不够补0
print(f&quot;{dt:%M}&quot;)
print(f&quot;{dt:%S}&quot;)
&quot;&quot;&quot;
30
45
&quot;&quot;&quot;

# 所以完整的 &quot;年-月-日 时:分:秒&quot;
# 就可以这么实现
print(f&quot;{dt:%Y-%m-%d %H:%M:%S}&quot;)
&quot;&quot;&quot;
1995-07-05 13:30:45
&quot;&quot;&quot;

# %f: 返回微妙
# 注意：会占满六位，不够补0
print(f&quot;{dt:%f}&quot;)
&quot;&quot;&quot;
100000
&quot;&quot;&quot;

# %p: 早上还是下午（本地时间）
# 早上返回 AM、下午返回 PM
print(f&quot;{dt:%p}&quot;)
&quot;&quot;&quot;
PM
&quot;&quot;&quot;

# %j: 一年中的第几天，从 1 开始，1月1号就是 1
# 注意：会占满三位，不够补 0
print(f&quot;{dt:%j}&quot;)
&quot;&quot;&quot;
186
&quot;&quot;&quot;

# %w: 星期几（0 是周日、1 到 6 是周一到周六）
# %u: 星期几（1 到 7 是周一到周日）
# 可以看到两种格式只有星期天不一样
print(f&quot;{dt:%w}&quot;)
print(f&quot;{dt:%u}&quot;)
&quot;&quot;&quot;
3
3
&quot;&quot;&quot;

# %U: 一年中的第几周（以全年首个周日所在的星期为第 0 周）
# %W: 一年中的第几周（以全年首个周一所在的星期为第 1 周）
# %V: 一年中的第几周（以全年首个包含 1 月 4 日的星期为第 1 周）
# 都是占满两位，不够补 0
print(f&quot;{dt:%U}&quot;)
print(f&quot;{dt:%W}&quot;)
print(f&quot;{dt:%V}&quot;)
&quot;&quot;&quot;
27
27
27
&quot;&quot;&quot;
# 所以如果对应的年的第一天恰好是星期一，那么 %U 会比 %W 少 1。
# 如果不是星期一，那么两者是相等的，比如 2007 年的 1 月 1 号恰好是星期一
dt = datetime.datetime(2007, 10, 13)
print(f&quot;{dt:%U}&quot;)
print(f&quot;{dt:%W}&quot;)
print(f&quot;{dt:%V}&quot;)
&quot;&quot;&quot;
40
41
41
&quot;&quot;&quot;

# %Z: 返回时区名，如果没有则返回空字符串
print(f&quot;'{dt:%Z}'&quot;)  # ''
from pytz import timezone
dt = datetime.datetime(2007, 10, 13, tzinfo=timezone(&quot;UTC&quot;))
print(f&quot;'{dt:%Z}'&quot;)  # 'UTC'
</code></pre>
<p>怎么样，是不是很方便呢？以后在做日期的格式化和解析的时候，不妨使用 f-string 试一下。</p>
<h2 id="f-string-的注意事项"><a class="header" href="#f-string-的注意事项">f-string 的注意事项</a></h2>
<p>使用 f-string 需要注意单双引号的问题，如果限定字符串使用的是双引号，那么 {} 里面出现的必须是单引号，反之亦然。</p>
<pre><code class="language-Python">d = {&quot;a&quot;: 1}
# 外面是双引号，{} 里面必须是单引号，不能是 d[&quot;a&quot;]
print(f&quot;{d['a'] + 1}&quot;)  # 2
</code></pre>
<p>我们限定字符串的时候使用的是双引号，{} 里面必须是单引号。可能有人好奇，如果里面仍使用双引号，但通过反斜杠 \ 进行转义的话会怎么样呢？答案是不行的，因为 f-string 的 {} 里面不可以出现 \。注意：{} 是不可以出现 \，一个都不可以，所以也不要再想是不是可以使用两个 \ 进行转义啥的。</p>
<pre><code class="language-Python">try:
    print(f&quot;{\\}&quot;)
except Exception as e:
    pass
# 我们即便使用异常捕获，也是无用的，依旧会抛出 SyntaxError
# 因为 try except 是捕捉运行时的错误
# 而 {} 里面出现反斜杠属于语法上的错误，在编译成字节码阶段就会检测出来
&quot;&quot;&quot;
    print(f&quot;{\\}&quot;)
          ^
SyntaxError: f-string expression part cannot include a backslash
&quot;&quot;&quot;
</code></pre>
<p>因此：使用 f-string 同样需要注意单双引号的问题，并且 {} 里面不可以出现反斜杠。如果真的需要反斜杠，那么可以将反斜杠赋值给一个变量，然后将变量传递到 {} 里面去。</p>
<pre><code class="language-Python">a = &quot;\\&quot;
print(f&quot;{a}&quot;)  # \
</code></pre>
<p>另外，使用 f-string 时一定要注意：<strong>{</strong> 和 <strong>}</strong> 的个数要匹配。</p>
<pre><code class="language-Python"># 如果不使用 f-string，没有任何问题
# 但是使用了f-string，那么会报错
# 因为里面出现了 { 但是却没有对应的 }
# 这段代码不会通过编译
print(f&quot;我永远喜欢{古明地觉&quot;)
&quot;&quot;&quot;
    print(f&quot;我永远喜欢{古明地觉&quot;)
          ^
SyntaxError: f-string: expecting '}'
&quot;&quot;&quot;
</code></pre>
<p>可能有人好奇了，如果我只是想单纯地输入 <strong>{</strong> 这个字符呢？答案是用两个 <strong>{</strong> 进行转义。</p>
<pre><code class="language-Python">print(f&quot;我永远喜欢{{古明地觉&quot;)
&quot;&quot;&quot;
我永远喜欢{古明地觉
&quot;&quot;&quot;

# } 也是同理，需要使用两个 }} 进行转义
print(f&quot;我永远喜欢古明地觉}}&quot;)
&quot;&quot;&quot;
我永远喜欢古明地觉}
&quot;&quot;&quot;

print(f&quot;我永远喜欢{{古明地觉}}&quot;)
&quot;&quot;&quot;
我永远喜欢{古明地觉}
&quot;&quot;&quot;
</code></pre>
<p>不过这就又产生了一个问题，如果我希望外面的 <strong>{}</strong> 表示限定符，里面的 <strong>{}</strong> 表示集合该怎么办？</p>
<pre><code class="language-Python">name = &quot;古明地觉&quot;

# 打印的不是我们想要的结果
print(f&quot;{{name}}&quot;)
&quot;&quot;&quot;
{name}
&quot;&quot;&quot;

# 在内部的 {} 周围套上一层小括号即可
print(f&quot;{({name})}&quot;)
&quot;&quot;&quot;
{'古明地觉'}
&quot;&quot;&quot;

# 字典也是同理
print(f&quot;{{'name': name}}&quot;)
print(f&quot;{({'name': name})}&quot;)
&quot;&quot;&quot;
{'name': name}
{'name': '古明地觉'}
&quot;&quot;&quot;
</code></pre>
<p>还有字符串的拼接：</p>
<pre><code class="language-Python"># 等价于 &quot;你好世界&quot;
s = &quot;你好&quot; &quot;世界&quot;
print(s)  # 你好世界

name = &quot;古明地觉&quot;
address = &quot;地灵殿&quot;
# 每一部分都要带上 f
s = f&quot;{name}&quot; f&quot;{address}&quot;
print(s)  # 古明地觉,地灵殿

s = f&quot;{name}&quot; &quot;{address}&quot;
print(s)  # 古明地觉{address}

# 多行显示也是同理
s = (f&quot;{name}&quot;
     f&quot;{address}&quot;)
print(s)  # 古明地觉地灵殿
</code></pre>
<p>最后则是 lambda 表达式的问题。</p>
<pre><code class="language-Python"># 使用 lambda 表达式的时候一定要使用括号括起来
# 否则会将 lambda 中的 : 解释成表达式与格式描述符之间的分隔符
print(f&quot;{(lambda x: x + 123)(123)}&quot;)  # 246
</code></pre>
<h2 id="小结-1"><a class="header" href="#小结-1">小结</a></h2>
<p>个人觉得 f-string 算是 Python3.6 新增的一大亮点，虽然有着一些限制，但是这都不是什么问题，毕竟在做分词解析的时候肯定是有一些限制的，但总体来说 f-string 是非常强大的一个工具了。因此在格式化字符串的时候，推荐使用f-string，相信它一定可以在格式化字符串的时候给你提供很大的帮助。</p>
<p>对了，再补充一点，在 3.8 的时候给 f-string 增加了一个功能：</p>
<pre><code class="language-Python">num = 123

print(f&quot;{num=}&quot;)
print(f&quot;{num =}&quot;)
print(f&quot;{num = }&quot;)
&quot;&quot;&quot;
num=123
num =123
num = 123
&quot;&quot;&quot;
# 可以看到加上了 =，还会将 {} 里面的内容输出出来
# 像我们之前的例子
print(f&quot;sum([1, 2, 3]) = {sum([1, 2, 3])}&quot;)
&quot;&quot;&quot;
sum([1, 2, 3]) = 6
&quot;&quot;&quot;
# 加上 = 就会简洁很多
print(f&quot;{sum([1, 2, 3]) = }&quot;)
&quot;&quot;&quot;
sum([1, 2, 3]) = 6
&quot;&quot;&quot;

print(f&quot;{1 + 1 = }&quot;)
&quot;&quot;&quot;
1 + 1 = 2
&quot;&quot;&quot;

print(f&quot;{len('古明地觉') = }&quot;)
&quot;&quot;&quot;
len('古明地觉') = 4
&quot;&quot;&quot;
</code></pre>
<p>以上就是 f-string 相关的内容，这些用法你是不是都了如指掌呢？</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/custom.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
