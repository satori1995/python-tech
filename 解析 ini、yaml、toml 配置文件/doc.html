<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>解析 ini、yaml、toml 配置文件 - Python 实用技巧</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/custom.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../如何优雅地遍历可迭代对象？/doc.html">如何优雅地遍历可迭代对象？</a></li><li class="chapter-item expanded "><a href="../解密可迭代对象的排序问题/doc.html">解密可迭代对象的排序问题</a></li><li class="chapter-item expanded "><a href="../通过 TOP K 问题，探究堆和优先队列的秘密/doc.html">通过 TOP K 问题，探究堆和优先队列的秘密</a></li><li class="chapter-item expanded "><a href="../如何优雅地对数据进行分组？/doc.html">如何优雅地对数据进行分组？</a></li><li class="chapter-item expanded "><a href="../全方位解析 f-string/doc.html">全方位解析 f-string</a></li><li class="chapter-item expanded "><a href="../最好的日期处理库：pendulum/doc.html">最好的日期处理库：pendulum</a></li><li class="chapter-item expanded "><a href="../你知道创建模块都有哪些方式吗？/doc.html">你知道创建模块都有哪些方式吗？</a></li><li class="chapter-item expanded "><a href="../exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？/doc.html">exit、quit、sys.exit、os._exit，这么多退出方式，它们之间有什么区别呢？</a></li><li class="chapter-item expanded "><a href="../文件处理的一些最佳实践/doc.html">文件处理的一些最佳实践</a></li><li class="chapter-item expanded "><a href="../使用 os 模块更高效地读写文件/doc.html">使用 os 模块更高效地读写文件</a></li><li class="chapter-item expanded "><a href="../将文件映射到内存，像数组一样访问/doc.html">将文件映射到内存，像数组一样访问</a></li><li class="chapter-item expanded "><a href="../使用 psutil 获取硬件、网络以及进程信息/doc.html">使用 psutil 获取硬件、网络以及进程信息</a></li><li class="chapter-item expanded "><a href="../使用临时文件保存数据/doc.html">使用临时文件保存数据</a></li><li class="chapter-item expanded "><a href="../shutil：更优雅地拷贝文件/doc.html">shutil：更优雅地拷贝文件</a></li><li class="chapter-item expanded "><a href="../使用 contextvars 管理上下文变量/doc.html">使用 contextvars 管理上下文变量</a></li><li class="chapter-item expanded "><a href="../自定义异常堆栈信息/doc.html">自定义异常堆栈信息</a></li><li class="chapter-item expanded "><a href="../prettytable：像数据库一样格式化输出内容/doc.html">prettytable：像数据库一样格式化输出内容</a></li><li class="chapter-item expanded "><a href="../轻松绘制动态条形图/doc.html">轻松绘制动态条形图</a></li><li class="chapter-item expanded "><a href="../自定义 jupyter 魔法命令/doc.html">自定义 jupyter 魔法命令</a></li><li class="chapter-item expanded "><a href="../解析 ini、yaml、toml 配置文件/doc.html" class="active">解析 ini、yaml、toml 配置文件</a></li><li class="chapter-item expanded "><a href="../使用 fuzzywuzzy 模块计算两个字符串之间的相似度/doc.html">使用 fuzzywuzzy 模块计算两个字符串之间的相似度</a></li><li class="chapter-item expanded "><a href="../命令行解析工具 argparse/doc.html">命令行解析工具 argparse</a></li><li class="chapter-item expanded "><a href="../使用 urllib.parse 模块优雅地处理 URL/doc.html">使用 urllib.parse 模块优雅地处理 URL</a></li><li class="chapter-item expanded "><a href="../Python 实现复制粘贴/doc.html">Python 实现复制粘贴</a></li><li class="chapter-item expanded "><a href="../Python 生成、解析二维码/doc.html">Python 生成、解析二维码</a></li><li class="chapter-item expanded "><a href="../解密 __getattr__ 和 __getattribute__ 的用法与区别/doc.html">解密 __getattr__ 和 __getattribute__ 的用法与区别</a></li><li class="chapter-item expanded "><a href="../使用 fcntl 模块对文件进行加解锁/doc.html">使用 fcntl 模块对文件进行加解锁</a></li><li class="chapter-item expanded "><a href="../详解新一代 HTTP 请求库：httpx/doc.html">详解新一代 HTTP 请求库：httpx</a></li><li class="chapter-item expanded "><a href="../通过 contextlib 模块详细复习一下 with 语句的用法/doc.html">通过 contextlib 模块详细复习一下 with 语句的用法</a></li><li class="chapter-item expanded "><a href="../使用 collections 模块扩展你的数据类/doc.html">使用 collections 模块扩展你的数据类</a></li><li class="chapter-item expanded "><a href="../使用 unicodedata 模块对字符串标准化/doc.html">使用 unicodedata 模块对字符串标准化</a></li><li class="chapter-item expanded "><a href="../使用 struct 模块打包、解包二进制数据/doc.html">使用 struct 模块打包、解包二进制数据</a></li><li class="chapter-item expanded "><a href="../使用 watchfiles 模块监控目录变更/doc.html">使用 watchfiles 模块监控目录变更</a></li><li class="chapter-item expanded "><a href="../读取照片的 Exif 信息/doc.html">读取照片的 Exif 信息</a></li><li class="chapter-item expanded "><a href="../模拟 TLS 指纹实现反反爬/doc.html">模拟 TLS 指纹实现反反爬</a></li><li class="chapter-item expanded "><a href="../生成词云/doc.html">生成词云</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 实用技巧</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/satori1995/python-tech" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="楔子"><a class="header" href="#楔子">楔子</a></h2>
<p>在开发过程中，配置文件是少不了的，只不过我们有时会将 py 文件作为配置文件（config.py），然后在其它的模块中直接导入。这样做是一个好主意，不过配置文件是有专门的格式的，比如：ini, yaml, toml 等等。</p>
<p>而对于 Python 而言，也都有相应的库来解析相应格式的文件，下面来看一看。</p>
<h2 id="ini-文件"><a class="header" href="#ini-文件">ini 文件</a></h2>
<p>先来了解一下 ini 文件的格式：</p>
<pre><code class="language-ini">[satori]
name = 古明地觉
age = 16
where = 东方地灵殿

[koishi]
name = 古明地恋
age = 15
where = 东方地灵殿

[marisa]
name = 雾雨魔理沙
age = 17
where = 魔法森林

; 以分号或井号开头表示注释，不影响
</code></pre>
<p>ini 文件总分可以分为三块，分别是：</p>
<ul>
<li>section：就是写在 [] 里面的内容，可以把它理解为一个段；</li>
<li>parameter：以 key = value 的形式出现，比如 age = 16，那么 age 就是 key、16 就是 value，注意：每个 section 都有自己的 parameter；</li>
<li>注释：以分号开头，无影响，会被忽略掉。</li>
</ul>
<p>可以看到结构还是比较清晰的，那么 Python 要如何解析呢？Python 解析 ini 文件需要使用一个名叫 configparser 的库，这个库是自带的，我们可以直接用。</p>
<pre><code class="language-python">import configparser

# 实例化一个 ConfigParser 实例
config = configparser.ConfigParser()
# 打开 ini 文件
config.read(&quot;cfg.ini&quot;, encoding=&quot;utf-8&quot;)

# 获取所有的 section
print(config.sections())
&quot;&quot;&quot;
['satori', 'koishi', 'marisa']
&quot;&quot;&quot;

# 获取某一个 section 的所有 parameter
print(config[&quot;satori&quot;])
&quot;&quot;&quot;
&lt;Section: satori&gt;
&quot;&quot;&quot;

# 我们可以像操作字典一样操作 parameter
print(list(config[&quot;satori&quot;]))
&quot;&quot;&quot;
['name', 'age', 'where']
&quot;&quot;&quot;
print(list(config[&quot;satori&quot;].values()))
&quot;&quot;&quot;
['古明地觉', '16', '东方地灵殿']
&quot;&quot;&quot;
print(list(config[&quot;satori&quot;].items()))
&quot;&quot;&quot;
[('name', '古明地觉'), ('age', '16'), ('where', '东方地灵殿')]
&quot;&quot;&quot;
# 获取某个 key 对应的 value
# 如果 key 不存在则抛出 KeyError
print(config[&quot;marisa&quot;][&quot;where&quot;])
&quot;&quot;&quot;
魔法森林
&quot;&quot;&quot;
# 也可以调用 get 方法
# 在 key 不存在时，指定一个默认值
print(config[&quot;marisa&quot;].get(&quot;age&quot;))
&quot;&quot;&quot;
17
&quot;&quot;&quot;
# 我们发现 age 居然是一个字符串
# 因为默认解析得到的都是字符串
print(config[&quot;marisa&quot;][&quot;age&quot;].__class__)
&quot;&quot;&quot;
&lt;class 'str'&gt;
&quot;&quot;&quot;

# 可以通过 getint 获取
# 会将 value 转成整型，但转化失败的话会报错
# 除了 getint 之外，还有 getfloat、getboolean
print(config[&quot;marisa&quot;].getint(&quot;age&quot;) == 17)
&quot;&quot;&quot;
True
&quot;&quot;&quot;

# 最后也可以直接转成字典
print(dict(config[&quot;koishi&quot;]))
&quot;&quot;&quot;
{'name': '古明地恋', 'age': '15', 'where': '东方地灵殿'}
&quot;&quot;&quot;
print(dict(config))
&quot;&quot;&quot;
{'DEFAULT': &lt;Section: DEFAULT&gt;, 
 'satori': &lt;Section: satori&gt;, 
 'koishi': &lt;Section: koishi&gt;, 
 'marisa': &lt;Section: marisa&gt;}
&quot;&quot;&quot;
print({k: dict(v) for k, v in config.items()})
&quot;&quot;&quot;
{'DEFAULT': {}, 
 'satori': {'name': '古明地觉', 
            'age': '16', 
            'where': '东方地灵殿'}, 
 'koishi': {'name': '古明地恋', 
            'age': '15', 
            'where': '东方地灵殿'}, 
 'marisa': {'name': '雾雨魔理沙', 
            'age': '17', 
            'where': '魔法森林'}}
&quot;&quot;&quot;
</code></pre>
<p>可以看到还是比较容易的，因为 ini 这种文件格式本身就很简单。除了读取文件，我们还可以进行写入。</p>
<pre><code class="language-python">import configparser

# 实例化一个 ConfigParser 类的实例
config = configparser.ConfigParser()
config[&quot;basic&quot;] = {&quot;Host&quot;: &quot;127.0.0.1&quot;,
                   &quot;Port&quot;: &quot;8888&quot;,
                   &quot;Username&quot;: &quot;satori&quot;}

config[&quot;thread&quot;] = {}
config[&quot;thread&quot;][&quot;name&quot;] = &quot;my_thread&quot;
config[&quot;thread&quot;][&quot;num&quot;] = &quot;3&quot;

with open(&quot;cfg.ini&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
    config.write(f)
</code></pre>
<p><img src="./1.png" alt="" /></p>
<p>虽然成功写入了，但是我们看到结果变成了小写。是的，对于 parameter 来说，无论是大写还是小写，写入文件的时候都会变成小写。然后读取也是，无论 ini 文件中是大写还是小写，读取之后都会变成小写。</p>
<blockquote>
<p>注意：大小写不敏感只是针对于 parameter，对于 section 来说还是区分大小写的。</p>
</blockquote>
<h3 id="特殊格式"><a class="header" href="#特殊格式">特殊格式</a></h3>
<p>我们上面配置的 parameter 中的 key, value 都是一个普通的单词，但其实还可以配置的更加复杂一些。</p>
<p><img src="./2.png" alt="" /></p>
<p>我们操作一波，看看能否正常解析。</p>
<pre><code class="language-python">import configparser

# 实例化一个 ConfigParser 实例
config = configparser.ConfigParser()
# 打开 ini 文件
config.read(&quot;cfg.ini&quot;, encoding=&quot;utf-8&quot;)

print(dict(config[&quot;简单值&quot;]))
&quot;&quot;&quot;
{'键': '值', 
 '键 里面 有空格': '合法', 
 '值 里面 有空格': '也 合 法', 
 '等号 周围 有 空格': '仍然合法', 
 '你也使用': '代替等号'}
&quot;&quot;&quot;

print(dict(config[&quot;所有值都是字符串&quot;]))
&quot;&quot;&quot;
{'这是字符串': '123', 
 '这也是字符串': '3.14', 
 '整数、浮点数、布尔值都是字符串': 'true'}
&quot;&quot;&quot;
# true True yes 都可以转成布尔值 True
# false False no 都可以转成布尔值 False
print(config[&quot;所有值都是字符串&quot;].getboolean(
    '整数、浮点数、布尔值都是字符串'))
&quot;&quot;&quot;
True
&quot;&quot;&quot;

print(dict(config[&quot;值占多行&quot;]))
&quot;&quot;&quot;
{'洪世贤': '你怎么穿品如的衣服啊\n还用人东西'}
&quot;&quot;&quot;

print(dict(config[&quot;值为空字符串&quot;]))
&quot;&quot;&quot;
{'key1': '', 'key2': ''}
&quot;&quot;&quot;
</code></pre>
<p>结果是正常的，但是很明显上面这种做法有点闲的没事了，以后就统一写成 key = value 的形式即可。另外如果 ini 文件中只有 key 没有 value 的话，默认是报错的，但可以通过一个参数改变这一点：</p>
<pre><code class="language-python">import configparser

# &quot;key =&quot; 这种形式不叫没有值，它是有值的，值为空字符串
# &quot;key&quot; 这种形式才是没有值，解析的时候默认会报错
# 可以通过一个参数改变这一点
config = configparser.ConfigParser(allow_no_value=True)
config.read_string(
    &quot;&quot;&quot;
[mysqld]
user = mysql
skip-bdb
&quot;&quot;&quot;)
print(dict(config[&quot;mysqld&quot;]))
&quot;&quot;&quot;
{'user': 'mysql', 'skip-bdb': None}
&quot;&quot;&quot;
</code></pre>
<p>除此之外，key 之间还可以发生引用。</p>
<pre><code class="language-python">import configparser

config = configparser.ConfigParser()

# 可以通过 %(key)s 的方式对同一个 section 中的其它 key 进行引用
# 所以如果想表示一个 % 的话，需要写两个 %，因为涉及到转义
config.read_string(&quot;&quot;&quot;
[section1]
user = 古明地觉
age = 16
info = %(user)s--%(age)s 
percent = 80%% 
&quot;&quot;&quot;)

print(dict(config[&quot;section1&quot;]))
&quot;&quot;&quot;
{'user': '古明地觉', 'age': '16', 
 'info': '古明地觉--16', 'percent': '80%'}
&quot;&quot;&quot;
</code></pre>
<p>还是很简单的，如果想引用其它的 section 中的 key 要怎么做呢？</p>
<pre><code class="language-python">import configparser

# 指定该参数之后，我们就不能通过 %(age)s 的方式引用了
# 需要使用 ${age} 这种格式，显然更方便了
config = configparser.ConfigParser(
    interpolation=configparser.ExtendedInterpolation()
)

config.read_string(&quot;&quot;&quot;
[DEFAULT]
默认的 = 自动加入到每一个 section 中

[section1]
user = 古明地觉
age = 16
info = ${user} -- ${age} 

[section2]
info = ${section1:user}, ${section1:age}
&quot;&quot;&quot;)

print(dict(config[&quot;section1&quot;]))
&quot;&quot;&quot;
{'user': '古明地觉', 
 'age': '16', 
 'info': '古明地觉 -- 16', 
 '默认的': '自动加入到每一个 section 中'}
&quot;&quot;&quot;
print(dict(config[&quot;section2&quot;]))
&quot;&quot;&quot;
{'info': '古明地觉, 16', 
 '默认的': '自动加入到每一个 section 中'}
&quot;&quot;&quot;
</code></pre>
<p>以上就是 ini 文件的一些简单用法，以后我们在写配置的时候，不妨使用一些专门用来表示配置的文件格式，不一定非要写在 py 文件里面。</p>
<p>而且使用 ini 等配置文件的一个好处就是，即便不懂 Python 的人也能看懂；或者这个配置文件不一定是要由你来写，可能是别人写，而那个人不用 Python，但是通过 ini 文件的话就省去了沟通的成本。</p>
<h2 id="yaml-文件"><a class="header" href="#yaml-文件">yaml 文件</a></h2>
<p>yaml 的表达能力比 ini 更加强大，该文件以 .yml 结尾，在介绍它的语法结构之前我们先来看看 yaml 的一些基本规则。</p>
<ul>
<li>大小写敏感；</li>
<li>使用缩进表示层级关系，并且缩进只能用空格、不可以使用 tab 键。缩进的空格数目不重要，只要相同层级的元素左侧对齐即可；</li>
<li># 表示注释，# 到行尾的所有字符都会被忽略；</li>
</ul>
<p>yaml 支持的数据结构有以下三种：</p>
<ul>
<li>字典：键值对的集合；</li>
<li>数组：多个元素组成的集合；</li>
<li>标量：单个、不可分割的值；</li>
</ul>
<p>Python 解析 yaml 则是通过一个名为 pyyaml 的库，直接 pip install pyyaml 即可。</p>
<p>下面我们来介绍一下 yaml 的数据结构。</p>
<h3 id="字典"><a class="header" href="#字典">字典</a></h3>
<p>类似于 Python 的字典，使用键值对表示：</p>
<pre><code class="language-yaml">name: satori
# 或者写成下面的形式
{name: satori}
</code></pre>
<p>Python 解析之后会是什么结果呢？</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
name: satori
&quot;&quot;&quot;

# yaml.safe_load：只解析自己信任的输入
# yaml.unsafe_load：不检测输入的安全性
print(yaml.safe_load(config))
&quot;&quot;&quot;
{'name': 'satori'}
&quot;&quot;&quot;

config = &quot;&quot;&quot;
{name: satori}
&quot;&quot;&quot;
print(yaml.safe_load(config))
&quot;&quot;&quot;
{'name': 'satori'}
&quot;&quot;&quot;
</code></pre>
<p>在 yaml 里面，字典的 value 也可以是一个字典：</p>
<pre><code class="language-yaml">info: {name: satori, address: 东方地灵殿}
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
info: {name: satori, address: 东方地灵殿}
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
  'info': {'name': 'satori', 'address': '东方地灵殿'}
}
&quot;&quot;&quot;
</code></pre>
<p>还是很简单的。</p>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<p>一组连字符开头的行，构成一个数组。</p>
<pre><code class="language-yaml">- 古明地觉
- 古明地恋
- 雾雨魔理沙
# - 后面要有空格，或者写成下面的形式
[古明地觉, 古明地恋, 雾雨魔理沙]
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
- 古明地觉
- 古明地恋
- 雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
['古明地觉', '古明地恋', '雾雨魔理沙']
&quot;&quot;&quot;

config = &quot;&quot;&quot;
[古明地觉, 古明地恋, 雾雨魔理沙]
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
['古明地觉', '古明地恋', '雾雨魔理沙']
&quot;&quot;&quot;
</code></pre>
<p>并且数组的子成员也可以是一个数组：</p>
<pre><code class="language-yaml">-
 - 古明地觉
 - 古明地恋
 - 雾雨魔理沙
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
-
  - 古明地觉
  - 古明地恋
  - 雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
[['古明地觉', '古明地恋', '雾雨魔理沙']]
&quot;&quot;&quot;

# 更简洁的写法
config = &quot;&quot;&quot;
- [古明地觉, 古明地恋, 雾雨魔理沙]
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
[['古明地觉', '古明地恋', '雾雨魔理沙']]
&quot;&quot;&quot;
</code></pre>
<p>显然数组也可以放在字典中：</p>
<pre><code class="language-yaml"># 缩进对应的空格数没有要求，但是必须一样
# 对于当前这个键值对而言也可以没有缩进
girl:
    -古明地觉
    -古明地恋
    -雾雨魔理沙
# 或者下面这种形式
girl:[古明地觉,古明地恋,雾雨魔理沙]
# 或者下面这种形式
{girl:[古明地觉,古明地恋, 雾雨魔理沙]}
</code></pre>
<p>Python 解析的结果如下：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
girl:
  - 古明地觉
  - 古明地恋
  - 雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{'girl': ['古明地觉', '古明地恋', '雾雨魔理沙']}
&quot;&quot;&quot;

# 注意：上面的 girl 对应的是数组，因为每个元素前面都有 -
# 但如果没有的话会发生什么？
config = &quot;&quot;&quot;
girl:
    古明地觉
    古明地恋
    雾雨魔理沙
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{'girl': '古明地觉 古明地恋 雾雨魔理沙'}
&quot;&quot;&quot;
# 我们看到整体相当于是一个字符串，类似于 html，之间用一个空格代替
# 因此如果内容比较长，我们可以写成多行，但是注意：每一行前面必须有空格
</code></pre>
<p>然后是一个稍微复杂的例子：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
girl:
    # 会对应一个数组
    - 古明地觉
    - 古明地恋
    - 雾雨魔理沙
    
place1:
    # 虽然不是数组，但是内部是字典的形式
    # 所以会对应一个含有三个键值对的字典
    古明地觉: 东方地灵殿
    古明地恋: 东方地灵殿
    雾雨魔理沙: 魔法森林

place2:
  # 是数组，数组里面每个元素是一个字典
  - 古明地觉: 东方地灵殿
  - 古明地恋: 东方地灵殿
  - 雾雨魔理沙: 魔法森林
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
    'girl': ['古明地觉', '古明地恋', '雾雨魔理沙'],
    'place1': {'古明地觉': '东方地灵殿', 
               '古明地恋': '东方地灵殿', 
               '雾雨魔理沙': '魔法森林'},
    'place2': [{'古明地觉': '东方地灵殿'}, 
               {'古明地恋': '东方地灵殿'}, 
               {'雾雨魔理沙': '魔法森林'}]
}
&quot;&quot;&quot;
</code></pre>
<p>place1 对应的是一个字典，place2 对应的是一个数组。</p>
<h3 id="标量"><a class="header" href="#标量">标量</a></h3>
<p>标量属于最基本的、不可再分的值，比较简单，我们就全部都说了吧。</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
int: 123
float: 3.14
bool:
    - true 
    - false
# 波浪号表示空    
NoneType: ~  
datetime: 2020-11-11 12:12:13

# 使用两个 ! 可以进行类型强转
# 不过几乎用不到 
cast:
    - !!str 123
    - !!str true  
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
    'int': 123, 'float': 3.14,
    'bool': [True, False], 'NoneType': None,
    'datetime': datetime.datetime(2020, 11, 11, 12, 12, 13), 
    'cast': ['123', 'true']
}
&quot;&quot;&quot;
</code></pre>
<p>这里可能有人已经发现了，就是字符串不需要加引号，但如果里面有特殊字符怎么办？所以 yaml 是支持使用引号括起来的。</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
name1: 古明地觉      a x   $ #  !!        
name2: &quot;古明地觉      a x   $ #  !!&quot;        
name3: '古明地觉      a x   $ #  !!'   
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{'name1': '古明地觉      a x   $', 
 'name2': '古明地觉      a x   $ #  !!', 
 'name3': '古明地觉      a x   $ #  !!'}
&quot;&quot;&quot;
</code></pre>
<p>对于 yaml 而言，字符串默认是从第一个不是空格的字符、匹配到最后一个不是空格的字符（如果遇到 # 直接停止）。因此如果 value 的前面或后面有空格的话，那么这些空格是不会显示的，或者当中有 #，那么 # 后面的内容也不会显示。</p>
<p>解决办法是使用单引号或双引号括起来，如果内部还有引号，那么需要输入两遍进行转义（如果内部的引号和外面括起来的引号相同的话）。</p>
<h3 id="引用"><a class="header" href="#引用">引用</a></h3>
<p>对于 yaml 而言，还支持我们采用 &amp; 和 * 进行引用，举个例子：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
# 多了一个 &amp;db_info_ref
# 相当于起了个名字，叫 db_info_ref
db_info: &amp;db_info_ref  
    host: 127.0.0.1
    port: 5432
    user: postgres
    password: 123456

deploy:
    os: Linux
    # 将内容直接扔到里面来  
    &lt;&lt;: *db_info_ref  
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
{
    'db_info': {'host': '127.0.0.1',
                'port': 5432,
                'user': 'postgres',
                'password': 123456},
    'deploy': {'host': '127.0.0.1',
               'port': 5432,
               'user': 'postgres',
               'password': 123456,
               'os': 'Linux'}
}
&quot;&quot;&quot;
</code></pre>
<p>&amp; 用来建立锚点，&lt;&lt; 表示合并当前数据，* 表示用来引用锚点。还可以作用在数组中：</p>
<pre><code class="language-python">import yaml

config = &quot;&quot;&quot;
- &amp;name 古明地觉 
- 古明地恋
- 雾雨魔理沙
- *name
&quot;&quot;&quot;

print(yaml.safe_load(config))
&quot;&quot;&quot;
['古明地觉', '古明地恋', 
 '雾雨魔理沙', '古明地觉']
&quot;&quot;&quot;
</code></pre>
<h3 id="生成-yaml-文件"><a class="header" href="#生成-yaml-文件">生成 yaml 文件</a></h3>
<p>既然能够读取 yaml 文件，那么自然也能生成 yaml 文件。</p>
<pre><code class="language-python">import yaml

data = {
    &quot;girl&quot;: [
        {&quot;name&quot;: &quot;古明地觉&quot;, &quot;age&quot;: 17, &quot;place&quot;: &quot;东方地灵殿&quot;},
        {&quot;name&quot;: &quot;古明地恋&quot;, &quot;age&quot;: 16, &quot;place&quot;: &quot;东方地灵殿&quot;},
        {&quot;name&quot;: &quot;雾雨魔理沙&quot;, &quot;age&quot;: 16, &quot;place&quot;: &quot;魔法森林&quot;}
    ],
    &quot;other&quot;: {
        &quot;古明地觉&quot;: {&quot;nickname&quot;: [&quot;小五&quot;, &quot;少女觉&quot;, &quot;觉大人&quot;, &quot;小五萝莉&quot;], &quot;length&quot;: 155},
        &quot;古明地恋&quot;: {&quot;nickname&quot;: [&quot;恋恋&quot;], &quot;length&quot;: 155},
        &quot;雾雨魔理沙&quot;: {&quot;nickname&quot;: [&quot;摸你傻&quot;], &quot;length&quot;: 155}
    }
}

with open(&quot;cfg.yml&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
    yaml.dump(data, f, allow_unicode=True, indent=2)
</code></pre>
<p>然后我们看看生成的 yml 文件长什么样子。</p>
<p><img src="./3.png" alt="" /></p>
<p>我们来看 yml 文件，然后反推出相应的数据结构。首先整体是一个字典，里面有 girl 和 other 两个 key。其中 girl 对应一个数组，数组里面每个元素都是字典，这是符合预期的。</p>
<p>然后 other 对应一个字典，而且这个字典内部有三个键值对，key 分别是：古明地觉、古明地恋、雾雨魔理沙，各自对应的 value 又是一个字典（内部有 length、nickname 两个 key，其中 length 对应整型、nickname 对应列表）。</p>
<p>最后再看一个本人之前项目中的 yml 文件，可以猜猜看解析出来长什么样子。</p>
<p><img src="./4.png" alt="" /></p>
<p>解析一下看看和你想的是不是一样的。</p>
<pre><code class="language-python">import yaml

with open(&quot;.gitlab-ci.yml&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
    data = f.read()

data = yaml.safe_load(data)
print(data)
&quot;&quot;&quot;
{
    'stages': ['test'], 
    'cache': {'key': '${CI_COMMIT_REF_SLUG}', 
              'paths': ['.cache/pip']},
    'variables': {'PIP_CACHE_DIR': '$CI_PROJECT_DIR/.cache/pip'},
    'test': {'stage': 'test', 
             'image': 'xxxxxxx/python:3.8.1-thanosclient-buster', 
             'only': ['branches', 'tags'],
             'services': ['mysql:5.7'],
             'variables': {'PROJECT': 'XXXXXX', 
                           'PIP_CACHE_DIR': '$CI_PROJECT_DIR/.cache/pip',
                           'MARKETING_CONFIG': 'config/room/ci.cn-gz.toml',
                           'MYSQL_DATABASE': 'activity', 
                           'MYSQL_ROOT_PASSWORD': 'password',
                           'MYSQL_INITDB_SKIP_TZINFO': '1'}
             }
}
&quot;&quot;&quot;
</code></pre>
<p>结果应该不难想，毕竟 yaml 文件不是很复杂。</p>
<h2 id="toml-文件"><a class="header" href="#toml-文件">toml 文件</a></h2>
<p>虽然 yaml 的表达能力已经很丰富了，但 GitHub 觉得还是不够优雅，所以鼓捣出了一个 toml。toml 有着比 yaml 更简洁的语法，它的目标就是成为一个最简单的配置文件格式。然后 Python 解析 toml 文件需要使用一个名字也叫 toml 的库，直接 pip install toml 即可。</p>
<p>有了 ini 和 yaml，相信 toml 学习来也很简单，先直接看一个例子吧。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
title = &quot;toml 小栗子&quot;

[owner]
name = &quot;古明地觉&quot;
age = 17
place = &quot;东方地灵殿&quot;
nickname = [&quot;小五&quot;, &quot;少女觉&quot;, &quot;觉大人&quot;]

[database]
host = &quot;127.0.0.1&quot;
port = 5432
username = &quot;satori&quot;
password = &quot;123456&quot;
echo = true

[server]
    [server.v1]
    api = &quot;1.1&quot;
    enable = false
    
    [server.v2]
    api = &quot;1.2&quot;
    enable = true

[client]
client = [
    [&quot;socket&quot;, &quot;webservice&quot;], 
    [5555]
]
address = [
    &quot;xxxx&quot;,
    &quot;yyyy&quot;
]
&quot;&quot;&quot;

# loads：从字符串加载
# load：从文件加载
# dumps：生成 toml 格式字符串
# dump：生成 toml 格式字符串并写入文件中
data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'title': 'toml 小栗子', 
    'owner': {'name': '古明地觉', 
              'age': 17, 
              'place': '东方地灵殿', 
              'nickname': ['小五', '少女觉', '觉大人']},
    'database': {'host': '127.0.0.1', 
                 'port': 5432,
                 'username': 'satori', 
                 'password': '123456', 
                 'echo': True},
    'server': {'v1': {'api': '1.1', 'enable': False}, 
               'v2': {'api': '1.2', 'enable': True}},
    'client': {'client': [['socket', 'webservice'], [5555]], 
               'address': ['xxxx', 'yyyy']}
}
&quot;&quot;&quot;
</code></pre>
<p>toml 是采用 <code>var = value</code> 的形式进行配置，然后也有类似于 ini 里面的 section，每个 section 都是字典中的一个 key，然后该 key 也对应一个字典。但是我们注意看最开始的 title，由于它上面没有 section，所以它是一个单独的 key。</p>
<p>而且还有一点就是 toml 支持嵌套，我们看到 server.v1，表示 v1 是 server 对应的字典里面的一个 key，然后 v1 对应的值还是一个字典。</p>
<p>toml 变得更加简单了，而且写来也非常像 Python，它有如下特点：</p>
<ul>
<li>toml 文件是大小写敏感的；</li>
<li>toml 文件必须是有效的 UTF-8 编码的 Unicode 文档；</li>
<li>toml 文件的空白符应该是 Tab 或者空格；</li>
<li>toml 文件的换行是 LF 或者 CRLF；</li>
</ul>
<p>然后我们来介绍一下 toml 的数据结构。</p>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<p>toml 采用 # 表示注释，举个例子：</p>
<pre><code class="language-toml"># 这是注释
key = &quot;value&quot;  # 也是注释
</code></pre>
<p>可以解析一下看看会得到什么，剧透：会得到只包含一个键值对的字典。</p>
<h3 id="键值对"><a class="header" href="#键值对">键值对</a></h3>
<p>TOML 文档最基本的构成区块是键值对，键名在等号的左边、值在右边，并且键名和键值周围的空白会被忽略。此外键、等号和值必须在同一行（不过有些值可以跨多行）。</p>
<pre><code class="language-toml">key = &quot;value&quot;
</code></pre>
<p>键名可以是裸露的（裸键），引号引起来的（引号键），或点分隔的（点分隔键）。裸键只能包含：ascii 字符、ascii 数字、下划线、短横线。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
key = &quot;value&quot;
bare_key = &quot;value&quot;
bare-key = &quot;value&quot;
# 1234 会被当成字符串
1234 = &quot;value&quot;  
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'key': 'value', 
 'bare_key': 'value', 
 'bare-key': 'value', 
 '1234': 'value'}
&quot;&quot;&quot;
</code></pre>
<p>如果不是裸键，那么就必须使用引号括起来，但是此时也支持我们使用更加广泛的键名，但除了特殊场景，否则使用裸键是最佳实践。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
&quot;127.0.0.1&quot; = &quot;value&quot;
&quot;character encoding&quot; = &quot;value&quot;
&quot;ʎǝʞ&quot; = &quot;value&quot;
'key2' = &quot;value&quot;
'quoted &quot;value&quot;' = &quot;value&quot; 
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'127.0.0.1': 'value', 
 'character encoding': 'value', 
 'ʎǝʞ': 'value', 
 'key2': 'value', 
 'quoted &quot;value&quot;': 'value'}
&quot;&quot;&quot;
</code></pre>
<p>注意：裸键不能为空，但空引号键是允许的（虽然不建议如此）。</p>
<pre><code class="language-toml">= &quot;没有键名&quot;  # 错误
&quot;&quot; = &quot;空&quot;     # 正确但不鼓励
'' = '空'     # 正确但不鼓励
</code></pre>
<p>然后是点分隔键，它是一系列通过点相连的裸键或引号键，这允许我们将相近属性放在一起：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
name = &quot;橙子&quot;
physical.color = &quot;橙色&quot;
physical.shape = &quot;圆形&quot;
site.&quot;google.com&quot; = true
site.google.com = true
a.b.c.d = 123
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'name': '橙子',
    'physical': {'color': '橙色',
                 'shape': '圆形'},
    'site': {'google.com': True,
             'google': {'com': True}},
    'a': {'b': {'c': {'d': 123}}}
}
&quot;&quot;&quot;
</code></pre>
<p>我们看到这个点分隔符不错哟，自动实现了嵌套结构，并且点分隔符周围的空白会被忽略。</p>
<pre><code class="language-toml">fruit.name = &quot;香蕉&quot;     # 这是最佳实践
fruit. color = &quot;黄色&quot;    # 等同于 fruit.color
fruit . flavor = &quot;香蕉&quot;   # 等同于 fruit.flavor
</code></pre>
<p>注意：多次定义同一个键是不行的。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# name 和 &quot;name&quot; 是等价的
name = &quot;古明地觉&quot;
&quot;name&quot; = &quot;古明地恋&quot;  
&quot;&quot;&quot;

try:
    data = toml.loads(config)
except toml.decoder.TomlDecodeError as e:
    print(e)
&quot;&quot;&quot;
Duplicate keys! (line 4 column 1 char 36)
&quot;&quot;&quot;
</code></pre>
<p>对于点分隔键也是如此，只要一个键还没有被直接定义过，我们就仍可以对它和它下属的键名赋值。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
fruit.apple.smooth = true# 此时可以继续操作 fruit、fruit.apple，它们都是字典
# 给 fruit 这个字典加一个 key  
fruit.orange = 2  
# 给 fruit.apple 加一个 key
fruit.apple.color = &quot;red&quot;   
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'fruit': {'apple': {'smooth': True, 
                        'color': 'red'}, 
              'orange': 2}
}
&quot;&quot;&quot;
</code></pre>
<p>但下面这个操作是不行的：</p>
<pre><code class="language-toml"># 将 fruit.apple 的值定义为一个整数
fruit.apple = 1
# 但接下来就不合法了，因为整数不能变成字典
fruit.apple.smooth = true

# 如果我们设置 fruit.apple = {}，那么第二个赋值是可以的
# 没错，我们可以通过 {} 直接创建一个字典
</code></pre>
<p>可以看到，真的很像 Python。然后再来说一个特例：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
3.14 = &quot;pi&quot;  
&quot;3.14&quot; = &quot;pi&quot;  
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'3': {'14': 'pi'}, '3.14': 'pi'}
&quot;&quot;&quot;
</code></pre>
<p>如果键是浮点数，那么需要使用引号括起来，否则会被解释为点分隔键。</p>
<p>看完了键，再来看看值（value），其实对于 toml 来说，值比键要简单的多得多。</p>
<h3 id="字符串"><a class="header" href="#字符串">字符串</a></h3>
<p>字符串共有四种方式来表示：基础式的，多行基础式的，字面量式的，和多行字面量式的。</p>
<p><strong>1）基础字符串由引号包裹，任何 Unicode 字符都可以使用，除了那些必须转义的。</strong></p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
str = '我是一个字符串，&quot;你可以把我引起来&quot;' 
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'str': '我是一个字符串，&quot;你可以把我引起来&quot;'}
&quot;&quot;&quot;
</code></pre>
<p><strong>2）多行字符串由三个引号包裹，允许换行，注意：紧随开头引号的换行会被去除，其它空白和换行会被原样保留。</strong></p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
str = '''
玫瑰是红色的
紫罗兰是蓝色的
'''
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'str': '玫瑰是红色的\n紫罗兰是蓝色的\n'}
&quot;&quot;&quot;
</code></pre>
<p>这里的引号可以是双引号、也可以是单引号。</p>
<h3 id="整数"><a class="header" href="#整数">整数</a></h3>
<p>整数是纯数字，正数可以有加号前缀，负数的前缀是减号。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
int1 = +99
int2 = 42
int3 = 0
int4 = -17

# 对于大数，可以在数字之间用下划线来增强可读性
# 每个下划线两侧必须至少有一个数字。
int5 = 1_000
int6 = 5_349_221
int7 = 53_49_221  # 印度记数体系分组
int8 = 1_2_3_4_5  # 无误但不鼓励
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'int1': 99,
 'int2': 42,
 'int3': 0,
 'int4': -17,
 'int5': 1000,
 'int6': 5349221,
 'int7': 5349221,
 'int8': 12345}
&quot;&quot;&quot;
</code></pre>
<p>但是注意：数字不能以零开头，除了 0 本身。当然 -0 与 +0 也是有效的，并等同于无前缀的零。非负整数值也可以用十六进制、八进制或二进制来表示。</p>
<pre><code class="language-python"># 带有 `0x` 前缀的十六进制，大小写均可
hex1=0xDEADBEEF
hex2=0xdeadbeef
hex3=0xdead_beef

# 带有 `0o` 前缀的八进制
oct1=0o01234567
oct2=0o755# 对于表示 Unix 文件权限很有用

# 带有 `0b` 前缀的二进制
bin1= 0b11010110
</code></pre>
<h3 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h3>
<p>一个浮点数由一个整数部分（遵从与十进制整数值相同的规则）后跟上一个小数部分、或一个指数部分组成。如果小数部分和指数部分兼有，那小数部分必须在指数部分前面。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 小数
flt1 = +1.0
flt2 = 3.1415
flt3 = -0.01

# 指数
flt4 = 5e+22
flt5 = 1e06
flt6 = -2E-2

flt7 = 6.626e-34
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'flt1': 1.0,
 'flt2': 3.1415,
 'flt3': -0.01,
 'flt4': 5e+22,
 'flt5': 1000000.0,
 'flt6': -0.02,
 'flt7': 6.626e-34}
&quot;&quot;&quot;
</code></pre>
<p>小数部分是一个小数点后跟一个或多个数字，一个指数部分是一个 E（大小写均可）后跟一个整数部分（遵从与十进制整数值相同的规则，但可以包含前导零）。小数点，如果有用到的话，每侧必须紧邻至少一个数字。</p>
<pre><code class="language-python"># 非法的浮点数
invalid_float_1 = .7
invalid_float_2 = 7.
invalid_float_3 = 3.e+20
</code></pre>
<p>与整数相似，可以使用下划线来增强可读性，每个下划线必须被至少一个数字围绕。</p>
<pre><code class="language-python">flt8 = 224_617.445_991_228
</code></pre>
<p>浮点数值 -0.0 与 +0.0 是有效的，并且应当遵从 IEEE 754。特殊浮点值也能够表示：</p>
<pre><code class="language-python"># 无穷
sf1=inf  # 正无穷
sf2=+inf  # 正无穷
sf3=-inf  # 负无穷

# 非数
sf4=nan  # 是对应信号非数码还是静默非数码，取决于实现
sf5=+nan  # 等同于 `nan`
sf6=-nan  # 正确，实际码取决于实现
</code></pre>
<h3 id="布尔值"><a class="header" href="#布尔值">布尔值</a></h3>
<p>布尔值就是惯用的那样，但要小写。</p>
<pre><code class="language-toml">bool1 = true
bool2 = false
</code></pre>
<h3 id="日期"><a class="header" href="#日期">日期</a></h3>
<p>可以是普通的 datetime，或者是遵循 ISO-8859-1 格式的日期。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
dt1 = 2020-01-01T12:33:22+00:00
dt2 = 2020-11-12 12:11:33
dt3 = 2020-11-23
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'dt1': datetime.datetime(2020, 1, 1, 12, 33, 22, tzinfo=...), 
 'dt2': datetime.datetime(2020, 11, 12, 12, 11, 33), 
 'dt3': datetime.date(2020, 11, 23)}
&quot;&quot;&quot;
</code></pre>
<h3 id="数组-1"><a class="header" href="#数组-1">数组</a></h3>
<p>语法和 Python 的列表类似：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 每个数组里面的元素类型要一致
integers = [1, 2, 3]
colors = [&quot;红&quot;, &quot;黄&quot;, &quot;绿&quot;]
nested_array_of_ints = [[1, 2], [3, 4, 5]]
nested_mixed_array = [[1, 2], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]]
numbers = [0.1, 0.2, 0.5]
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'colors': ['红', '黄', '绿'],
 'integers': [1, 2, 3],
 'nested_array_of_ints': [[1, 2], [3, 4, 5]],
 'nested_mixed_array': [[1, 2], ['a', 'b', 'c']],
 'numbers': [0.1, 0.2, 0.5]}
&quot;&quot;&quot;
</code></pre>
<p>数组可以跨行，数组的最后一个值后面可以有终逗号（也称为尾逗号）。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
integers2 = [
  1, 2, 3
]

integers3 = [
  1,
  2, # 这是可以的
]
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'integers2': [1, 2, 3], 'integers3': [1, 2]}
&quot;&quot;&quot;
</code></pre>
<h3 id="表"><a class="header" href="#表">表</a></h3>
<p>表，完全可以把它想象成 ini 的 section。</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 表名的定义规则与键名相同
# 解析之后得到的大字典中就有 &quot;table-1&quot; 这个 key
# 并且其 value 也是一个表，在它下方
# 直至下一个表头或文件结束，都是这个表内部的键值对
[table-1]
key1 = &quot;some string&quot;
key2 = 123

[table-2]
key1 = &quot;another string&quot;
key2 = 456
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'table-1': {'key1': 'some string', 'key2': 123},
 'table-2': {'key1': 'another string', 'key2': 456}}
&quot;&quot;&quot;
</code></pre>
<p>但是我们之前也实现过类似于这种结构，没错，就是点分隔符：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 所以 other-table-1 和 table-1 是等价的
# other-table-2 和 table-2 是等价的
other-table-1.key1 = &quot;some string&quot;
other-table-1.key2 = 123

other-table-2.key1 = &quot;another string&quot;
other-table-2.key2 = 456

[table-1]
key1 = &quot;some string&quot;
key2 = 123

[table-2]
key1 = &quot;another string&quot;
key2 = 456
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'other-table-1': {'key1': 'some string', 'key2': 123},
 'other-table-2': {'key1': 'another string', 'key2': 456},
 'table-1': {'key1': 'some string', 'key2': 123},
 'table-2': {'key1': 'another string', 'key2': 456}}
&quot;&quot;&quot;
</code></pre>
<p>不过注意：我们必须要把 other-table-1 和 other-table-2 定义在上面，如果我们定义在下面看看会有什么后果：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[table-1]
key1 = &quot;some string&quot;
key2 = 123

[table-2]
key1 = &quot;another string&quot;
key2 = 456

other-table-1.key1 = &quot;some string&quot;
other-table-1.key2 = 123

other-table-2.key1 = &quot;another string&quot;
other-table-2.key2 = 456
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'table-1': {'key1': 'some string', 'key2': 123},
    'table-2': {'key1': 'another string',
                'key2': 456,
                'other-table-1': {'key1': 'some string', 
                                  'key2': 123},
                'other-table-2': {'key1': 'another string', 
                                  'key2': 456}}
}
&quot;&quot;&quot;
</code></pre>
<p>估计你已经猜到了，它们被当成了 'table-2' 对应的字典里面的 key 了。此外我们还可以将上面两种方式结合起来：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# [] 里面的不再是一个普通的键，而是点分隔键
# 另外键名周围的空格会被忽略，但是最好不要有
[dog  .  &quot;tater.man&quot;]  
type.name = &quot;哈巴狗&quot;
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'dog': {'tater.man': {'type': {'name': '哈巴狗'}}}
}
&quot;&quot;&quot;
</code></pre>
<p>表的里面也是可以没有键值对的：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[x.y.z.w.a.n]

[x.m]

[x.n]

[x]
a.b.c = &quot;xxx&quot;
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'x':
    {
        'a': {'b': {'c': 'xxx'}},
        'm': {},
        'n': {},
        'y': {'z': {'w': {'a': {'n': {}}}}}
    }
}
&quot;&quot;&quot;
</code></pre>
<p>总的来说还是蛮强大的，但是要注意：不能重复定义。</p>
<h3 id="行内表"><a class="header" href="#行内表">行内表</a></h3>
<p>行内表提供了一种更为紧凑的语法来表示表，因为上面每一个键值对都需要单独写一行，比如：</p>
<pre><code class="language-toml">[table1]
a = 1
b = 2
c = 3
# 最终可以得到 
# {'table1': {'a': 1, 'b': 2, 'c': 3}}
</code></pre>
<p>但是除了上面的表达方式之外，我们还可以采用行内表：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
# 和 Python 字典的表示方式略有不同，并且也支持多种 key
table1 = {a = 1, b = &quot;二&quot;, c.a = &quot;3&quot;}
table2 = {c.&quot;b c&quot;.d = &quot;4&quot;}
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'table1': {'a': 1, 'b': '二', 'c': {'a': '3'}},
    'table2': {'c': {'b c': {'d': '4'}}}
}
&quot;&quot;&quot;
</code></pre>
<h3 id="表数组"><a class="header" href="#表数组">表数组</a></h3>
<p>然后来看看数组和表的结合：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[name1]
girl = &quot;古明地觉&quot;

[[name2]]
girl = &quot;古明地恋&quot;

[name3]
[[name4]]
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{'name1': {'girl': '古明地觉'},
 'name2': [{'girl': '古明地恋'}],
 'name3': {},
 'name4': [{}]}
&quot;&quot;&quot;
</code></pre>
<p>当使用 [[]] 的时候，相当于在 [] 的基础上套上一层列表。并且任何对表数组的引用都指向该数组里最近定义的表元素，这允许我们在最近的表内定义子表，甚至子表数组。</p>
<p>我们再举个更复杂的例子：</p>
<pre><code class="language-python">import toml

config = &quot;&quot;&quot;
[[fruits]]  
name = &quot;苹果&quot;  

# 会操作 [] 里面最近定义的 {}
[fruits.physical]  
color = &quot;红色&quot;
shape = &quot;圆形&quot;

[[fruits.varieties]]  # 嵌套表数组
name = &quot;蛇果&quot;    

[[fruits.varieties]]
name = &quot;澳洲青苹&quot; 

[[fruits]]
name = &quot;香蕉&quot; 

[[fruits.varieties]]
name = &quot;车前草&quot;  
&quot;&quot;&quot;

data = toml.loads(config)
print(data)
&quot;&quot;&quot;
{
    'fruits':
        [
            {
                'name': '苹果',
                'physical': {'color': '红色', 
                             'shape': '圆形'},
                'varieties': [{'name': '蛇果'}, 
                              {'name': '澳洲青苹'}]
            },
            {
                'name': '香蕉', 
                'varieties': [{'name': '车前草'}]
            }
        ]
}
&quot;&quot;&quot;
</code></pre>
<p>很明显这种定义不是很常用，配置文件应该要非常直观才对，但这已经不是很好理解了。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>以上就是几种配置文件相关的内容，其中 ini 文件格式最简单，yaml 文件格式使用最广泛， toml 文件格式的表达能力更加丰富，像 Rust 项目采用的配置文件就是 toml 格式的。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../自定义 jupyter 魔法命令/doc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../使用 fuzzywuzzy 模块计算两个字符串之间的相似度/doc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../自定义 jupyter 魔法命令/doc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../使用 fuzzywuzzy 模块计算两个字符串之间的相似度/doc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../theme/custom.js"></script>
    </body>
</html>
